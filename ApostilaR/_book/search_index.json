[["shiny.html", "Capítulo 8 Shiny 8.1 Introdução ao Shiny 8.2 UI básica 8.3 Reatividade básica 8.4 Layout, temas, HTML 8.5 UI dinâmica 8.6 Publicando aplicativo em shinyapps.io 8.7 Exercícios do Capítulo 8 (Entregar na lista 2)", " Capítulo 8 Shiny 8.1 Introdução ao Shiny Definição: Shiny é um framework para R que permite criar aplicações web interativas diretamente a partir do código R, sem necessidade de conhecimentos em HTML, CSS ou JavaScript. Para começar a trabalhar com Shiny, primeiro instale o pacote: # Instalação do pacote Shiny # install.packages(&quot;shiny&quot;) # Carregando o pacote library(shiny) Para criar um novo app, salvar um script com a extensão .R, exemplo app.R. A partir disso, pode adicionar rapidamente o modelo do aplicativo digitando “shinyapp” e pressionando Shift+Tab. A estrutura de um App Shiny, é composta de: 1. Interface do Usuário (UI): A UI define a aparência do aplicativo - o que o usuário vê e com o que interage. 2. Servidor (Server): O servidor contém a lógica do aplicativo - como ele responde às interações do usuário. 3. Função que combina ambos UI e Server: Para criar o aplicativo, combinamos a UI e o servidor com a função shinyApp(ui = ui, server = server) RunApp: executa o aplicativo Stop (no RStudio) ou fechar a janela do app: encerra o aplicativo 8.1.1 Adicionando controles de UI library(shiny) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Conjunto de Dados&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { } shinyApp(ui, server) fluidPage(): função de layout que define a estrutura visual básica da página. selectInput(): controle de entrada que permite ao usuário interagir com o aplicativo fornecendo um valor. Neste caso, é uma caixa de seleção com o rótulo “Conjunto de Dados” e permite escolher um dos conjuntos de dados que vêm com o R. verbatimTextOutput() e tableOutput(): controles de saída que informam ao Shiny onde colocar a saída renderizada. verbatimTextOutput() exibe código e tableOutput() tabelas. Vemos apenas a entrada, não as duas saídas, porque ainda não informamos ao Shiny como a entrada e as saídas estão relacionadas. 8.1.2 Adicionando comportamento ao Server library(shiny) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Conjunto de Dados&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { output$resumo &lt;- renderPrint({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) summary(dataset) }) output$tabela &lt;- renderTable({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) dataset }) } shinyApp(ui, server) Cada input e output na UI tem identificarodes (IDs). Chamando input$ID e output$ID no servidor é a forma de identificar no shiny uma entrada e uma saída específica, com base no seu ID. output$ID: indica que você está fornecendo a receita para a saída do Shiny com esse ID. Funções de renderização (render{Type}): encapsulam o código fornecido e conectam inputs e outputs. Cada função render{Type} é projetada para produzir um tipo específico de saída (texto, tabelas e gráficos) e geralmente é pareada com uma função {type}Output. Exemplo, renderPrint() é pareado com verbatimTextOutput() e renderTable() é pareado com tableOutput(). Observações: O resumo e a tabela são atualizados sempre que você altera o conjunto de dados de entrada. Essa dependência é criada implicitamente, pois utilizamos input$dataset nas funções de saída. input$dataset é preenchido com o valor atual do componente de interface do usuário com id dataset e fará com que as saídas sejam atualizadas automaticamente sempre que esse valor for alterado. Essa é a essência da reatividade: as saídas reagem (recalculam) automaticamente quando suas entradas são alteradas. 8.1.3 Expressões Reativas São usadas para evitar códigos duplicados. No exemplo anterior, o código a seguir é repetido 2 vezes. dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) Para criar uma expressão reativa: expressao_reativa &lt;- reactive({...}) Para chamar o seu valor, usamos: expressao_reativa(). A expressão reativa só é executada na primeira vez que é chamada e, em seguida, armazena o resultado em cache até que ele precise ser atualizado, deixando o código mais eficiente. Atualizando o app com a expressão reativa: library(shiny) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Conjunto de Dados&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { # Criando uma expressão reativa dataset &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;) }) output$resumo &lt;- renderPrint({ # Chamando-a como uma função summary(dataset()) }) output$tabela &lt;- renderTable({ dataset() }) } shinyApp(ui, server) O aplicativo se comporta de forma idêntica, mas funciona um pouco mais eficientemente, pois só precisa recuperar o conjunto de dados uma vez, e não duas. Exercícios - Seção 8.1 1. Crie um aplicativo que cumprimente o usuário pelo nome. Considerando as funções abaixo, organize e identifique quais delas serão necessárias para esta finalidade. tableOutput(&quot;hipoteca&quot;) output$saudacao &lt;- renderText({ paste0(&quot;Olá &quot;, input$nome) }) numericInput(&quot;idade&quot;, &quot;Quantos anos você tem?&quot;, value = NA) textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;) textOutput(&quot;saudacao&quot;) output$histogram &lt;- renderPlot({ hist(rnorm(1000)) }, res = 96) 2. Suponha que seu amigo queira criar um aplicativo que permita ao usuário definir um número (x) entre 1 e 50 e exiba o resultado da multiplicação desse número por 5. Esta é a primeira tentativa dele: library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;Se x é&quot;, min = 1, max = 50, value = 30), &quot;então x vezes 5 é&quot;, textOutput(&quot;produto&quot;) ) server &lt;- function(input, output, session) { output$produto &lt;- renderText({ x * 5 }) } shinyApp(ui, server) Mas infelizmente tem um erro. Você pode ajudá-lo a encontrar e corrigir o erro? 3. Expanda o aplicativo do exercício anterior para permitir que o usuário defina o valor do multiplicador, y, para que o aplicativo produza o valor de x * y. O resultado final deve ser semelhante a este: 4. Considere o aplicativo a seguir, que adiciona algumas funcionalidades adicionais ao aplicativo descrito no exercício anterior. O que há de novo? Como você poderia reduzir a quantidade de código duplicado no aplicativo usando uma expressão reativa? library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, &quot;Se x é&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, &quot;e y é&quot;, min = 1, max = 50, value = 5), &quot;então, (x * y) é&quot;, textOutput(&quot;produto&quot;), &quot;e, (x * y) + 5 é&quot;, textOutput(&quot;produto_mais5&quot;), &quot;e (x * y) + 10 é&quot;, textOutput(&quot;produto_mais10&quot;) ) server &lt;- function(input, output, session) { output$produto &lt;- renderText({ prod &lt;- input$x * input$y prod }) output$produto_mais5 &lt;- renderText({ prod &lt;- input$x * input$y prod + 5 }) output$produto_mais10 &lt;- renderText({ prod &lt;- input$x * input$y prod + 10 }) } shinyApp(ui, server) 5. No aplicativo a seguir, você seleciona um conjunto de dados de um pacote (usando o pacote ggplot2) e o aplicativo imprime um resumo e um gráfico dos dados. Ele também segue boas práticas e utiliza expressões reativas para evitar redundância de código. No entanto, há três bugs no código fornecido abaixo. Você consegue encontrá-los e corrigi-los? library(shiny) library(ggplot2) datasets &lt;- c(&quot;economics&quot;, &quot;faithfuld&quot;, &quot;seals&quot;) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, &quot;Conjunto de dados:&quot;, choices = datasets), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { dataset &lt;- reactive({ get(input$dataset, &quot;package:ggplot2&quot;) }) output$resummo &lt;- renderPrint({ summary(dataset()) }) output$plot &lt;- renderPlot({ plot(dataset) }, res = 96) } shinyApp(ui, server) Respostas ## 1. library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), textOutput(&quot;saudacao&quot;) ) server &lt;- function(input, output, session) { output$saudacao &lt;- renderText({ paste0(&quot;Olá &quot;, input$nome) }) } shinyApp(ui, server) ## 2. O erro aqui surge porque, no lado do servidor, precisamos escrever input$x em vez de x. ## 3. Vamos adicionar outro sliderInput com ID y e usar ambos input$x e input$y para calcular output$product. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;Se x é&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, label = &quot;e y é&quot;, min = 1, max = 50, value = 30), &quot;então x multiplicado por y é&quot;, textOutput(&quot;produto&quot;) ) server &lt;- function(input, output, session) { output$produto &lt;- renderText({ input$x * input$y }) } shinyApp(ui, server) ## 4. # A novidade é o cálculo adicional em que 5 e 10 foram adicionados ao produto. # Reduzindo códido com expressão reativa: library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, &quot;Se x é&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, &quot;e y é&quot;, min = 1, max = 50, value = 5), &quot;então, (x * y) é&quot;, textOutput(&quot;produto&quot;), &quot;e, (x * y) + 5 é&quot;, textOutput(&quot;produto_mais5&quot;), &quot;e (x * y) + 10 é&quot;, textOutput(&quot;produto_mais10&quot;) ) server &lt;- function(input, output, session) { # Expressão reativa prod &lt;- reactive({ input$x * input$y }) output$produto &lt;- renderText({ prod() }) output$produto_mais5 &lt;- renderText({ prod() + 5 }) output$produto_mais10 &lt;- renderText({ prod() + 10 }) } shinyApp(ui, server) ## 5. # Erros: # 1º erro: # trocar tableOutput(&quot;plot&quot;) por plotOutput(&quot;plot&quot;) -&gt; renderPlot # 2º erro: # resumo esta escrito errado em output$resummo # 3º erro: # trocar plot(dataset) por plot(dataset()) para usar a expressão reativa Acesso Professor 8.2 UI básica A estrutura do UI (front-end) do shiny possibilita diferentes tipos de funções de entrada e saída que permitem capturar diversos tipos de dados e exibir diversos tipos de saída em R. 8.2.1 Entradas Argumentos das funções de entrada: inputId (primeiro argumento presente em todas as funções): Este é o identificador usado para conectar o front-end com o back-end. Se sua interface de usuário tiver uma entrada com ID “name”, a função do servidor a acessará com input$name. O inputId tem duas restrições: Deve ser uma string simples contendo apenas letras, números e sublinhados. Deve ser nomeada como uma variável em R. Deve ser único. label (segundo argumento presente na maioria das funções): usado para criar um rótulo legível para o controle. value (terceiro argumento): quando pesente, permite definir o valor padrão. Principais funções de entrada do Shiny 1. Texto livre Permite coletar pequenas quantidades de texto com textInput(), senhas com passwordInput() e parágrafos de texto com textAreaInput(). ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), passwordInput(&quot;senha&quot;, &quot;Qual é a sua senha?&quot;), textAreaInput(&quot;historia&quot;, &quot;Fale sobre você&quot;, rows = 3) ) 2. Entradas numéricas Para valores numéricos: caixa de texto restrita com numericInput() ou um controle deslizante com sliderInput(). ui &lt;- fluidPage( numericInput(&quot;num&quot;, &quot;Número um&quot;, value = 0, min = 0, max = 100), sliderInput(&quot;num2&quot;, &quot;Número dois&quot;, value = 50, min = 0, max = 100), sliderInput(&quot;inter&quot;, &quot;Intervalo&quot;, value = c(10, 20), min = 0, max = 100) ) 3. Datas Para coletar um único dia: dateInput(); ou um intervalo de dias: dateRangeInput(). ui &lt;- fluidPage( dateInput(&quot;nascimento&quot;, &quot;Quando você nasceu?&quot;), dateRangeInput(&quot;ferias&quot;, &quot;Quando você quer tirar as próximas férias?&quot;) ) 4. Escolhas limitadas Existem duas abordagens diferentes para permitir que o usuário escolha entre um conjunto pré-especificado de opções: selectInput() e radioButtons(). animais &lt;- c(&quot;cachorro&quot;, &quot;gato&quot;, &quot;rato&quot;, &quot;pássaro&quot;, &quot;outro&quot;, &quot;nenhum&quot;) estados &lt;- c(&quot;PR&quot;, &quot;SC&quot;, &quot;SP&quot;, &quot;RJ&quot;) ui &lt;- fluidPage( selectInput(&quot;estado&quot;, &quot;Qual é o seu estado favorito?&quot;, estados), radioButtons(&quot;animal&quot;, &quot;Qual é o seu animal favorito?&quot;, animais) ) Os botões de opção (radioButtons()) têm dois recursos interessantes: eles mostram todas as opções possíveis, tornando-os adequados para listas curtas. Os menus suspensos (selectInput()) ocupam a mesma quantidade de espaço, independentemente do número de opções, tornando-os mais adequados para opções mais longas. Você também pode configurar multiple = TRUEpara permitir que o usuário selecione vários elementos. ui &lt;- fluidPage( selectInput(&quot;estado&quot;, &quot;Qual é o seu estado favorito?&quot;, estados, multiple = TRUE) ) 5. Botões de ação Para executar ações: actionButton() ou actionLink(). ui &lt;- fluidPage( actionButton(&quot;clique&quot;, &quot;Clique aqui!&quot;), actionButton(&quot;beba&quot;, &quot;Beba-me!&quot;, icon = icon(&quot;cocktail&quot;)) ) Links e botões de ação são mais naturalmente pareados com observeEvent() ou eventReactive() na sua função de servidor. Você pode personalizar a aparência usando o argumento class “btn-primary”, “btn-success”, “btn-info”, “btn-warning”, ou “btn-danger”. Você também pode alterar o tamanho com “btn-lg”, “btn-sm”, “btn-xs”. Por fim, você pode fazer com que os botões ocupem toda a largura do elemento em que estão incorporados usando “btn-block”. ui &lt;- fluidPage( fluidRow( actionButton(&quot;clique&quot;, &quot;Clique aqui!&quot;, class = &quot;btn-danger&quot;), actionButton(&quot;beba&quot;, &quot;Beba-me!&quot;, class = &quot;btn-lg btn-success&quot;) ), fluidRow( actionButton(&quot;resp&quot;, &quot;Respostas!&quot;, class = &quot;btn-block&quot;) ) ) Exercícios - Seção 8.2.1 1. Quando o espaço é limitado, é útil rotular as caixas de texto com um espaço reservado que aparece dentro da área de entrada de texto. Como você chamaria a função textInput() para gerar a IU abaixo? 2. Leia atentamente a documentação de sliderInput() e tente descobrir como criar um controle deslizante de data, conforme mostrado abaixo. 3. No seu aplicativo Shiny, crie um controle deslizante que permita ao usuário escolher um número entre 0 e 100, variando de 5 em 5. Em seguida, adicione uma funcionalidade de animação, de forma que, ao clicar em um botão de “play”, o controle avance automaticamente pelos valores disponíveis, como se estivesse passando por eles em sequência. Dica: existe um argumento do controle deslizante que permite ativar esse tipo de animação automaticamente. 4. Quando uma lista de opções em um menu suspenso (selectInput()) é muito longa, pode ser útil organizá-la em grupos com rótulos — como se fossem seções ou categorias dentro da lista. Explore como criar esse tipo de organização usando selectInput() no Shiny. Crie um exemplo com pelo menos dois grupos e algumas opções dentro de cada grupo (como o exemplo a seguir). Respostas ##1 textInput(inputId = &quot;texto&quot;, label = &quot;&quot;, placeholder = &quot;Seu nome&quot;) ##2 # ?sliderInput -&gt; ?Date -&gt; as.Date sliderInput( &quot;datas&quot;, &quot;Quando devemos entregar?&quot;, min = as.Date(&quot;2025-03-10&quot;), max = as.Date(&quot;2025-03-20&quot;), value = as.Date(&quot;2025-03-12&quot;) ) ##3 sliderInput(&quot;num&quot;, &quot;Selecione um número:&quot;, min = 0, max = 100, value = 0, step = 5, animate = TRUE) ##4 selectInput( &quot;raca&quot;, &quot;Selecione sua raça animal favorita:&quot;, choices = list(&quot;Cães&quot; = list(&#39;Pastor Alemão&#39;, &#39;Bulldog&#39;, &#39;Labrador Retriever&#39;), &quot;Gatos&quot; = list(&#39;Gato Persa&#39;, &#39;Gato de Bengala&#39;, &#39;Gato Siamês&#39;)) ) Acesso Professor 8.2.2 Saídas As saídas na UI criam espaços reservados que são posteriormente preenchidos pela função do servidor. Assim como as entradas, as saídas recebem um ID exclusivo como primeiro argumento. Se a sua especificação de UI criar uma saída com ID “plot”, você a acessará na função do servidor com output$plot. Cada função de output no front-end (UI) é acoplada a uma função de renderização no back-end (server). 1. Texto Produza texto com textOutput() e código fixo com verbatimTextOutput(). library(shiny) ui &lt;- fluidPage( textOutput(&quot;texto&quot;), verbatimTextOutput(&quot;codigo&quot;) ) server &lt;- function(input, output, session) { output$texto &lt;- renderText({ &quot;Olá, bem vindo! A seguir um resumo de dados:&quot; }) output$codigo &lt;- renderPrint({ summary(1:10) }) } shinyApp(ui, server) Observe que há duas funções de renderização que se comportam de maneira ligeiramente diferente: renderText() combina o resultado em uma única string e geralmente é emparelhado com textOutput(). renderPrint() imprime o resultado, como se você estivesse em um console R, e geralmente é pareado com verbatimTextOutput(). ui &lt;- fluidPage( textOutput(&quot;texto&quot;), verbatimTextOutput(&quot;imprime&quot;) ) server &lt;- function(input, output, session) { output$texto &lt;- renderText(&quot;Texto com renderText.&quot;) output$imprime &lt;- renderPrint(cat(&quot;Texto com renderPrint.&quot;)) } 2. Tabelas Há duas opções para exibir quadros de dados em tabelas: tableOutput() e renderTable() renderizam uma tabela estática de dados, mostrando todos os dados de uma só vez. Útil para resumos pequenos e fixos. dataTableOutput() e renderDataTable() renderizam uma tabela dinâmica. É mais apropriado se você deseja expor um quadro de dados completo ao usuário. ui &lt;- fluidPage( tableOutput(&quot;estatica&quot;), dataTableOutput(&quot;dinamica&quot;) ) server &lt;- function(input, output, session) { output$estatica &lt;- renderTable(head(mtcars)) output$dinamica &lt;- renderDataTable(mtcars, options = list(pageLength = 5)) } Versões mais recentes sugerem usar DTOutput e renderDT do pacote DT para tabelas dinâmicas. library(shiny) library(DT) ui &lt;- fluidPage( tableOutput(&quot;estatica&quot;), DTOutput(&quot;dinamica&quot;) ) server &lt;- function(input, output, session) { output$estatica &lt;- renderTable(head(mtcars)) output$dinamica &lt;- renderDT(mtcars, options = list(pageLength = 5)) } shinyApp(ui, server) 3. Gráficos Você pode exibir qualquer tipo de gráfico R (basico, ggplot2, etc) com plotOutput() e renderPlot(). ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } Por padrão, plotOutput() ocupará toda a largura do contêiner e terá 400 pixels de altura. Você pode substituir esses padrões com os argumentos height e width. Recomenda-se sempre definir res = 96, pois isso fará com que seus gráficos correspondam o máximo possível ao que você vê no RStudio. Os gráficos são especiais porque são saídas que também podem atuar como entradas. plotOutput() possui vários argumentos como click, dblclick e hover. Se passar uma string para eles, como click = \"plot_click\", eles criarão uma entrada reativa (input$plot_click) que você pode usar para manipular a interação do usuário no gráfico, por exemplo, clicando no gráfico. Exercícios - Seção 8.2.2 1. As funções textOutput() e verbatimTextOutput() devem ser pareadas com qual(is) função(ões) de renderização abaixo: renderPrint(summary(mtcars)) renderText(\"Bom dia!\") renderPrint(t.test(1:5, 2:6)) 2. Recrie o aplicativo a seguir, definindo a altura como 300px e a largura como 700px. library(shiny) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } shinyApp(ui, server) 3. Atualize o código abaixo para que a tabela exiba apenas os dados e o controle de paginação, removendo os controles de busca e ordenação por colunas. Para isso, use os argumentos adequados para options da função renderDataTable(). Consulte a ajuda da função renderDataTable (?renderDataTable) e a documentação oficial do DataTables para entender como desativar esses controles: https://datatables.net/reference/option/ ui &lt;- fluidPage( dataTableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { output$tabela &lt;- renderDataTable(mtcars, options = list(pageLength = 5)) } Respostas ## 1. # a. renderPrint(summary(mtcars)) -&gt; verbatimTextOutput (console) # b. renderText(&quot;Good morning!&quot;) -&gt; textOutput # c. renderPrint(t.test(1:5, 2:6)) -&gt; verbatimTextOutput (console) ## 2. library(shiny) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;700px&quot;, height = &quot;300px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } shinyApp(ui, server) ## 3. library(shiny) ui &lt;- fluidPage( dataTableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { output$tabela &lt;- renderDataTable(mtcars, options = list(ordering = FALSE, searching = FALSE)) } shinyApp(ui, server) Acesso Professor 8.3 Reatividade básica 8.3.1 A função do servidor As funções de servidor recebem três parâmetros: input, output e session. Como você nunca chama a função de servidor, nunca criará esses objetos. Em vez disso, eles são criados pelo Shiny quando a sessão inicia, conectando-se a uma sessão específica. Vamos ver algumas formas de evitar erros envolvendo inputs e outputs. Entradas (input) O input é um objeto em forma de lista que contém todos os dados de entrada enviados pelo navegador, nomeados de acordo com o ID de entrada. Por exemplo, se sua interface contiver um controle de entrada numérico com um ID contagem, então você pode acessar o valor dessa entrada com input$contagem. ui &lt;- fluidPage( numericInput(&quot;contagem&quot;, label = &quot;Number of values&quot;, value = 100) ) Inicialmente, ele conterá o valor 100 e será atualizado automaticamente conforme o usuário altera o valor no navegador. Ao contrário de uma lista típica, objetos de input são somente leitura. Se você tentar modificar uma entrada dentro da função do servidor, receberá um erro: server &lt;- function(input, output, session) { input$contagem &lt;- 10 } shinyApp(ui, server) #&gt; Error: Can&#39;t modify read-only reactive value &#39;contagem&#39; Este erro ocorre porque o input reflete o que está acontecendo no navegador, e o navegador é a “única fonte de verdade” do Shiny. Além disso, para ler um input no servidor é necessário estar em um contexto reativo criado por uma função como renderText() ou reactive(). Isso permite que as saídas sejam atualizadas automaticamente quando uma entrada muda. Este código ilustra o erro que você verá se cometer este erro: server &lt;- function(input, output, session) { message(&quot;O valor de input$contagem é&quot;, input$contagem) } shinyApp(ui, server) #&gt; Error: Can&#39;t access reactive value &#39;contagem&#39; outside of reactive consumer. #&gt; ℹ Do you need to wrap inside reactive() or observer()? Saídas (output) A saída (output) também é um objeto do tipo lista, nomeado de acordo com o ID de saída. A principal diferença é que você o usa para enviar saída em vez de receber entrada. Você sempre usa o objeto output em conjunto com uma função render. ui &lt;- fluidPage( textOutput(&quot;saudacao&quot;) ) server &lt;- function(input, output, session) { output$saudacao &lt;- renderText(&quot;Olá humano!&quot;) } Assim como o input, o output é exigente quanto à forma como você o utiliza. Você receberá um erro se: Esquecer a função render. server &lt;- function(input, output, session) { output$saudacao &lt;- &quot;Olá humano!&quot; } shinyApp(ui, server) #&gt; Error: Unexpected character object for output$saudacao #&gt; ℹ Did you forget to use a render function? Tentar ler uma saída. server &lt;- function(input, output, session) { message(&quot;A saudação é &quot;, output$saudacao) } shinyApp(ui, server) #&gt; Error: Reading from shinyoutput object is not allowed. 8.3.2 Programação reativa Um aplicativo será bem chato se tiver apenas entradas ou apenas saídas. A verdadeira magia do Shiny acontece quando você tem um aplicativo com ambos. library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), textOutput(&quot;saudacao&quot;) ) server &lt;- function(input, output, session) { output$saudacao &lt;- renderText({ paste0(&quot;Olá &quot;, input$nome, &quot;!&quot;) }) } shinyApp(ui, server) Se você executar o aplicativo verá que a saudação é atualizada automaticamente conforme você digita. Esta é a grande ideia do Shiny: você não precisa informar a saída quando atualizar, porque o Shiny descobre isso automaticamente para você. Um dos pontos fortes da programação em Shiny é que ela permite que os aplicativos sejam extremamente preguiçosos. Um aplicativo Shiny só fará o mínimo de trabalho necessário para atualizar os controles de saída. Essa preguiça, no entanto, tem uma desvantagem importante. O que há de errado com o código abaixo? library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), textOutput(&quot;saudacao&quot;) ) server &lt;- function(input, output, session) { output$saudacaoo &lt;- renderText({ paste0(&quot;Olá &quot;, input$nome, &quot;!&quot;) }) } shinyApp(ui, server) Se você observar atentamente, poderá notar que está escrito saudacaoo em vez de saudacao. Isso não gerará um erro no Shiny, mas não fará o que você deseja. A saída saudacaoo não existe, então o código em renderText() nunca será executado. Importante: Verificar se sua interface de usuário e funções de servidor estão usando os mesmos nomes de identificadores. O Gráfico Reativo O gráfico reativo é uma representação gráfica que descreve como as entradas e saídas estão conectadas. Ele define a ordem de execução do aplicativo. Para o exemplo: library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), textOutput(&quot;saudacao&quot;) ) server &lt;- function(input, output, session) { output$saudacao &lt;- renderText({ paste0(&quot;Olá &quot;, input$nome, &quot;!&quot;) }) } shinyApp(ui, server) O gráfico reativo fica: O gráfico reativo contém um símbolo para cada entrada e saída, e conectamos uma entrada a uma saída sempre que a saída acessa a entrada. Este gráfico informa que saudacao precisará ser recomputado sempre que nome for alterado. Frequentemente descreveremos essa relação como saudacao tendo uma dependência reativa em nome. O gráfico reativo é uma ferramenta poderosa para entender como seu aplicativo funciona. À medida que seu aplicativo se torna mais complexo, muitas vezes é útil fazer um esboço rápido e detalhado do gráfico reativo para lembrar como todas as peças se encaixam. No caso do código envolver expressões reativas, esta informação também deve ser adicionada ao gráfico reativo. Exemplo: library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), textOutput(&quot;saudacao&quot;) ) server &lt;- function(input, output, session) { frase &lt;- reactive(paste0(&quot;Olá &quot;, input$nome, &quot;!&quot;)) output$saudacao &lt;- renderText(frase()) } shinyApp(ui, server) Neste caso, o gráfico reativo fica: Uma expressão reativa é desenhada com ângulos em ambos os lados porque conecta entradas a saídas. Exercícios - Seção 8.3.2 1. Dada esta UI: ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;), textOutput(&quot;saudacao&quot;) ) Corrija os erros encontrados em cada uma das três funções de servidor abaixo. Primeiro, tente identificar o problema apenas lendo o código; depois, execute o código para garantir que o corrigiu. server1 &lt;- function(input, output, server) { input$saudacao &lt;- renderText(paste0(&quot;Olá &quot;, nome)) } server2 &lt;- function(input, output, server) { saudacao &lt;- paste0(&quot;Olá &quot;, input$nome) output$saudacao &lt;- renderText(saudacao) } server3 &lt;- function(input, output, server) { output$saudacaoo &lt;- paste0(&quot;Olá&quot;, input$nome) } 2. Desenhe o gráfico reativo para cada função de servidor a seguir: server1 &lt;- function(input, output, session) { c &lt;- reactive(input$a + input$b) e &lt;- reactive(c() + input$d) output$f &lt;- renderText(e()) } server2 &lt;- function(input, output, session) { x &lt;- reactive(input$x1 + input$x2 + input$x3) y &lt;- reactive(input$y1 + input$y2) output$z &lt;- renderText(x() / y()) } server3 &lt;- function(input, output, session) { d &lt;- reactive(c() ^ input$d) a &lt;- reactive(input$a * 10) c &lt;- reactive(b() / input$c) b &lt;- reactive(a() + input$b) } 3. Por que esse código falhará? library(shiny) df &lt;- mtcars ui &lt;- fluidPage( selectInput(&quot;var&quot;, NULL, choices = colnames(df)), verbatimTextOutput(&quot;debug&quot;) ) server &lt;- function(input, output, session) { var &lt;- reactive(df[[input$var]]) range &lt;- reactive(range(var(), na.rm = TRUE)) output$debug &lt;- renderPrint({ range() }) } shinyApp(ui = ui, server = server) Por que range() e var() são nomes ruins para reativos? Apresente o código corrigido. Respostas 1. # Servidor 1: - input$saudacao –&gt; output$saudacao - Dentro renderText, nome –&gt; input$nome Código corrigido: server1 &lt;- function(input, output, server) { output$saudacao &lt;- renderText(paste0(&quot;Olá &quot;, input$nome)) } # Servidor 2: - Faça saudacao um reativo: saudacao &lt;- reactive(paste0(&quot;Olá &quot;, input$nome)) - Como saudacao agora é reativo, adicione parênteses ao redor dele: output$saudacao &lt;- renderText(saudacao()) Código corrigido: server2 &lt;- function(input, output, server) { saudacao &lt;- reactive(paste0(&quot;Olá &quot;, input$nome)) output$saudacao &lt;- renderText(saudacao()) } # Servidor 3: - Erro de ortografia: output$saudacaoo –&gt; output$saudacao - renderText() ausente. Código corrigido: server3 &lt;- function(input, output, server) { output$saudacao &lt;- renderText(paste0(&quot;Olá &quot;, input$nome)) } 2. Para criar o grafico reativo, precisamos considerar as entradas, expressões reativas e saídas. Server1: entradas: input$a, input$b e input$d reativos: c() e e() saídas: output$f Server2: entradas: input$x1, input$x2, input$x3, input$y1, input$y2 reativos: y() e x() saídas: output$z Server3 entradas: input$a, input$b, input$c, input$d reativos: a(), b(), c(), d() 3. Este código não funciona porque chamamos nosso reativo de range, então, quando chamamos a função range, estamos, na verdade, chamando nosso novo reativo. Se mudarmos o nome do reativo de range para col_range, o código funcionará. Da mesma forma, var() não é um bom nome para um reativo porque já é uma função para calcular a variância de x! Código corrigido: library(shiny) df &lt;- mtcars ui &lt;- fluidPage( selectInput(&quot;var&quot;, NULL, choices = colnames(df)), verbatimTextOutput(&quot;debug&quot;) ) server &lt;- function(input, output, session) { col_var &lt;- reactive(df[[input$var]]) col_range &lt;- reactive({ range(col_var(), na.rm = TRUE ) }) output$debug &lt;- renderPrint({ col_range() }) } shinyApp(ui = ui, server = server) Acesso Professor 8.3.3 observeEvent() e eventReactive() No Shiny, observeEvent() e eventReactive() são funções essenciais para controlar a reatividade com base em eventos específicos (como cliques em botões, mudanças em inputs, etc.). Elas têm finalidades diferentes, embora ambas respondam a eventos. observeEvent(): Executa código sem retorno de valor reativo e é útil para efeitos colaterais (ex: atualizar valores, mostrar mensagens, salvar arquivos). Sintaxe: observeEvent(evento, { # código que será executado quando &#39;evento&#39; mudar }) Exemplo: library(shiny) ui &lt;- fluidPage( actionButton(&quot;meu_botao&quot;, &quot;Clique aqui&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$meu_botao, { print(&quot;O botão foi clicado!&quot;) }) } shinyApp(ui, server) eventReactive(): Cria um objeto reativo que só é atualizado quando um evento ocorre. Ideal para realizar cálculos pesados ou demorados apenas quando necessário (como ao clicar num botão). Sintaxe: reactivo &lt;- eventReactive(evento, { # código que gera e retorna o valor }) Exemplo: library(shiny) ui &lt;- fluidPage( numericInput(&quot;n&quot;, &quot;Número:&quot;, value = 5), actionButton(&quot;calc&quot;, &quot;Calcular quadrado&quot;), verbatimTextOutput(&quot;resultado&quot;) ) server &lt;- function(input, output, session) { quadrado &lt;- eventReactive(input$calc, { input$n^2 }) output$resultado &lt;- renderText({ paste(&quot;Resultado:&quot;, quadrado()) }) } shinyApp(ui, server) Exercícios - Seções 8.1 a 8.3 1. Encontre e corrija o(s) erro(s) dos códigos a seguir: a. library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Seu nome:&quot;), textOutput(&quot;mensagem&quot;) ) server &lt;- function(input, output, session) { output$frase &lt;- renderText({ paste(&quot;Olá&quot;, input$nome) }) } shinyApp(ui, server) b. library(shiny) ui &lt;- fluidPage( numericInput(&quot;x&quot;, &quot;Número:&quot;, value = 1), textOutput(&quot;mensagem&quot;) ) server &lt;- function(input, output, session) { output$mensagem &lt;- renderPlot({ paste(&quot;O valor é&quot;, input$x) }) } shinyApp(ui, server) c. library(shiny) ui &lt;- fluidPage( numericInput(&quot;x&quot;, &quot;Número:&quot;, value = 5) ) server &lt;- function(input, output, session) { output$resultado &lt;- renderText({ paste(&quot;Dobro:&quot;, 2 * input$x) }) } shinyApp(ui, server) d. library(shiny) ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Número A&quot;, value = 0), numericInput(&quot;b&quot;, &quot;Número B&quot;, value = 0), textOutput(&quot;soma&quot;) ) server &lt;- function(input, output, session) { soma &lt;- reactive({ input$a + input$b }) output$soma &lt;- renderText({ paste(&quot;A soma é:&quot;, soma) }) } shinyApp(ui, server) e. library(shiny) ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Número A&quot;, value = 0), numericInput(&quot;b&quot;, &quot;Número B&quot;, value = 0), textOutput(&quot;soma&quot;) ) server &lt;- function(input, output, session) { soma &lt;- reactive({ input$a + input$b }) renderText({ paste(&quot;A soma é:&quot;, soma()) }) } shinyApp(ui, server) 2. Crie um app com: textInput() para um nome, selectInput() para escolher uma comida favorita, Um textOutput() que exibe algo como: “Olá [nome], sua comida favorita é [comida].” 3. Crie um app com: Dois numericInput() (números a e b), Um botão (actionButton(“calcular”)), Um textOutput() com a soma de a + b, somente após clicar. Dica: Use eventReactive(). 4. Crie um app com: Um sliderInput() para escolher o número de bins (ex: de 5 a 50), Um plotOutput() com um histograma da distribuição rnorm(100), O gráfico deve atualizar automaticamente conforme o slider muda. Dica: Use renderPlot(). 5. Crie um app com: Um botão (actionButton()) para gerar, quando clicado, 100 números aleatórios (rnorm(100)), Um plotOutput() com o histograma desses números, O gráfico só deve mudar quando o botão for clicado. Dica: Use eventReactive(). Respostas ## 1. # a. output$frase &lt;- renderText({ # ID do output diferente na UI paste(&quot;Olá&quot;, input$nome) }) # b. # renderPlot() está sendo usado para gerar texto (erro de função) # c. # faltando textOutput() no UI! # d. # paste(&quot;A soma é:&quot;, soma) # BUG AQUI: está faltando () # e. # BUG: renderText() está sendo chamado sem ser atrtribuído a output$soma ## 2. library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Seu nome:&quot;), selectInput(&quot;comida&quot;, &quot;Escolha sua comida favorita:&quot;, choices = c(&quot;Pizza&quot;, &quot;Sushi&quot;, &quot;Lasanha&quot;, &quot;Hambúrguer&quot;)), textOutput(&quot;mensagem&quot;) ) server &lt;- function(input, output, session) { output$mensagem &lt;- renderText({ paste(&quot;Olá &quot;, input$nome, &quot;, sua comida favorita é&quot;, input$comida) }) } shinyApp(ui, server) ## 3. library(shiny) ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Número A:&quot;, value = 0), numericInput(&quot;b&quot;, &quot;Número B:&quot;, value = 0), actionButton(&quot;calcular&quot;, &quot;Calcular soma&quot;), textOutput(&quot;resultado&quot;) ) server &lt;- function(input, output, session) { soma &lt;- eventReactive(input$calcular, { input$a + input$b }) output$resultado &lt;- renderText({ paste(&quot;Resultado da soma:&quot;, soma()) }) } shinyApp(ui, server) ## 4. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;bins&quot;, &quot;Número de bins:&quot;, min = 5, max = 50, value = 10), plotOutput(&quot;histograma&quot;) ) server &lt;- function(input, output, session) { output$histograma &lt;- renderPlot({ x &lt;- rnorm(100) hist(x, breaks = input$bins, col = &quot;steelblue&quot;, border = &quot;white&quot;) }) } shinyApp(ui, server) ## 5. library(shiny) ui &lt;- fluidPage( actionButton(&quot;gerar&quot;, &quot;Gerar histograma&quot;), plotOutput(&quot;histograma&quot;) ) server &lt;- function(input, output, session) { dados &lt;- eventReactive(input$gerar, { rnorm(100) }) output$histograma &lt;- renderPlot({ hist(dados(), col = &quot;darkgreen&quot;) }) } shinyApp(ui, server) Acesso Professor 8.4 Layout, temas, HTML O Shiny fornece diversas funções para organizar a aparência dos aplicativos. 8.4.1 Layouts Funções de página O fluidPage() configura todo o HTML, CSS e JavaScript que o Shiny precisa. Além de fluidPage(), o Shiny oferece outras funções de página que podem ser úteis em situações mais especializadas: fixedPage() e fillPage(). fixedPage() funciona como fluidPage(), mas tem uma largura máxima fixa, o que impede que seus aplicativos fiquem excessivamente largos em telas maiores. fillPage() Preenche toda a altura do navegador e é útil se você quiser criar um gráfico que ocupe a tela inteira. 1. Layouts de página única Página com barra lateral Para criar layouts mais complexos, você precisará chamar funções de layout dentro de fluidPage() Para criar um layout de duas colunas com entradas à esquerda e saídas à direita, você pode usar sidebarLayout() junto com titlePanel(), sidebarPanel() e mainPanel(). ui &lt;- fluidPage( titlePanel( # Titulo do app ), sidebarLayout( sidebarPanel( # inputs ), mainPanel( # outputs ) ) ) Exemplo: Teorema do Limite Central ui &lt;- fluidPage( titlePanel(&quot;Teorema do Limite Central&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;m&quot;, &quot;Número de amostras:&quot;, 2, min = 1, max = 100) ), mainPanel( plotOutput(&quot;hist&quot;) ) ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }, res = 96) } Multi-linhas Podemos adicionar linhas ou colunas ao aplicativo com fluidRow() e column(). ui &lt;- fluidPage( fluidRow( column(4, ... ), column(8, ... ) ), fluidRow( column(6, ... ), column(6, ... ) ) ) Cada linha é composta por 12 colunas e o primeiro argumento de column() indica quantas dessas colunas ocupar. Exercícios 1. Leia a documentação de sidebarLayout() e identifique os valores padrão da largura (em colunas) da barra lateral (sidebarPanel) e do painel principal (mainPanel). Recrie a aparência do aplicativo Teorema do Limite Central usando fluidRow() e column()? 2. Modifique o aplicativo Teorema do Limite Central (usando sidebarLayout()) para colocar a barra lateral à direita em vez de à esquerda. 3. Para conjunto de dados mtcars e usando as funções fluidRow() e column(), construa um app Shiny que mostre: Titulo do Aplicativo Na primeira linha: Dois botões de seleção (selectInput) para escolher duas variáveis numéricas (em colunas lado a lado). Na segunda linha: Dois gráficos correspondentes - um histograma da primeira variável e um boxplot da segunda variável, exibidos lado a lado. Respostas 1. Por padrão, a barra lateral ocupa 1/3 da largura (width = 4), e o painel principal, 2/3 (width = 8). # É possivel recriar, embora o layout fique um pouco diferente # Recriando sidebarLayout() fluidRow( # sidebar (4 columns) column(4, ... ), # # main panel (8 columns) column(8, ... ) ) # Para o exemplo anterior: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Teorema do Limite Central&quot;), # sidebar (4 columns) fluidRow( column(4, numericInput(&quot;m&quot;, &quot;Número de amostras:&quot;, 2, min = 1, max = 100) ), # main panel (8 columns) column(8, plotOutput(&quot;hist&quot;) ) ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }, res = 96) } shinyApp(ui = ui, server = server) 2. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Teorema do Limite Central&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;m&quot;, &quot;Número de amostras:&quot;, 2, min = 1, max = 100) ), mainPanel( plotOutput(&quot;hist&quot;) ), # Modificado para colocar a posição da barra lateral à direita position = &quot;right&quot; ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }, res = 96) } shinyApp(ui, server) 3. library(shiny) &lt;!-- # Selecionando numericas (se necessário) --&gt; &lt;!-- library(dplyr) --&gt; &lt;!-- numeric_vars &lt;- mtcars %&gt;% --&gt; &lt;!-- select(where(is.numeric)) %&gt;% --&gt; &lt;!-- names() --&gt; ui &lt;- fluidPage( titlePanel(&quot;Histograma e Boxplot&quot;), # Linha de seleção das variáveis fluidRow( column(6, selectInput(&quot;var1&quot;, &quot;Variável para histograma:&quot;, choices = names(mtcars), selected = &quot;mpg&quot;) ), column(6, selectInput(&quot;var2&quot;, &quot;Variável para boxplot:&quot;, choices = names(mtcars), selected = &quot;hp&quot;) ) ), # Linha com os dois gráficos lado a lado fluidRow( column(6, plotOutput(&quot;histPlot&quot;) ), column(6, plotOutput(&quot;boxPlot&quot;) ) ) ) server &lt;- function(input, output, session) { output$histPlot &lt;- renderPlot({ var &lt;- mtcars[[input$var1]] hist(var, main = paste(&quot;Histograma de&quot;, input$var1), xlab = input$var1, col = &quot;skyblue&quot;) }) output$boxPlot &lt;- renderPlot({ var &lt;- mtcars[[input$var2]] boxplot(var, main = paste(&quot;Boxplot de&quot;, input$var2), ylab = input$var2, col = &quot;orange&quot;) }) } shinyApp(ui, server) Acesso Professor 2. Layouts de várias páginas Conjuntos de guias A maneira mais simples de dividir uma página em partes é usar tabsetPanel() junto com tabPanel(). tabsetPanel() cria um contêiner para qualquer número de tabPanels(), que por sua vez pode conter quaisquer outros componentes. Exemplo: ui &lt;- fluidPage( tabsetPanel( tabPanel(title = &quot;Importar dados&quot;, fileInput(&quot;file&quot;, &quot;Dados&quot;, buttonLabel = &quot;Upload...&quot;), textInput(&quot;delim&quot;, &quot;Delimitador&quot;, &quot;&quot;), numericInput(&quot;skip&quot;, &quot;Linhas para pular&quot;, 0, min = 0), numericInput(&quot;rows&quot;, &quot;Linhas para visualizar&quot;, 10, min = 1) ), tabPanel(&quot;Conjunto de parâmetros&quot;), tabPanel(&quot;Resultados&quot;) ) ) Se quiser saber qual aba um usuário selecionou, você pode fornecer o argumento id para tabsetPanel() e ele se tornará uma entrada. Argumento ID: se fornecido, você pode usar input$id na lógica do seu servidor para determinar qual das abas atuais está ativa. O valor de input$id corresponderá ao argumento value passado para tabPanel(). library(shiny) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( textOutput(&quot;painel&quot;) ), mainPanel( tabsetPanel( id = &quot;painel_ativo&quot;, tabPanel(title = &quot;Aba 1&quot;, value = &quot;aba1&quot;, &quot;Conteúdo da Aba 1&quot;), tabPanel(title = &quot;Aba 2&quot;, value = &quot;aba2&quot;, &quot;Conteúdo da Aba 2&quot;) ) ) ) ) server &lt;- function(input, output, session) { output$painel &lt;- renderText({ paste(&quot;A aba atual é:&quot;, input$painel_ativo) }) } shinyApp(ui, server) Se value for omitido e tabsetPanel tiver um ID, o título será usado. Listas e barras de navegação A estrutura de abas com tabsetPanel (que tem exibição horizontal), dificulta representar titulos longos. Deste modo, navlistPanel(), navbarPage() e navbarMenu() possibilitam layouts alternativos que permitem que você use abas com títulos mais longos. navlistPanel() é semelhante a tabsetPanel(), mas em vez de exibir os títulos das guias horizontalmente, ele os exibe verticalmente em uma barra lateral. ui &lt;- fluidPage( navlistPanel( id = &quot;tabset&quot;, &quot;Título 1&quot;, tabPanel(&quot;Painel 1&quot;, &quot;Conteúdos do painel 1...&quot;), &quot;Título 2&quot;, tabPanel(&quot;Painel 2&quot;, &quot;Conteúdos do painel 2...&quot;), tabPanel(&quot;Painel 3&quot;, &quot;Conteúdos do painel 3...&quot;) ) ) navbarPage(): exibe os títulos das abas horizontalmente, mas você pode usar navbarMenu() para adicionar menus suspensos com um nível adicional de hierarquia. ui &lt;- navbarPage( &quot;Titulo&quot;, tabPanel(&quot;Painel 1&quot;, &quot;Conteúdos do painel 1...&quot;), tabPanel(&quot;Painel 2&quot;, &quot;Conteúdos do painel 2...&quot;), navbarMenu(&quot;Sub-Painéis&quot;, tabPanel(&quot;Painel 4a&quot;, &quot;Conteúdos do painel 4-a...&quot;), tabPanel(&quot;Painel 4b&quot;, &quot;Conteúdos do painel 4-b...&quot;) ) ) Exercícios 1. Crie um app usando tabsetPanel() com 2 abas para os dados mtcars: Aba 1: Gráfico boxplot para a variável mpg Aba 2: Gráfico de barras para a variável cyl. 2. Crie um app com uma barra de navegação lateral (navlistPanel()) com 2 abas, para os dados mtcars: Aba 1: contendo um controle (por exemplo, selectInput()) para escolher uma variável e um gráfico para esta variável. Aba 2: contendo a tabela de dados mtcars. 3. Considerando o conjunto de dados iris, crie um app com menu de navegação usando navbarPage() e navbarMenu(), contendo 2 abas: Aba 1: um resumo (summary) dos dados (use verbatimTextOutput()). Aba 2: contendo 2 sub-abas com: (1) um gráfico de dispersão entre Sepal.Length e Petal.Length e (2) um histograma para Sepal.Width. Respostas ## 1. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Visualização dos dados mtcars&quot;), tabsetPanel( tabPanel(&quot;Boxplot de mpg&quot;, plotOutput(&quot;boxplot_mpg&quot;) ), tabPanel(&quot;Barras de cyl&quot;, plotOutput(&quot;barras_cyl&quot;) ) ) ) server &lt;- function(input, output, session) { output$boxplot_mpg &lt;- renderPlot({ boxplot(mtcars$mpg, main = &quot;Boxplot de mpg&quot;, ylab = &quot;Milhas por galão (mpg)&quot;, col = &quot;skyblue&quot;) }) output$barras_cyl &lt;- renderPlot({ barplot(table(mtcars$cyl), main = &quot;Frequência de cilindros (cyl)&quot;, xlab = &quot;Número de cilindros&quot;, ylab = &quot;Frequência&quot;, col = &quot;orange&quot;) }) } shinyApp(ui, server) ## 2. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Análise dos dados mtcars&quot;), navlistPanel( &quot;Menu&quot;, tabPanel(&quot;Gráfico de variável&quot;, selectInput(inputId = &quot;variavel&quot;, label = &quot;Escolha uma variável numérica:&quot;, choices = names(mtcars), selected = &quot;mpg&quot; ), plotOutput(&quot;grafico&quot;) ), tabPanel(&quot;Tabela de dados&quot;, tableOutput(&quot;tabela&quot;) ) ) ) server &lt;- function(input, output, session) { output$grafico &lt;- renderPlot({ hist(mtcars[[input$variavel]], main = paste(&quot;Histograma de&quot;, input$variavel), xlab = input$variavel, col = &quot;steelblue&quot;) }) output$tabela &lt;- renderTable({ mtcars }) } shinyApp(ui, server) ## 3. library(shiny) ui &lt;- navbarPage(&quot;Análise do dataset iris&quot;, tabPanel(&quot;Resumo dos dados&quot;, verbatimTextOutput(&quot;resumo&quot;) ), navbarMenu(&quot;Gráficos&quot;, tabPanel(&quot;Dispersão: Sepal vs Petal&quot;, plotOutput(&quot;dispersao&quot;) ), tabPanel(&quot;Histograma: Sepal.Width&quot;, plotOutput(&quot;histograma&quot;) ) ) ) server &lt;- function(input, output, session) { output$resumo &lt;- renderPrint({ summary(iris) }) output$dispersao &lt;- renderPlot({ plot(iris$Sepal.Length, iris$Petal.Length, main = &quot;Dispersão: Sepal.Length vs Petal.Length&quot;, xlab = &quot;Sepal.Length&quot;, ylab = &quot;Petal.Length&quot;, pch = 19, col = iris$Species) }) output$histograma &lt;- renderPlot({ hist(iris$Sepal.Width, main = &quot;Histograma de Sepal.Width&quot;, xlab = &quot;Sepal.Width&quot;, col = &quot;lightgreen&quot;, border = &quot;white&quot;) }) } shinyApp(ui, server) Acesso Professor 8.4.2 Temas Principais abordagens para aplicar temas em Shiny. Temas básicos com shinythemes library(shiny) library(shinythemes) ui &lt;- fluidPage( theme = shinytheme(&quot;cerulean&quot;), # Exemplo de tema titlePanel(&quot;App com tema &#39;cerulean&#39;&quot;), sidebarLayout( sidebarPanel( sliderInput(&quot;num&quot;, &quot;Escolha um número&quot;, 1, 100, 50) ), mainPanel( textOutput(&quot;res&quot;) ) ) ) server &lt;- function(input, output) { output$res &lt;- renderText({ paste(&quot;Você escolheu&quot;, input$num) }) } shinyApp(ui = ui, server = server) Outros temas disponíveis: cosmo, cyborg, darkly, flatly, journal, lumen, paper, readable Customização avançada com bslib (Bootstrap themes) library(shiny) library(bslib) ui &lt;- fluidPage( theme = bslib::bs_theme( bg = &quot;#0b3d91&quot;, fg = &quot;white&quot;, base_font = &quot;Source Sans Pro&quot; ), titlePanel(&quot;App com bslib e tema &#39;minty&#39;&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;n&quot;, &quot;Número&quot;, 1) ), mainPanel( verbatimTextOutput(&quot;result&quot;) ) ) ) server &lt;- function(input, output) { output$result &lt;- renderPrint({ input$n^2 }) } shinyApp(ui, server) bg: Cores para o fundo. fg: Cores para o primeiro plano. base_font: A fonte padrão. Para visualizar o exemplo de um tema específico: theme &lt;- bslib::bs_theme( bg = &quot;#0b3d91&quot;, fg = &quot;white&quot;, base_font = &quot;Source Sans Pro&quot; ) bslib::bs_theme_preview(theme) Para personalizar os gráficos de acordo com o tema do app, usar thematic_shiny() do pacote thematic. library(shiny) library(thematic) thematic_shiny() # aplica automaticamente o tema ui &lt;- fluidPage( theme = bslib::bs_theme( bg = &quot;#0b3d91&quot;, fg = &quot;white&quot;, base_font = &quot;Source Sans Pro&quot; ), titlePanel(&quot;App com thematic&quot;), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output) { output$plot &lt;- renderPlot({ plot(rnorm(100)) }) } shinyApp(ui, server) Observações: Para criar as cores você pode consultar colors(), ou consultar os códigos em https://r-charts.com/colors/. Para fontes, você pode usar o suporte do Google Fonts via a função font_google() do próprio bslib, com diferentes opções em https://fonts.google.com/. 8.4.3 HTML O Shiny foi projetado para que, como usuário de R, você não precise aprender os detalhes de HTML. No entanto, se você tiver algum conhecimento de HTML e CSS, é possível personalizá-lo ainda mais. Todas as funções de entrada, saída e layout do shiny: apenas geram HTML. Você pode ver esse HTML executando funções de interface do usuário diretamente no console: # Código no console fluidPage( textInput(&quot;nome&quot;, &quot;Qual é o seu nome?&quot;) ) # Saída &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label class=&quot;control-label&quot; id=&quot;nome-label&quot; for=&quot;nome&quot;&gt;Qual é o seu nome?&lt;/label&gt; &lt;input id=&quot;nome&quot; type=&quot;text&quot; class=&quot;shiny-input-text form-control&quot; value=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; É possível adicionar seu próprio HTML ao ui. Uma maneira de fazer isso é incluir HTML literal com a função HTML(), juntamente com a “constante de caractere bruto”, r\"()\", para facilitar a inclusão de aspas na string: ui &lt;- fluidPage( HTML(r&quot;( &lt;h1&gt;Este é um título&lt;/h1&gt; &lt;p&gt;Este é um texto!&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Primeiro item&lt;/li&gt; &lt;li&gt;Segundo item&lt;/li&gt; &lt;/ul&gt; )&quot;) ) Outra opção é usar o auxiliar HTML fornecido pelo Shiny. Existem funções regulares para os elementos mais importantes, como h1() e p(), e outros podem ser acessados por meio de tags auxiliares. Recriando o HTML acima: ui &lt;- fluidPage( h1(&quot;Este é um título&quot;), p(&quot;Este é um texto!&quot;, class = &quot;minha-classe&quot;), tags$ul( tags$li(&quot;Primeiro item&quot;), tags$li(&quot;Segundo item&quot;) ) ) O livro Outstanding User Interfaces with Shiny, de David Granjon, pode ser consultado para mais detalhes sobre como usar HTML, CSS e JavaScript para criar interfaces de usuário mais atraentes. Exercícios 1. Crie um aplicativo Shiny simples com um tema usando bslib com as seguintes características: Cor de fundo (bg) para um tom de azul claro: #e6f2ff. Cor do texto (fg) para um cinza escuro: #2c3e50. Fonte base como “Lato” (Google Fonts). Dica: Você pode usar a função font_google(\"Lato\") para aplicar a fonte. 2. Use bslib::bs_theme_preview() para criar o tema mais feio possível. Respostas ## 1. library(shiny) library(thematic) thematic_shiny() # aplica automaticamente o tema ui &lt;- fluidPage( theme = bslib::bs_theme( bg = &quot;#e6f2ff&quot;, fg = &quot;#2c3e50&quot;, base_font = font_google(&quot;Lato&quot;) ), titlePanel(&quot;App com thematic&quot;), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output) { output$plot &lt;- renderPlot({ plot(rnorm(100)) }) } shinyApp(ui, server) ## 2. tema &lt;- bslib::bs_theme( bg = &quot;#ff00ff&quot;, # Rosa neon de fundo fg = &quot;#00ff00&quot;, # Verde neon para texto base_font = font_google(&quot;Comic Neue&quot;), # Fonte bizarra heading_font = font_google(&quot;Creepster&quot;), # Título ainda mais estranho code_font = &quot;Courier New&quot; ) bslib::bs_theme_preview(tema) Acesso Professor 8.5 UI dinâmica O shiny disponibiliza alguns recursos para criar interfaces de usuário dinâmicas, alterando a UI usando código executado na função do servidor. Existem três técnicas principais para criar interfaces de usuário dinâmicas: Usando a familia de funções update para modificar parâmetros de controles de entrada. Usando tabsetPanel() com updateTabsetPanel() para mostrar e ocultar condicionalmente partes da interface do usuário. Usando uiOutput() e renderUI() gerando partes selecionadas da interface do usuário com código. 8.5.1 Usando a familia de funções update Cada controle de entrada, por exemplo textInput(), é pareado com uma função de atualização, por exemplo updateTextInput(), que permite modificar o controle após sua criação. Exemplos 1. Atualizando parâmetros de slider No exemplo a seguir, o aplicativo possui duas entradas que controlam o min e max de outra entrada, um controle deslizante. A ideia principal é usar observeEvent() para disparar updateSliderInput() sempre que as entradas min ou max mudarem. ui &lt;- fluidPage( numericInput(&quot;min&quot;, &quot;Mínimo&quot;, 0), numericInput(&quot;max&quot;, &quot;Máximo&quot;, 3), sliderInput(&quot;n&quot;, &quot;n&quot;, min = 0, max = 3, value = 1) ) server &lt;- function(input, output, session) { observeEvent(input$min, { updateSliderInput(inputId = &quot;n&quot;, min = input$min) }) observeEvent(input$max, { updateSliderInput(inputId = &quot;n&quot;, max = input$max) }) } As funções de atualização recebem o nome do input como o argumento inputId. Os argumentos restantes correspondem aos argumentos para construir o input que podem ser modificados após a criação. 2. Resetar controles O app a seguir ilustra como redefinir os parâmetros dos controles para seus valores iniciais. ui &lt;- fluidPage( sliderInput(&quot;x1&quot;, &quot;x1&quot;, 0, min = -10, max = 10), sliderInput(&quot;x2&quot;, &quot;x2&quot;, 0, min = -10, max = 10), sliderInput(&quot;x3&quot;, &quot;x3&quot;, 0, min = -10, max = 10), actionButton(&quot;reset&quot;, &quot;Resetar&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$reset, { updateSliderInput(inputId = &quot;x1&quot;, value = 0) updateSliderInput(inputId = &quot;x2&quot;, value = 0) updateSliderInput(inputId = &quot;x3&quot;, value = 0) }) } 3. Atualizar texto de um botão de ação ui &lt;- fluidPage( numericInput(&quot;n&quot;, &quot;Simulações&quot;, 10), actionButton(&quot;simula&quot;, &quot;Simular&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$n, { texto_botao &lt;- paste0(&quot;Simular &quot;, input$n, &quot; vezes&quot;) updateActionButton(inputId = &quot;simula&quot;, label = texto_botao) }) } 4. Caixas de seleção hierárquicas Uma aplicação particularmente importante é facilitar a seleção em uma longa lista de opções possíveis, por meio da filtragem passo a passo. Considere o conjunto de dados simulado a seguir: dados &lt;- data.frame( Cidade = c(&quot;Curitiba&quot;, &quot;Curitiba&quot;, &quot;Curitiba&quot;, &quot;Londrina&quot;, &quot;Londrina&quot;, &quot;Londrina&quot;, &quot;Maringá&quot;, &quot;Maringá&quot;), Escola = c(&quot;GP&quot;, &quot;GP&quot;, &quot;CM&quot;, &quot;RM&quot;, &quot;RM&quot;, &quot;MA&quot;, &quot;BJ&quot;, &quot;BJ&quot;), Turma = as.integer(c(2, 3, 2, 1, 2, 3, 1, 2)) ) Aplicando alguns filtros a estes dados: # library(dplyr) # Filtando a Cidade de Curitiba cidade_curi &lt;- filter(dados, Cidade == &quot;Curitiba&quot;) cidade_curi ## Cidade Escola Turma ## 1 Curitiba GP 2 ## 2 Curitiba GP 3 ## 3 Curitiba CM 2 # Escolas de Curitiba unique(cidade_curi$Escola) ## [1] &quot;GP&quot; &quot;CM&quot; # Filtrando uma escola para Curitiba escola_curi &lt;- filter(cidade_curi, Escola == &quot;GP&quot;) escola_curi ## Cidade Escola Turma ## 1 Curitiba GP 2 ## 2 Curitiba GP 3 Neste caso, os dados tem uma hierarquia natural: Cada Cidade contém Escolas. Cada Escola contém Turmas Vamos criar uma interface de usuário onde você possa: Selecionar um Cidade para ver todas as Escolas. Selecionar uma Escola para ver todas as Turmas. A essência da UI é simples: duas caixas de seleção e uma tabela de saída. As opções para a caixa de seleção Escola serão geradas dinamicamente, então usamos choices = NULL. Na função de servidor: É criado um reativo, cidade(), que contém as linhas das escolas e turmas que correspondem à cidade selecionada. Sempre que cidade() muda, a lista choices na caixa de seleção input$escola é atualizada. É criado outro reativo, escola(), que contém as linhas de cidade() que correspondem à escola selecionada. Os dados contendo a Cidade e Escola selecionados são exibidos em output$dados_filtrados. Neste caso, o cidade e escola foram considerados reativos, por terem sido utilizados em mais de um lugar. Em casos mais simples, isso não seria necessário. library(shiny) # Interface do usuário ui &lt;- fluidPage( # Menu suspenso para selecionar o Cidade # (usa os valores únicos da coluna Cidade) selectInput(&quot;cidade&quot;, &quot;Escolha uma Cidade:&quot;, choices = unique(dados$Cidade)), # Menu suspenso para selecionar a Escola # (inicialmente vazio, será preenchido dinamicamente) selectInput(&quot;escola&quot;, &quot;Escolha uma Escola:&quot;, choices = NULL), # Local onde será exibida a tabela com os dados filtrados tableOutput(&quot;dados_filtrados&quot;) ) # Lógica do servidor server &lt;- function(input, output, session) { # Expressão reativa que filtra os dados # com base na Cidade selecionada cidade &lt;- reactive({ filter(dados, Cidade == input$cidade) }) # Quando a cidade mudar, # atualiza a lista de escolas disponíveis observeEvent(cidade(), { # escolas únicas da Cidade filtrada choices &lt;- unique(cidade()$Escola) # atualiza o selectInput de escola updateSelectInput(inputId = &quot;escola&quot;, choices = choices) }) # Expressão reativa que filtra os dados # com base na escola selecionada escola &lt;- reactive({ req(input$escola) # garante que a escola foi selecionada filter(cidade(), Escola == input$escola) }) # Renderiza a tabela com os dados filtrados output$dados_filtrados &lt;- renderTable({ escola() %&gt;% # seleciona as colunas a serem exibidas select(Cidade, Escola, Turma) }) } shinyApp(ui, server) Exercícios 1. Crie um aplicativo com um sliderInput que possibilite ao usuário selecionar um número e um botão de ação que, ao clicado, atualize o label desse slider para o número atual selecionado. 2. Crie um aplicativo com um botão de ação nomeado “trocar” e um selectInput com 3 letras do alfabeto. O objetivo é que ao clicar no botão “trocar” as opções de letras do alfabeto sejam atualizadas para outras letras aleatórias. 3. Crie um aplicativo com 2 inputs numéricos e um slider cujo valor seja atualizado com a média destes inputs, conforme eles forem modificados. 4. Complete a interface de usuário abaixo com uma função de servidor que atualiza as opções de input$county com base em input$state. library(openintro, warn.conflicts = FALSE) states &lt;- unique(county$state) ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;State&quot;, choices = states), selectInput(&quot;county&quot;, &quot;County&quot;, choices = NULL) ) 5. Complete a interface de usuário abaixo com uma função de servidor que atualiza as opções de input$country com base em input$continent. Use output$data para exibir todas as linhas correspondentes. library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = continents), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) Respostas ## 1. ui &lt;- fluidPage( sliderInput(&quot;nota&quot;, &quot;Nota&quot;, min = 0, max = 10, value = 5), actionButton(&quot;atualizar&quot;, &quot;Atualizar rótulo&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$atualizar, { updateSliderInput(inputId = &quot;nota&quot;, label = paste(&quot;Nota:&quot;, input$nota)) }) } ## 2. ui &lt;- fluidPage( actionButton(&quot;trocar&quot;, &quot;Trocar opções&quot;), selectInput(&quot;escolha&quot;, &quot;Escolha uma opção:&quot;, choices = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ) server &lt;- function(input, output, session) { observeEvent(input$trocar, { novas_opcoes &lt;- sample(LETTERS[1:6], size = 3) updateSelectInput(inputId = &quot;escolha&quot;, choices = novas_opcoes) }) } ## 3. ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Valor A&quot;, value = 10), numericInput(&quot;b&quot;, &quot;Valor B&quot;, value = 30), sliderInput(&quot;media&quot;, &quot;Média&quot;, min = 0, max = 100, value = 20) ) server &lt;- function(input, output, session) { observeEvent(c(input$a, input$b), { media_valor &lt;- mean(c(input$a, input$b)) updateSliderInput(inputId = &quot;media&quot;, value = media_valor) }) } ## 4. library(shiny) library(openintro, warn.conflicts = FALSE) # Lista única de estados disponíveis no dataset &#39;county&#39; states &lt;- unique(county$state) # Interface do usuário ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;State&quot;, choices = states),# Seletor de estado selectInput(&quot;county&quot;, &quot;County&quot;, choices = NULL) # Seletor de condado (atualizado dinamicamente) ) # Função do servidor server &lt;- function(input, output, session) { # Observa mudanças no estado selecionado observeEvent(input$state, { # Filtra os condados correspondentes ao estado selecionado counties &lt;- unique(county$name[county$state == input$state]) # Atualiza o seletor de condados updateSelectInput(inputId = &quot;county&quot;, choices = counties) }) } ## ou (solução livro) server &lt;- function(input, output, session) { observeEvent(input$state, { req(input$state) # pull out county names choices &lt;- county %&gt;% filter(state == input$state) %&gt;% pull(name) %&gt;% unique() updateSelectInput(inputId = &quot;county&quot;, choices = choices) }) } # Executa o aplicativo shinyApp(ui, server) ## 5. library(shiny) library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( # add &quot;(All)&quot; to the list of choices selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = continents), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) # Função do servidor (usando base R) server &lt;- function(input, output, session) { # Observa mudanças no estado selecionado observeEvent(input$continent, { choices &lt;- unique(gapminder$country[gapminder$continent == input$continent]) # Atualiza o seletor de condados updateSelectInput(inputId = &quot;country&quot;, choices = choices) }) output$data &lt;- renderTable({ req(input$country) gapminder[gapminder$continent == input$continent &amp; gapminder$country == input$country, ] }) } # Função do servidor (usando dplyr) server &lt;- function(input, output, session) { observeEvent(input$continent, { req(input$continent) # pull out country names choices &lt;- gapminder %&gt;% filter(continent == input$continent) %&gt;% pull(country) %&gt;% unique() updateSelectInput(inputId = &quot;country&quot;, choices = choices) }) output$data &lt;- renderTable({ gapminder %&gt;% filter(continent == input$continent, country == input$country) }) } shinyApp(ui, server) Acesso Professor 8.5.2 Usando tabsetPanel() com updateTabsetPanel() Exemplos 1. Guias condicionais Imagine que você queira um aplicativo que permita ao usuário simular distribuições normal, uniforme e exponencial. Cada distribuição tem parâmetros diferentes, então precisaremos de uma maneira de mostrar controles diferentes para cada distribuição. Cada distribuição terá sua interface de usuário exclusiva com tabPanel() e, em seguida, serão oranizadas em guias de um arquivo tabsetPanel(). Em seguida, isso será incorporado na interface de usuário que permite ao usuário escolher o número de amostras e mostra um histograma dos resultados. # Define um conjunto de abas ocultas, onde cada aba contém os # parâmetros para uma distribuição específica parameter_tabs &lt;- tabsetPanel( id = &quot;params&quot;, # ID do tabset usado para controle via server type = &quot;hidden&quot;, # Oculta as abas # (elas são trocadas programaticamente, não clicáveis) # Aba para distribuição normal: precisa de média e desvio padrão tabPanel(&quot;normal&quot;, numericInput(&quot;mean&quot;, &quot;mean&quot;, value = 1), # Input para média numericInput(&quot;sd&quot;, &quot;standard deviation&quot;, min = 0, value = 1) # Input para desvio padrão ), # Aba para distribuição uniforme: precisa de mínimo e máximo tabPanel(&quot;uniform&quot;, numericInput(&quot;min&quot;, &quot;min&quot;, value = 0), # Limite inferior numericInput(&quot;max&quot;, &quot;max&quot;, value = 1) # Limite superior ), # Aba para distribuição exponencial: precisa da taxa tabPanel(&quot;exponential&quot;, numericInput(&quot;rate&quot;, &quot;rate&quot;, value = 1, min = 0) # Parâmetro de taxa (lambda) ) ) # Interface do usuário ui &lt;- fluidPage( sidebarLayout( sidebarPanel( selectInput(&quot;dist&quot;, &quot;Distribution&quot;, # Menu suspenso para escolher a distribuição choices = c(&quot;normal&quot;, &quot;uniform&quot;, &quot;exponential&quot;) ), numericInput(&quot;n&quot;, &quot;Number of samples&quot;, value = 100), # Quantidade de amostras parameter_tabs # Os inputs de parâmetros definidos acima ), mainPanel( plotOutput(&quot;hist&quot;) # Área para exibir o histograma ) ) ) # Função do servidor server &lt;- function(input, output, session) { # Observa a escolha da distribuição e atualiza o tabsetPanel correspondente observeEvent(input$dist, { updateTabsetPanel(inputId = &quot;params&quot;, selected = input$dist) # Ativa a aba correspondente à distribuição }) # Gera a amostra com base na distribuição e nos parâmetros escolhidos sample &lt;- reactive({ switch(input$dist, normal = rnorm(input$n, input$mean, input$sd), # Gera amostra normal uniform = runif(input$n, input$min, input$max), # Gera amostra uniforme exponential = rexp(input$n, input$rate) # Gera amostra exponencial ) }) # Desenha o histograma da amostra gerada output$hist &lt;- renderPlot(hist(sample()), res = 96) # res = 96 define resolução para melhor visualização } O resultado pode ser visualizado em: https://hadley.shinyapps.io/ms-dynamic-conditional/ 2. Guias sequenciais A mesma ideia pode ser usada para criar um “assistente”, um tipo de interface que facilita a coleta de um conjunto de informações, distribuindo-as por várias páginas. Neste exemplo, cada “página” têm botões de ação, facilitando o avanço e o retrocesso. # Interface do usuário ui &lt;- fluidPage( tabsetPanel( # ID do tabset, usado para controlar qual aba está ativa id = &quot;wizard&quot;, # Esconde as abas (mostra apenas o conteúdo) type = &quot;hidden&quot;, # Primeira &quot;página&quot; tabPanel(&quot;page_1&quot;, &quot;Bem-vindo!&quot;, actionButton(&quot;page_12&quot;, &quot;next&quot;) # Botão para ir para a próxima página ), # Segunda página tabPanel(&quot;page_2&quot;, &quot;Falta só uma página&quot;, actionButton(&quot;page_21&quot;, &quot;prev&quot;), # Botão para voltar para a página 1 actionButton(&quot;page_23&quot;, &quot;next&quot;) # Botão para ir para a página 3 ), # Terceira (última) página tabPanel(&quot;page_3&quot;, &quot;Pronto!&quot;, actionButton(&quot;page_32&quot;, &quot;prev&quot;) # Botão para voltar para a página 2 ) ) ) # Função do servidor server &lt;- function(input, output, session) { # Função auxiliar que recebe um número e ativa a aba correspondente switch_page &lt;- function(i) { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = paste0(&quot;page_&quot;, i)) } # Observadores: quando um botão é clicado, chama a função switch_page() observeEvent(input$page_12, switch_page(2)) # Página 1 → 2 observeEvent(input$page_21, switch_page(1)) # Página 2 → 1 observeEvent(input$page_23, switch_page(3)) # Página 2 → 3 observeEvent(input$page_32, switch_page(2)) # Página 3 → 2 } Esse app simula um “wizard” (um fluxo de páginas passo-a-passo), muito comum em formulários ou tutoriais. O tabsetPanel(type = \"hidden\") permite criar várias telas (abas), mas sem mostrar as guias. Cada página é representada por um tabPanel(), e os botões de navegação chamam updateTabsetPanel() para mudar de página. A função switch_page(i) constrói o nome da aba a ativar com paste0(\"page_\", i), por exemplo “page_2”. O resultado pode ser visualizado em: https://hadley.shinyapps.io/ms-wizard Exercícios 1. Crie uma UI em que o usuário escolha uma categoria (por ex., “Carro”, “Moto”, “Bicicleta”), e o app mostre campos específicos para essa categoria, usando abas escondidas. Um selectInput(\"veiculo\", \"Tipo de veículo\", choices = ...) Um tabsetPanel(type = \"hidden\") com uma aba para cada tipo de veículo. No servidor, troque para a aba correspondente com updateTabsetPanel(). 2. Crie um formulário multi-etapas para coletar o nome e a idade do usuário em duas páginas separadas. Página 1: textInput(\"name\", \"Seu nome:\") + botão “Próximo” Página 2: numericInput(\"age\", \"Sua idade:\", value = NA) + botões “Voltar” e “Próximo” Página 3: Exiba um texto com paste(\"Olá\", input$name, \"de\", input$age, \"anos!\") + botão “Reiniciar” que volta para página 1. 3. Crie um mini-quiz com duas perguntas de múltipla escolha. Página 1: Pergunta 1 (radioButtons) + botão “Próximo” Página 2: Pergunta 2 (radioButtons) + botão “Ver Resultado” Página 3: Mostrar pontuação com renderText() com base nas respostas corretas e um botão “Tentar novamente” que reinicia o quiz na página 1. Respostas ## 1. ui &lt;- fluidPage( selectInput(&quot;veiculo&quot;, &quot;Tipo de veículo:&quot;, choices = c(&quot;carro&quot;, &quot;moto&quot;, &quot;bicicleta&quot;)), tabsetPanel( id = &quot;veiculo_tabs&quot;, type = &quot;hidden&quot;, tabPanel(&quot;carro&quot;, numericInput(&quot;portas&quot;, &quot;Número de portas:&quot;, value = 4) ), tabPanel(&quot;moto&quot;, numericInput(&quot;ano&quot;, &quot;Ano de fabricação:&quot;, value = 1990) ), tabPanel(&quot;bicicleta&quot;, selectInput(&quot;tipo_bike&quot;, &quot;Tipo:&quot;, choices = c(&quot;urbana&quot;, &quot;mountain bike&quot;, &quot;estrada&quot;)) ) ) ) server &lt;- function(input, output, session) { observeEvent(input$veiculo, { updateTabsetPanel(inputId = &quot;veiculo_tabs&quot;, selected = input$veiculo) }) } ## 2. ui &lt;- fluidPage( tabsetPanel( id = &quot;wizard&quot;, type = &quot;hidden&quot;, tabPanel(&quot;page_1&quot;, textInput(&quot;name&quot;, &quot;Seu nome:&quot;), actionButton(&quot;to2&quot;, &quot;Próximo&quot;) ), tabPanel(&quot;page_2&quot;, numericInput(&quot;age&quot;, &quot;Sua idade:&quot;, value = NA), actionButton(&quot;back1&quot;, &quot;Voltar&quot;), actionButton(&quot;to3&quot;, &quot;Próximo&quot;) ), tabPanel(&quot;page_3&quot;, textOutput(&quot;summary&quot;), actionButton(&quot;restart&quot;, &quot;Reiniciar&quot;) ) ) ) server &lt;- function(input, output, session) { switch_page &lt;- function(i) { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = paste0(&quot;page_&quot;, i)) } observeEvent(input$to2, { req(input$name) switch_page(2)}) observeEvent(input$back1, switch_page(1)) observeEvent(input$to3, { req(input$age) switch_page(3)}) observeEvent(input$restart, switch_page(1)) output$summary &lt;- renderText({ paste(&quot;Olá&quot;, input$name, &quot;de&quot;, input$age, &quot;anos!&quot;) }) } ## 3. ui &lt;- fluidPage( tabsetPanel( id = &quot;wizard&quot;, type = &quot;hidden&quot;, tabPanel(&quot;page_1&quot;, radioButtons(&quot;q1&quot;, &quot;Quanto é 2 + 2?&quot;, choices = c(&quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), actionButton(&quot;nextq1&quot;, &quot;Próxima&quot;) ), tabPanel(&quot;page_2&quot;, radioButtons(&quot;q2&quot;, &quot;Quanto é 3 * 3?&quot;, choices = c(&quot;6&quot;, &quot;9&quot;, &quot;12&quot;)), actionButton(&quot;result&quot;, &quot;Ver resultado&quot;), actionButton(&quot;backq1&quot;, &quot;Voltar&quot;) ), tabPanel(&quot;page_3&quot;, textOutput(&quot;score&quot;), actionButton(&quot;retry&quot;, &quot;Tentar novamente&quot;) ) ) ) server &lt;- function(input, output, session) { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_1&quot;) observeEvent(input$nextq1, { req(input$q1) updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_2&quot;) }) observeEvent(input$backq1, { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_1&quot;) }) observeEvent(input$result, { req(input$q2) updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_3&quot;) }) observeEvent(input$retry, { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_1&quot;) }) output$score &lt;- renderText({ score &lt;- 0 if (input$q1 == &quot;4&quot;) score &lt;- score + 1 if (input$q2 == &quot;9&quot;) score &lt;- score + 1 paste(&quot;Você acertou&quot;, score, &quot;de 2 perguntas.&quot;) }) } Acesso Professor 8.5.3 Usando uiOutput() e renderUI() Essa técnica permite criar e modificar a interface de usuário enquanto o aplicativo está em execução. Essa solução tem duas partes: uiOutput(): insere um espaço reservado no seu ui. Isso deixa um “buraco” que o código do seu servidor pode preencher posteriormente. renderUI() é chamado server() para preencher o espaço reservado com a interface do usuário gerada dinamicamente. Exemplo: Criando dinamicamente um controle de entrada ui &lt;- fluidPage( textInput(&quot;label&quot;, &quot;Rótulo&quot;), selectInput(&quot;type&quot;, &quot;Tipo&quot;, c(&quot;slider&quot;, &quot;numerico&quot;)), uiOutput(&quot;controle&quot;) ) server &lt;- function(input, output, session) { output$controle &lt;- renderUI({ if (input$type == &quot;slider&quot;) { sliderInput(&quot;dynamic&quot;, input$label, value = 0, min = 0, max = 10) } else { numericInput(&quot;dynamic&quot;, input$label, value = 0, min = 0, max = 10) } }) } Embora mais personalizável, uma das desvantagens de renderUI() é que ele pode deixar o aplicativo mais lento. Assim, recomenda-se manter a maior parte possível da interface do usuário fixa, usando as técnicas descritas anteriormente. Exercícios 1. Usando uiOutput() e renderUI() Crie um app que mostre um tipo diferente de controle de entrada (textInput, numericInput ou sliderInput) dependendo da opção escolhida pelo usuário. Crie um app que pergunte ao usuário quantos nomes deseja informar (de 1 a 5) e mostre dinamicamente esse número de caixas de texto para preencher os nomes. Respostas ## a. ui &lt;- fluidPage( selectInput(&quot;tipo&quot;, &quot;Tipo de entrada:&quot;, choices = c(&quot;texto&quot;, &quot;número&quot;, &quot;slider&quot;)), uiOutput(&quot;entrada&quot;), verbatimTextOutput(&quot;resposta&quot;) ) server &lt;- function(input, output, session) { output$entrada &lt;- renderUI({ if (input$tipo == &quot;texto&quot;) { textInput(&quot;valor&quot;, &quot;Digite algo:&quot;) } else if (input$tipo == &quot;número&quot;) { numericInput(&quot;valor&quot;, &quot;Informe um número:&quot;, value = 0) } else if (input$tipo == &quot;slider&quot;) { sliderInput(&quot;valor&quot;, &quot;Escolha um valor:&quot;, min = 0, max = 100, value = 50) } }) output$resposta &lt;- renderPrint({ input$valor }) } ## ou server &lt;- function(input, output, session) { output$entrada &lt;- renderUI({ switch(input$tipo, &quot;texto&quot; = textInput(&quot;valor&quot;, &quot;Digite algo:&quot;), &quot;número&quot; = numericInput(&quot;valor&quot;, &quot;Informe um número:&quot;, value = 0), &quot;slider&quot; = sliderInput(&quot;valor&quot;, &quot;Escolha um valor:&quot;, min = 0, max = 100, value = 50) ) }) output$resposta &lt;- renderPrint({ input$valor }) } ## b. ui &lt;- fluidPage( numericInput(&quot;n&quot;, &quot;Quantos nomes?&quot;, value = 1, min = 1, max = 5), uiOutput(&quot;nomes&quot;) ) server &lt;- function(input, output, session) { output$nomes &lt;- renderUI({ req(input$n) lapply(1:input$n, function(i) { textInput(inputId = paste0(&quot;nome&quot;, i), label = paste(&quot;Nome&quot;, i)) }) }) # função lapply: aplica uma função a cada elemento de uma lista, # ou de vetor, retornando lista. lapply(list(1,2,3), function(i) i^2) # ou lapply(1:3, function(i) i^2) Acesso Professor 8.5.4 Inclusão de fórmulas no Shiny 1. Introdução O Shiny permite inserir fórmulas matemáticas usando LaTeX com o auxílio do MathJax. Para habilitar o recurso, basta incluir a função withMathJax(). Exemplo: library(shiny) ui &lt;- fluidPage( # Título do app titlePanel(&quot;Equação de segundo grau&quot;), # Fórmula em LaTeX withMathJax(&quot;$$x = \\\\frac{-b \\\\pm \\\\sqrt{b^2 - 4ac}}{2a}$$&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) Observação: Observe a barra dupla antes das funções do LaTeX. No Latex, a fórmula ficaria: x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} 2. Fórmula fixa A fórmula fica sempre igual, sem depender dos inputs. ui &lt;- fluidPage( titlePanel(&quot;Energia cinética&quot;), withMathJax(&quot;$$E_c = \\\\dfrac{1}{2} m v^2$$&quot;) ) Observação: Observe a barra dupla antes das funções do LaTeX. No Latex, a fórmula ficaria: E_c = \\dfrac{1}{2} m v^2 3. Fórmula dinâmica (alterados pelos inputs do usuário) Podemos substituir os valores inseridos pelo usuário diretamente na fórmula. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Energia cinética dinâmica&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;massa&quot;, &quot;Massa (kg):&quot;, 1000, min = 0), numericInput(&quot;vel&quot;, &quot;Velocidade (m/s):&quot;, 20, min = 0) ), mainPanel( h4(&quot;Cálculo com substituição:&quot;), uiOutput(&quot;formulaSubst&quot;) ) ) ) server &lt;- function(input, output, session) { output$formulaSubst &lt;- renderUI({ E &lt;- 0.5 * input$massa * input$vel^2 withMathJax( sprintf(&quot;$$E_c = \\\\dfrac{1}{2} \\\\times %s \\\\times %s^2 = %.2f\\\\ \\\\text{J}$$&quot;, input$massa, input$vel, E) ) }) } shinyApp(ui, server) Observações: Os símbolos %s, %.2f, etc, aparecem porque usamos a função sprintf() no R. Ela serve para montar strings formatadas, ou seja, construir um texto onde você “encaixa” valores em lugares específicos. No exemplo anterior, apareceram os símbolos %s, %s^2 e %.2f, os quais serão substituídos respectivamente pelas entradas: input$massa, input$vel^2 e E. Principais marcadores usados: %s → insere um valor como string (texto). Exemplo: sprintf(&quot;massa = %s kg&quot;, 1000) # &quot;massa = 1000 kg&quot; %f → insere um número no formato decimal. Exemplo: sprintf(&quot;energia = %f J&quot;, 200000) # &quot;energia = 200000.000000 J&quot; %.2f → insere um número decimal com 2 casas decimais. Exemplo: sprintf(&quot;energia = %.2f J&quot;, 200000) # &quot;energia = 200000.00 J&quot; Para outras casas decimais, alterar o número antes do f: %.0f → arredonda para inteiro. %.3f → mostra 3 casas decimais. m &lt;- 1000 v &lt;- 20 E &lt;- 0.5 * m * v^2 sprintf(&quot;$$E_c = \\\\tfrac{1}{2} \\\\times %s \\\\times %s^2 = %.2f \\\\ J$$&quot;, m, v, E) Saída (renderizada pelo LaTeX): \\[E_c = \\dfrac{1}{2} \\times 1000 \\times 20^2 = 200000.00 \\ J\\] Tabela de formatação sprintf() em R: Marcador Significado Exemplo Saída %s String/texto sprintf(\"Nome: %s\", \"Alice\") \"Nome: Alice\" %d Número inteiro sprintf(\"Idade: %d\", 25) \"Idade: 25\" %f Número decimal sprintf(\"Valor: %f\", 3.14159) \"Valor: 3.141590\" %.2f Decimal com 2 casas sprintf(\"Valor: %.2f\", 3.14159) \"Valor: 3.14\" %e Notação científica (exponencial) sprintf(\"Valor: %e\", 12345) \"Valor: 1.234500e+04\" %g Mais compacto (decimal ou científica) sprintf(\"Valor: %g\", 12345) \"12345\" Outros Exemplos: a) Lei de Ohm: \\[V=R.I\\] library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Lei de Ohm&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;R&quot;, &quot;Resistência (Ω):&quot;, 10, min = 0), numericInput(&quot;I&quot;, &quot;Corrente (A):&quot;, 2, min = 0) ), mainPanel( uiOutput(&quot;leiOhm&quot;) ) ) ) server &lt;- function(input, output, session) { output$leiOhm &lt;- renderUI({ V &lt;- input$R * input$I withMathJax(sprintf(&quot; $$\\\\large{\\\\text{A equação é:}}$$ $$V = R \\\\cdot I$$ $$\\\\text{Substituindo os valores:}$$ $$V = %s \\\\times %s = %.2f\\\\ \\\\text{V}$$&quot;, input$R, input$I, V)) }) } shinyApp(ui, server) Equação de Torricelli library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Equação de Torricelli&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;v0&quot;, &quot;Velocidade inicial (m/s):&quot;, 0), numericInput(&quot;a&quot;, &quot;Aceleração (m/s²):&quot;, 10), numericInput(&quot;s&quot;, &quot;Deslocamento (m):&quot;, 5) ), mainPanel( uiOutput(&quot;torricelli&quot;) ) ) ) server &lt;- function(input, output, session) { output$torricelli &lt;- renderUI({ v &lt;- sqrt(input$v0^2 + 2 * input$a * input$s) withMathJax(sprintf(&quot; $$\\\\large{\\\\textbf{A equação é:}}$$ $$v^2 = v_0^2 + 2a\\\\Delta s$$ $$\\\\textbf{Substituindo os valores:}$$ $$v^2 = %s^2 + 2 \\\\times %s \\\\times %s = %.2f^2$$ &quot;, input$v0, input$a, input$s, v)) }) } shinyApp(ui, server) Observações: Fómulas do Latex devem ser incluidas em $$...$$ e com barra dupla antes de suas funções. A função withMathJax() deve ser usada para fórmulas. Para valores dinâmicos, utilizar renderUI() + sprintf() para construir a string LaTeX. Valores dinâmicos devem ser especificados usando: %s, %d, %.nf ou %g, de acordo com a sua formatação numérica específica. 8.6 Publicando aplicativo em shinyapps.io 1. Instalar o pacote rsconnect no R Abra o R ou RStudio e execute: install.packages(&quot;rsconnect&quot;) 2. Criar uma conta no shinyapps.io Acesse: https://www.shinyapps.io Crie uma conta gratuira e faça login Após o login, vá até a aba Account &gt; Tokens &gt; Show &gt; Show secret &gt; Copy Copiar o código 3. Configurar sua conta e Publicar o App Abra o seu aplicativo no R Clique no ícone azul: “Publish the application” Clique em Conectar conta com shinyapps.io Cole o código copiado no campo especificado Selecione os arquivos da pasta que serão enviados para o app. Dê um nome para o app em “Title” Clique em “Publish” Se tudo estiver ok, o RStudio vai abrir o link do app na web, uma URL como: https://seu-usuario.shinyapps.io/nome-do-app/ Esse é o link público do seu app! 4. Compartilhando o app Copie o link gerado e envie para quem quiser acessar — não é necessário instalar nada! 5. Atualizações do app Sempre que fizer alterações no código, basta clucar no simbolo azul de publicação e fazer o envio novamente na conta conectada. O app será sobrescrito com a nova versão. Observações: Certifique-se de que seu app está salvo em uma pasta, contendo: Um único arquivo chamado app.R ou dois arquivos: ui.R e server.R Todos os arquivos adicionais (por exemplo, imagens, CSVs) também devem estar nessa mesma pasta. Para deletar o app ne sua conta acessar o app em shinyapps.io, arquivar e depois deletar. Exercício: Crie uma conta no shinyapps.io e publique o aplicativo a seguir: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Meu Primeiro App&quot;), sidebarLayout( sidebarPanel( selectInput(&quot;var&quot;, &quot;Variável:&quot;, choices = names(mtcars)) ), mainPanel( plotOutput(&quot;grafico&quot;) ) ) ) server &lt;- function(input, output, session) { output$grafico &lt;- renderPlot({ hist(mtcars[[input$var]], main = input$var) }) } shinyApp(ui, server) 8.7 Exercícios do Capítulo 8 (Entregar na lista 2) 1. Pesquise a definição das funções req() e isolate() e dê exemplos simples da utilização de cada uma delas. 2. Crie uma UI em que o usuário escolha uma categoria (por ex., “Carro”, “Moto”, “Bicicleta”), e o app mostre campos específicos para essa categoria, usando abas escondidas. Além disso, que o app exiba no painel principal um resumo com o tipo e a informação específica do veículo (nº de portas, ano, tipo de bicicleta). Um selectInput(“veiculo”, “Tipo de veículo”, choices = …) Um tabsetPanel(type = “hidden”) com uma aba para cada tipo de veículo. No servidor, troque para a aba correspondente com updateTabsetPanel(). 3. Crie um aplicativo que plote, ggplot(diamonds, aes(carat)) mas permita que o usuário escolha qual geom usar: geom_histogram(), geom_freqpoly(), ou geom_density(). Use um conjunto de guias oculto para permitir que o usuário selecione argumentos diferentes dependendo do geom: geom_histogram() e geom_freqpoly() tenha um argumento binwidth; geom_density() tenha um argumento bw. 4. Construa um app Shiny que: Permita ao usuário escolher um conjunto de dados entre mtcars, iris e ToothGrowth. Mostre uma tabela com os dados e um resumo estatístico. Permita ao usuário selecionar uma variável quantitativa para plotar um histograma. O número de classes (bins) do histograma deve ser ajustável por um sliderInput(). Ao escolher um dataset, os inputs de escolha de variável devem ser atualizados dinamicamente por meio da família update*() de funções. O layout deve ser organizado com fluidRow() e column(). 5 Publique pelo menos um dos aplicativos criados nesta seção no shinyapps.io usando sua conta (plano gratuito) e encaminhe o link da URL do app publicado. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
