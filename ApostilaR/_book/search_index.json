[["index.html", "Estatística Computacional com o R ", " Estatística Computacional com o R Profª. Angélica Maria T. Ribeiro "],["conceitos-básicos.html", "Capítulo 1 Conceitos Básicos 1.1 Sobre o R e RStudio 1.2 Instalação do R e do RStudio 1.3 Estrutura do RStudio 1.4 Operações Básicas em R", " Capítulo 1 Conceitos Básicos 1.1 Sobre o R e RStudio O R é uma linguagem de programação para análises estatísticas de dados É de código aberto, sendo gratuito e de livre distribuição; Amplamente utilizado por pesquisadores, professores e estudantes Disponível para diferentes sistemas operacionais; Conta com inumeros pacotes que disponibilizam funções e dados estatisticos Junto ao R, o RStudio é utilizado como ambiente de desenvolvimento integrado Algumas aplicações de R: Construção de Livros: Livro: R Cookbook Livro: Mastering Shiny Galeria do Bookdown Sites/páginas pessoais: Minha Página Pessoal Galeria do Blogdown Aplicativos dinâmicos: Aplicativos LEG (UFPR) Projeto de Extensão: EducaShiny Galeria do Shiny Referências/Fontes de ajuda Livros R Cookbook R for Data Science The Book of R: A First Course in Programming and Statistics Hands-On Programming with R: Write Your Own Functions and Simulations Learning R: A Step-by-Step Function Guide to Data Analysis Materiais em português Estatística Computacional com R (LEG/UFPR) Ciência de Dados em R Introdução ao Software R Introdução ao R Introdução ao R: Curso Básico de Linguagem R Introdução ao R (Vinícius A., Tania M. e Davi W.) Páginas de ajuda StackOverflow R-bloggers 1.2 Instalação do R e do RStudio Disponivel para Windows, macOS e Linux a instalação do R é simples basta seguir o passo-a-passo: Visitar o site do R: https://cran.r-project.org/ Clicar no link referente ao sistema operacional correspondente Fazer a instalação de acordo com as instruções Após a instalação do R seguir o passo-a-passo para a instalação do Rstudio: Visitar a página do RStudio Fazer o download do arquivo referente ao sistema operacional correspondente Fazer a instalação de acordo com as instruções 1.3 Estrutura do RStudio O Rstudio é dividido em quatro janelas principais: 1. Console (Janela Inferior Esquerda): Permite executar comandos R diretamente. Exibe resultados e mensagens (saídas de funções, erros, avisos). Dicas: Para rodar um código, digite e pressione Enter. Use as setas ↑ e ↓ para acessar comandos anteriores. O atalho Ctrl + L (Windows/Linux) ou Cmd + L (Mac) limpa o console. Exemplo Digite os códigos abaixo no Console. Use as setas ↑ e ↓ para acessar comandos anteriores. Limpe o console. x &lt;- 3 # pressione Enter y &lt;- 2 # pressione Enter print(x) # pressione Enter print(y) # pressione Enter 2. Editor de Scripts (Janela Superior Esquerda): Editor de arquivos R (.R), RMarkdown (.Rmd), Shiny Apps, entre outros. Permite escrever e salvar códigos para execução posterior. Dicas: Ctrl + Enter → Executa a linha atual. Ctrl + Shift + Enter ou Ctrl + A e Ctrl + Enter → Executa o script inteiro. Ctrl + S → Salva o arquivo. Para criar um novo script: File → New File → R Script. Exemplo Digite os códigos abaixo no Editor de Scripts. Utilize Ctrl + Enter para compilar cada linha separadamente. Utilize Ctrl + Shift + Enter (ou Ctrl + A e Ctrl + Enter) para compilar todo o script. Salve o arquivo em algum repositório. a &lt;- -1 b &lt;- 5 a b 3. Ambiente e Histórico (Janela Superior Direita): Environment: Mostra objetos carregados na sessão (data frames, variáveis, funções). History: Lista de comandos executados no console. Connections: Permite conectar-se a bancos de dados. Dicas: Use ls() no console para listar os objetos carregados. Para limpar o ambiente: rm(list = ls()) Exemplo Consulte as abas Ambiente e Histórico. Visualize as variáveis criadas e funções utilizadas. Utilize rm(list = ls()) para limpar o ambiente. 4. Janela de Arquivos, Plots, Pacotes e Ajuda (Janela Inferior Direita): Files: Gerenciador de arquivos do diretório de trabalho. Plots: Exibe gráficos gerados pelo R. Packages: Lista pacotes instalados e permite carregar ou instalar novos. Help: Ajuda e documentação de funções do R. Viewer: Exibe documentos HTML, visualizações interativas (como Shiny). Presentation: Permite criar apresentações de slides (RMarkdown). Dicas: Instalar um pacote: install.packages(\"nome_do_pacote\") ou clicar no botão Install na aba Packages. Carregar um pacote: library(\"nome_do_pacote\") ou “marcar” o pacote na aba Packages. Visualizar ajuda de uma função (ou pacote): ?nome_da_função ou help(nome_da_função). Listar pacotes carregados: search() Exemplo Copie e cole o código plot(1:10). Visualize o resultado na aba Plots. Exporte o gráfico. Instale e carregue o pacote ggplot2. Encontre a documentação do pacote no cran do R. Consulte na aba help a documentação da função mean(). Qual argumento permite ignorar valores NA nos cálculos de média? 1.3 Exercícios da Sessão 1. No Console, execute os seguintes comandos e observe os resultados: x &lt;- 10 y &lt;- 5 soma &lt;- x + y soma Qual foi o valor impresso no console? Use o comando ls() no console, o que ele faz? 2. No Editor de Scripts, crie um novo arquivo R: File → New File → R Script. Copie e cole o seguinte código no script: # Criando um vetor numeros &lt;- c(1, 2, 3, 4, 5) # Calculando a média media &lt;- mean(numeros) # Mostrando o resultado print(media) Salve o script como meuscript.R Execute o script inteiro usando Ctrl + A e Ctrl + Enter. O que foi impresso no console? 3. No Editor de Scripts cole este código e execute: x &lt;- seq(-10, 10, 0.1) y &lt;- sin(x) plot(x, y, type = &quot;l&quot;, col = &quot;blue&quot;, main = &quot;Gráfico de Seno&quot;) Vá até a aba Plots e veja o gráfico gerado. Clique em Export para salvar o gráfico. 4. Na aba Packages, instale e carregue o pacote de manipulação de dados dplyr. Encontre a documentação do pacote no Cran do R. 5. No Console do RStudio, consulte a documentação das seguintes funções: ?mean ?sd ?sum ?seq ?sample Descreva resumidamente o que faz cada função. Anote os principais argumentos de cada função. 1.4 Operações Básicas em R 1.4.1 Operações Aritméticas R funciona como uma calculadora, permitindo operações básicas com números e variáveis. Exemplo # Soma 2 + 3 # Subtração 10 - 4 # Multiplicação 5 * 2 # Divisão 9 / 3 # Exponenciação 2^3 # Raiz quadrada sqrt(16) # Resto da divisão 10 %% 3 # Parte inteira da divisão 10 %/% 3 Ordem de Prioridade dos Operadores Aritméticos Parênteses () – maior prioridade Exponenciação ^ Multiplicação e Divisão *, / Soma e Subtração +, - Exemplo 2 + 3 * 4 (2 + 3) * 4 2 * 5 ^ 2 (2 * 5) ^ 2 5 * 3 / 2 5 + 3 - 2 1.4.2 Criando Variáveis (objetos) Para criar uma variável ou objeto, usamos o simbolo de atribuição &lt;- ## Atribuindo um número a um objeto: x &lt;- 5; y &lt;- 3 Operações entre objetos numéricos: x+y # soma x-y # subtração x*y # produto x/y # quociente Restrições nos nomes das variáveis (objetos) 1. Começo do Nome: Não pode começar com número ou caracteres especiais. Deve começar com uma letra (A-Z ou a-z). nome_valido &lt;- 5 # Correto 1nome_invalido &lt;- 15 # Erro: nome não pode começar com número @nome_invalido &lt;- 15 # Erro: nome não pode começar com caracteres especiais 2. Espaços e Caracteres: O nome não deve conter espaços nem caracteres especiais como @, #, -, $, etc. O underline (_) é um caractere permitido no meio do nome. variavel_valida_1 &lt;- 20 # Correto variavel#invalida &lt;- 40 # Erro: caractere inválido (#) variavel@invalida &lt;- 40 # Erro: caractere inválido (@) 3. Diferenciação de Maiúsculas e Minúsculas: O R diferencia maiúsculas de minúsculas. Assim, var, Var e VAR são considerados nomes diferentes. var &lt;- 100 Var &lt;- 200 print(var) # 100 print(Var) # 200 4. Palavras Reservadas: Não é permitido usar palavras reservadas do R (como if, else, for, TRUE, FALSE, etc.). Essas palavras têm significados específicos e não podem ser sobrescritas. for &lt;- 10 # Erro: &#39;for&#39; é uma palavra reservada if &lt;- 20 # Erro: &#39;if&#39; é uma palavra reservada 5. Pontos e Nomes de funções preexistentes: Não é recomendado utilizar pontos. Também evitar usar nomes que conflitem com funções preexistentes do R. ## Evitar nome.com.ponto &lt;- 100 # Correto, mas pode ser confuso mean &lt;- 2 mean(mean) Dicas para os nomes das variáveis (objetos) A convenção em R é usar underline (_) para nomes de objetos (exceto no inicio). Evitar nomes ambíguos e usar nomes descritivos que deixem claro o que o objeto representa. ## Exemplos de Nomes Válidos x_1 &lt;- 5 minha_variavel &lt;- 10 temperatura_curitiba &lt;- 20 altura_estudantes &lt;- 160 Exercícios 1. Realize as seguintes operações no R: Soma de 45 e 23. Subtração de 78 por 35. Multiplicação de 12 e 9. Divisão de 100 por 4. Calcule 5 elevado à potência 3. Calcule a raiz quadrada de 64. 2. Atribua os valores 10 e 5 a duas variáveis chamadas a e b, respectivamente. Em seguida, calcule: A soma de a e b. O produto de a e b. A diferença entre a e b. O quociente de a dividido por b. 3. Algumas regras devem ser seguidas ao nomear variáveis em R. Analise os seguintes nomes e indique quais são válidos e quais causarão erro. Justifique a sua resposta. 1numero &lt;- 100 meu_numero &lt;- 25 data &lt;- &quot;2025-03-15&quot; for &lt;- &quot;teste&quot; x@y &lt;- 50 x_y &lt;- 5 Respostas 3. 1numero &lt;- 100 # Inválido: não pode começar com número meu_numero &lt;- 25 # Válido data &lt;- &quot;2025-03-15&quot; # Válido, mas desaconselhado (conflito com função data()) for &lt;- &quot;teste&quot; # Inválido: &quot;for&quot; é palavra reservada x@y &lt;- 50 # Inválido: caractere inválido (@) x_y &lt;- 5 # Válido Acesso Professor 1.4.3 Operações Lógicas e Comparações Os operadores lógicos em R são usados para avaliar expressões booleanas (VERDADEIRO ou FALSO) e criar condições. Eles operam em vetores, valores lógicos (TRUE, FALSE) e numéricos e são muito usados em estruturas condicionais e filtros de dados. 1. Operadores de Comparação Estes operadores retornam TRUE ou FALSE, dependendo do resultado da comparação. Operador Descrição Exemplo Resultado == Igualdade 10 == 10 TRUE != Diferente 10 != 5 TRUE &gt; Maior que 10 &gt; 5 TRUE &lt; Menor que 10 &lt; 5 FALSE &gt;= Maior ou igual 10 &gt;= 10 TRUE &lt;= Menor ou igual 10 &lt;= 5 FALSE Obs.: Para consultar o help destas funções usar ?Comparison ou help(\"operador\"), para algum operador específico. 2. Operadores Lógicos Operador Descrição Exemplo Resultado ! Negação lógica !TRUE FALSE &amp; E lógico (TRUE &amp; FALSE) FALSE | OU lógico (TRUE | FALSE) TRUE &amp;&amp; E lógico (TRUE &amp;&amp; FALSE) FALSE || OU lógico (TRUE || FALSE) TRUE Obs.: Para consultar o help destas funções usar ?Logic ou help(\"operador\"), para algum operador específico. Diferença entre &amp; e &amp;&amp;, | e || As formas mais curtas (&amp; e |) realizam comparações elemento a elemento. As formas mais longas (&amp;&amp; e ||) avaliam da esquerda para a direita, prosseguindo apenas até que o resultado seja determinado (em geral, mais eficiente computacionalmente). Exemplos ## Operadores de Comparação 5 &gt; 3 5 != 3 ## Operadores Lógicos TRUE &amp; TRUE # ambos são verdadeiros? Sim -&gt; TRUE, Não -&gt; FALSE TRUE | FALSE # pelo menos um deles é verdadeiro? Sim -&gt; TRUE, Não -&gt; FALSE ## Operadores de Comparação e Lógicos (5&gt;3) &amp; (4&gt;6) # FALSE (2&lt;3) | (4&lt;6) # TRUE Exercícios 1. Considere os seguintes números: a &lt;- 7, b &lt;- 3. No R, verifique as condições: Se a é maior que b Se a é divisível por 2 Se a é maior que b E (lógico) se a é divisível por 2, usando o operador lógico &amp;&amp; 2. Identifique, primeiramente sem o uso do R, o que retornará as relações a seguir (TRUE ou FALSE). Na sequência, confira os resultados usando o R. 10 &gt; 5 5 == 5 5 != 3 (3 + 2) &gt;= 5 10 / 2 &lt; 6 (4 &gt; 2) &amp; (10 &lt;= 20) (7 &lt; 3) | (8 == 8) !TRUE !(5 &gt; 3) Respostas 1. a &lt;- 7 b &lt;- 3 - a&gt;b - (a%%2==0) - a&gt;b &amp;&amp; (a%%2==0) 2. 10 &gt; 5 ## [1] TRUE 5 == 5 ## [1] TRUE 5 != 3 ## [1] TRUE (3 + 2) &gt;= 5 ## [1] TRUE 10 / 2 &lt; 6 ## [1] TRUE (4 &gt; 2) &amp; (10 &lt;= 20) ## [1] TRUE (7 &lt; 3) | (8 == 8) ## [1] TRUE !TRUE ## [1] FALSE !(5 &gt; 3) ## [1] FALSE Acesso Professor 1.4 Exercícios da Sessão 1. Resolva as expressões abaixo (primeiramente sem o R) e explique o resultado com base na ordem de prioridade dos operadores. Na sequência, confira os resultados usando o R. # a) resultado1 &lt;- 5 + 3 * 2 # b) resultado2 &lt;- (5 + 3) * 2 # c) resultado3 &lt;- 10 / 2 + 3 # d) resultado4 &lt;- 10 / (2 + 3) # e) resultado5 &lt;- 4^2 / 2 2. Dados os valores: x &lt;- 15; y &lt;- 10; z &lt;- 20 Quais das relações a seguir serão TRUE e quais serão FALSE: # a) x &gt; y &amp; y &lt; z # b) x == 15 | y &gt; z # c) !(x &lt; z) # d) (x &gt;= y) &amp; (y != 10) # e) (x &lt; y) | (z &gt; x) Respostas 1. # a) (resultado1 &lt;- 5 + 3 * 2) ## [1] 11 # b) (resultado2 &lt;- (5 + 3) * 2) ## [1] 16 # c) (resultado3 &lt;- 10 / 2 + 3) ## [1] 8 # d) (resultado4 &lt;- 10 / (2 + 3)) ## [1] 2 # e) (resultado5 &lt;- 4^2 / 2) ## [1] 8 2. x &lt;- 15 y &lt;- 10 z &lt;- 20 # a) x &gt; y &amp; y &lt; z ## [1] TRUE # b) x == 15 | y &gt; z ## [1] TRUE # c) !(x &lt; z) ## [1] FALSE # d) (x &gt;= y) &amp; (y != 10) ## [1] FALSE # e) (x &lt; y) | (z &gt; x) ## [1] TRUE Acesso Professor "],["estruturas-de-dados.html", "Capítulo 2 Estruturas de Dados 2.1 Vetores 2.2 Fatores 2.3 Matrizes 2.4 Listas 2.5 Data Frames 2.6 Exercícios do Capítulo 2 (Entregar na lista 1)", " Capítulo 2 Estruturas de Dados No R, as principais estruturas de dados são: Vetores Fatores Matrizes Listas Data frames 2.1 Vetores Vetores são a estrutura de dados mais básica do R. Um vetor é uma sequência de elementos do mesmo tipo, podendo ser numérico, caracter ou lógico. Pode ser definido como um conjunto de valores: \\(V=(v_1,v_2,...,v_n)\\). Principais Características dos Vetores Homogeneidade: Todos os elementos devem ser do mesmo tipo (numérico, lógico ou caractere). Indexação Baseada em 1: O acesso aos elementos é feito por índices que começam em 1 (diferente de outras linguagens como Python e C, que começam em 0). Operações Vetorizadas: Permite a realização de operações matemáticas diretamente sobre o vetor. Tamanho Dinâmico: Podem ser expandidos automaticamente conforme necessário. Reciclagem de Vetores: Quando os vetores têm tamanhos diferentes, o vetor menor é reciclado para igualar o comprimento do maior. Criando um vetor Criando um vetor com c() # Vetor numérico a &lt;- c(1, 2, 3, 4, 5) # Vetor de caracteres b &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # Vetor lógico c &lt;- c(TRUE, FALSE, TRUE) # Vetor misto (convertido para caractere) d &lt;- c(1, &quot;teste&quot;, TRUE) # Exibindo os vetores print(a) print(b) print(c) print(d) Criando um vetor com seq() Usar \\(a:b\\) cria uma sequência de a a b, ou seja, \\(a, a+1, a+2, ..., b\\) ## Criando uma sequencia de 1 a 6 1:6 ## Criando uma sequencia de 5 a 10 5:10 ## Criando uma sequencia decrescente de 10 a 1 10:1 Também podemos usar a função seq() para criar sequências: seq(from = 1, to = 10, by = 2) # gera sequencias de numeros # from: valor inicial, to: valor final, # by (opcional): Incremento, # length.out (opcional): Número total de elementos ## Criando uma sequencia de 1 a 6 seq(from = 1, to = 6, by = 1) #equivalente a 1:6 ## Criando uma sequencia de 1 a 10, com 5 elementos seq(1, 10, length.out = 5) Criando um vetor com a função seq() seq1 &lt;- seq(1, 10, length.out = 5) Criando um vetor com rep() rep(2, times = 3) # repete números ou vetores # x: O valor ou vetor a ser repetido. # times: Número total de repetições do vetor completo. # length.out: Define o comprimento final do vetor gerado. # each: Número de repetições de cada elemento individualmente. # times ou length.out devem ser usados. ## Repete o valor 5, até completar 2 elementos rep(5, length.out = 2) ## Repete o vetor c(2,3) até completar 5 elementos rep(c(2,3), length.out = 5) ## Repete o vetor c(2,3) até 5 vezes rep(c(2,3), times = 5) ## Repete cada elemento do vetor c(2,3), 3 vezes rep(c(2,3), each = 3) Criando um vetor com a função rep() rep1 &lt;- rep(c(1,2), each = 3) Criando um vetor com scan() A função scan() é utilizada para ler dados de entrada e criar vetores. Ela é muito útil para ler dados de um arquivo ou diretamente do console. Exemplo - Vetor numérico: Considere os valores 10 20 30 40 60. Para ler no R, fazemos: # Copie os dados acima. # Digite o código abaixo no Console do R: x &lt;- scan() # Pressione Enter. # Cole os valores no Console. # Para finalizar, pressione Enter 2 vezes. print(x) Exemplo - Vetor de caracteres: Considere os valores Ana Mateus Carlos Tati. Para ler no R, fazemos: # Copie os dados acima. # Digite o código abaixo no Console do R: nomes &lt;- scan(what = character()) # Pressione Enter. # Cole os valores no Console. # Para finalizar, pressione Enter 2 vezes. print(nomes) Exemplo - Separador diferente: Considere os valores 1,2,3,4,5. Para ler no R, fazemos: # Copie os dados acima. # Digite o código abaixo no Console do R: valores &lt;- scan(sep = &quot;,&quot;) # Pressione Enter. # Cole os valores no Console. # Para finalizar, pressione Enter 2 vezes. print(valores) Manipulação e características de vetores # Criando um vetor: a &lt;- c(1,2,5,7,8,10) # Primeiro elemento de a a[1] # Último elemento a[6] # Subconjunto de elementos a[2:4] # Elementos específicos a[c(1, 3, 5)] Modificando valores do vetor \\(a\\): # Substituindo um elemento a[2] &lt;- 99 # Adicionando novos elementos a &lt;- c(a, 200) # ou usando a função append(): a &lt;- append(a, 300) # Removendo alguma posição do vetor: a &lt;- a[-2] # Removendo mais de uma posição do vetor: a &lt;- a[-c(2,3)] Nomeando os Elementos do Vetor # Nomes do vetor a: names(a) # Atribuindo nomes para o vetor a: names(a) &lt;- c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;, &quot;x5&quot;) a[&quot;x1&quot;] # Retorna 3 (elemento nomeado &quot;a&quot;) Algumas características sobre o vetor: # Seja o vetor numérico: vec_num &lt;- c(3,6,7,9) # Seja o vetor de caracteres: vec_carac &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) # Seja o vetor de valores lógicos: vec_logi &lt;- c(TRUE, TRUE, FALSE) # (1) Tamanho (número de elementos): length(vec_num) length(vec_carac) length(vec_logi) # (2) estrutura: str(vec_num) str(vec_carac) str(vec_logi) Perguntando sobre o tipo do vetor: # is.vector -&gt; identifica qualquer tipo de vetor is.vector(vec_num) is.vector(vec_carac) is.vector(vec_logi) # is.character -&gt; identifica vetores de caracteres is.character(vec_num) is.character(vec_carac) is.character(vec_logi) # is.logical -&gt; identifica vetores de valores logicos is.logical(vec_num) is.logical(vec_carac) is.logical(vec_logi) Para converter vetores de um tipo para outro tipo, funções as.vector, as.character, as.logical: # as.character -&gt; Transforma em vetor de caracteres vec_num_carac &lt;- as.character(vec_num) str(vec_num_carac) vec_logi_carac &lt;- as.character(vec_logi) str(vec_logi_carac) # as.logical -&gt; Transforma em vetor de valores lógicos vec_num_logi &lt;- as.logical(c(0,1,1,0)) str(vec_num_logi) Exercícios 1. Gere o seguinte vetor usando rep(): 5 5 5 5 5 10 10 10 10 10. 2. Use rep() para gerar um vetor que repita c(“A”, “B”, “C”) até atingir o tamanho exato de 8 elementos. 3. Use seq() para gerar uma sequência de números de 1 a 20, pulando de 2 em 2. 4. Crie uma sequência de 5 números entre 0 e 1, com espaçamento igual entre eles. 5. A partir do vetor v &lt;- c(5, 10, 15, 20, 25, 30), extraia os elementos da posição 2 até a 5. 6. Dado v &lt;- c(3, 7, 12, 18, 25), obtenha apenas os valores maiores que 10. 7. Dado v &lt;- c(10, 20, 30, 40, 50), substitua os elementos das posições 2 e 4 por 999. 8. Dado v &lt;- c(2, 4, 6, 8, 10), remova o número que está na posição 4. 9. Dado v &lt;- c(\"1\", \"2\", \"3\", \"4\"), converta-o para numérico. 10. Dado v &lt;- c(100, 200, 300), converta-o para caractere. 11. Leia os valores: 3.5 7.2 9.8 5.1 6.3, usando a função scan(). Conte o número de elementos do vetor. 12. Leia os valores: 10;20;30;40;50, usando a função scan(). 13. Leia os nomes: Maria Isabel,Aurora,Teresa,Luis,Antonio, usando a função scan(). Identifique a estrutura do vetor. Respostas # 1. rep(c(5, 10), each = 5) # 2. rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), length.out = 8) # 3. seq(1, 20, by = 2) # 4. seq(0, 1, length.out = 5) # 5. v &lt;- c(5, 10, 15, 20, 25, 30) v[2:5] # Elementos da posição 2 até 5 # 6. v &lt;- c(3, 7, 12, 18, 25) v[v &gt; 10] # Retorna valores maiores que 10 # 7. v &lt;- c(10, 20, 30, 40, 50) v[c(2, 4)] &lt;- 999 # Modifica as posições 2 e 4 # 8. v &lt;- c(2, 4, 6, 8, 10) v &lt;- v[-4] # Remove o quarto elemento v # 9. v &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) v_numeric &lt;- as.numeric(v) v_numeric # 10. v &lt;- c(100, 200, 300) v_char &lt;- as.character(v) v_char # 11. x &lt;- scan() # 12. x &lt;- scan(sep = &quot;;&quot;) # 13. x &lt;- scan(what = character(), sep = &quot;,&quot;) Acesso Professor Operações com vetores Operações Aritméticas (elemento a elemento) # Considere os valores: a &lt;- 2 v1 &lt;- c(1, 2, 3) v2 &lt;- c(4, 5, 6) ## Soma # Soma de vetores: v1+v2 # Soma de vetor com escalar: v1+a ## Subtração # Subtração de vetores: v1-v2 # Subtração de vetor com escalar: v1-a ## Multiplicação # Multiplicação de vetores v1*v2 # Multiplicação de vetor com escalar: v1*a ## Divisão # Divisão de vetores v1/v2 # Resto da divisão v2%%v1 # Parte inteira da divisão v2%/%v1 # Divisão de vetor por escalar: v1/a ## Potenciação # Potenciação de vetores v1^v2 # Potenciação de vetor por escalar: v1^a ## Produto Escalar v1%*%v2 # equivalente a: sum(v1*v2) Reciclagem de Vetores Quando os vetores têm tamanhos diferentes, o vetor menor é reciclado para igualar o comprimento do maior. v1 &lt;- c(1, 2, 3, 4) v2 &lt;- c(10, 20) v1 + v2 ## [1] 11 22 13 24 Operações Lógicas e de Comparação v1 &gt; v2 v1 &lt; v2 v1 == v2 v1 != v2 # Considere os valores: x1 &lt;- c(TRUE, FALSE, TRUE) x2 &lt;- c(FALSE, FALSE, TRUE) x1 &amp; x2 x1 | x1 !x1 Exercícios 1. Calcule o cubo dos números inteiros de 1 a 100, ou seja, \\(1^3, 2^3, ..., 100^3\\). 2. Sejam v1 &lt;- c(3, 6, 9, 12) e v2 &lt;- c(2, 4, 6, 8). Calcule v1 + v2, v1 - v2, v1 * v2 e v1 / v2. Eleve cada elemento de v1 ao quadrado. Calcule a raiz quadrada de cada elemento de v2. Calcule o produto escalar entre os vetores. 3. Considere v3 &lt;- c(10, 20, 30) e v4 &lt;- c(5, 15). Some v3 + v4. O que aconteceu? Multiplique v3 * v4. O que aconteceu? Explique o conceito de reciclagem de vetores com base no resultado. 4. Considere v6 &lt;- c(10, 15, 20, 25) e v7 &lt;- c(12, 15, 18, 28). Compare v6 e v7 usando &gt;, &lt;, ==, !=. Quais valores de v6 são maiores que 15? Quais valores de v7 são menores ou iguais a 20? Respostas # 1. x &lt;- 1:100 x^3 # 2. v1 &lt;- c(3, 6, 9, 12) v2 &lt;- c(2, 4, 6, 8) v1 + v2 v1 - v2 v1 * v2 v1 / v2 v1^2 sqrt(v2) v1%*%v2 # 3. v3 &lt;- c(10, 20, 30) v4 &lt;- c(5, 15) v3+v4 v3*v4 # 4. v6 &lt;- c(10, 15, 20, 25) v7 &lt;- c(12, 15, 18, 28) v6&gt;v7 v6&lt;v7 v6==v7 v6!=v7 v6[v6&gt;15] v7[v7 &lt;= 20] Acesso Professor Funções úteis para vetores sum() - Soma dos elementos do vetor x &lt;- c(1, 3, 7, 8, 15) sum(x) length() - Tamanho do vetor x &lt;- c(2, 4, 6, 8, 10) length(x) sort() - Ordenar um vetor x &lt;- c(10, 5, 8, 3, 1) sort(x) # Ordenação crescente sort(x, decreasing = TRUE) # Ordenação decrescente which() - Índices que satisfazem uma condição x &lt;- c(10, 20, 30, 40, 50) which(x &gt; 25) # Retorna os índices dos elementos maiores que 25 unique() - Elementos únicos x &lt;- c(1, 2, 2, 3, 3, 3, 4, 4, 4, 4) unique(x) # Retorna os valores únicos table() - Frequência dos elementos x &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;) table(x) # Conta quantas vezes cada letra aparece %in% - Operador de Pertinência Verifica se os elementos de um vetor estão presentes em outro. x &lt;- c(1, 2, 3, 4, 5) y &lt;- c(2, 4, 6) x %in% y # Verifica quais elementos de x estão em y # Terá o tamanho de x # Se quisermos filtrar os valores de x que estão em y: x[x %in% y] # Retorna apenas os elementos de x que também estão em y Table 2.1: Table 2.2: Resumo das Funções para Vetores no R Funcao Descricao Exemplo sum() Soma dos elementos do vetor sum(c(1, 4, 2)) → 7 length() Número de elementos do vetor length(c(1, 2, 3)) → 3 sort() Ordena os elementos do vetor sort(c(5, 1, 3)) → 1 3 5 which() Indices dos elementos que atendem a uma condição which(c(2, 5, 8) &gt; 4) → 2 3 unique() Valores únicos de um vetor unique(c(1, 1, 2, 3, 3)) → 1 2 3 table() Frequência de cada elemento do vetor table(c(‘A’, ‘B’, ‘A’)) → A:2 B:1 %in% Verifica se os elementos de um vetor pertencem a outro c(2, 3, 4) %in% c(3, 4, 5) → FALSE TRUE TRUE Valores perdidos e especiais Valores perdidos devem ser definidos como NA (not available): x &lt;- c(1, 3, NA, 2) Outros valores especiais são NaN (not a number),-Inf (menos infinito) e Inf (mais infinito): y &lt;- 0/0 print(y) ## [1] NaN z &lt;- 1/0 print(z) ## [1] Inf Podemos testar a presença de valores especiais: # Testando presença de NA: x &lt;- c(1, 3, NA, 2) is.na(x) ## [1] FALSE FALSE TRUE FALSE # ou any(is.na(x)) ## [1] TRUE # Testando presença de NaN: y &lt;- 0/0 is.na(y) ## [1] TRUE # Testando presença de -Inf ou Inf: z &lt;- 1/0 is.infinite(z) ## [1] TRUE 2.2 Fatores Os fatores no R são similares aos vetores de caracteres. No entanto, o fator contém categorias (niveis), armazenando valores que pertencem a estes níveis. Para criar fatores, usa-se a função factor(). # Vetor de caracteres cores_char &lt;- c(&quot;azul&quot;, &quot;vermelho&quot;, &quot;verde&quot;, &quot;azul&quot;) print(cores_char) # O vetor de caracteres apenas contém texto. ## [1] &quot;azul&quot; &quot;vermelho&quot; &quot;verde&quot; &quot;azul&quot; # Fator cores_fac &lt;- factor(cores_char) print(cores_fac) # O fator atribui níveis aos valores. ## [1] azul vermelho verde azul ## Levels: azul verde vermelho Conversão de fator e vetor de caracteres: # Conversão de fator para vetor de caracteres as.character(cores_fac) ## [1] &quot;azul&quot; &quot;vermelho&quot; &quot;verde&quot; &quot;azul&quot; # Conversão de vetor de caracteres para fator factor(cores_char) ## [1] azul vermelho verde azul ## Levels: azul verde vermelho # ou usando as.factor(): as.factor(cores_char) ## [1] azul vermelho verde azul ## Levels: azul verde vermelho Quando Usar Cada Um? Caracteres (character): se os dados forem simplesmente rótulos sem necessidade de categorias ordenadas ou níveis fixos. Fatores (factor): se os dados representam categorias que serão usadas em análises estatísticas ou visualizações gráficas. A ordem dos níveis dos fatores pode também ser modificada através do argumento levels: cores_levels &lt;- factor(c(&quot;azul&quot;, &quot;vermelho&quot;, &quot;verde&quot;, &quot;azul&quot;), levels = c(&quot;verde&quot;,&quot;azul&quot;,&quot;vermelho&quot;)) cores_levels ## [1] azul vermelho verde azul ## Levels: verde azul vermelho Além disso, os níveis dos fatores podem também ser explicitamente definidos como ordenados, com o argumento ordered = TRUE: satisfacao &lt;- factor(c(&quot;Ruim&quot;, &quot;Bom&quot;, &quot;Excelente&quot;, &quot;Bom&quot;, &quot;Ruim&quot;), levels = c(&quot;Ruim&quot;, &quot;Bom&quot;, &quot;Excelente&quot;), ordered = TRUE) satisfacao ## [1] Ruim Bom Excelente Bom Ruim ## Levels: Ruim &lt; Bom &lt; Excelente Comparação entre ordered = TRUE e ordered = FALSE ordered = TRUE: implica que o R respeita a ordem entre os níveis, permitindo comparações e análises baseadas nessa ordem (variáveis ordinais). ordered = FALSE: significa que os níveis são apenas categorias e não são comparáveis em termos de hierarquia ou ordem (variáveis nominais). Outras funções úteis para fatores: # Níveis do fator levels(cores_levels) # Número de níveis do fator nlevels(cores_levels) Exercícios 1. Dado o vetor: v1 &lt;- c(2, 4, 6, 2, 8, 6, 10, 2, 4, 6) Use funções do R para: Contar o número total de elementos do vetor. Encontrar os elementos únicos do vetor. Ordenar os valores do vetor em ordem decrescente. 2. Dado o vetor de fatores: fatores &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;)) Use funções do R para: Contar quantas vezes cada nível aparece. Listar os níveis únicos do fator. 3. Dados os vetores: v2 &lt;- c(5, 10, 15, 20, 25) v3 &lt;- c(10, 20, 30) Verifique quais elementos de v2 estão presentes em v3 usando %in%. Use a função which() para encontrar as posições dos valores de v2 que estão presentes em v3. 4. Dado o vetor: v4 &lt;- c(10, NA, 30, 50, NA, NaN, 20): Calcule a soma de todos os elementos, ignorando os valores ausentes (NA e NaN). Calcule o número de elementos não ausentes no vetor. Ordene o vetor em ordem crescente, colocando os valores ausentes por último. Use a função which() para encontrar a posição dos valores ausentes no vetor. 5. Dado o vetor de fatores: categorias &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;C&quot;)) Use table() para contar as frequências de cada nível. Altere o nível “B” para “X” e recalcule as frequências. Ordene os niveis em ordem alfabética usando sort() e recalcule as frequências. Respostas # 1. v1 &lt;- c(2, 4, 6, 2, 8, 6, 10, 2, 4, 6) length(v1) unique(v1) sort(v1, decreasing = T) # 2. fatores &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;)) table(fatores) unique(fatores) #ou levels(fatores) # 3. v2 &lt;- c(5, 10, 15, 20, 25) v3 &lt;- c(10, 20, 30) # Verificando presença de elementos v2 %in% v3 # -&gt; elementos 10 e 20 # Posições dos valores de v2 que estão em v3 which(v2 %in% v3) # -&gt; posições 2 e 4 # 4. v4 &lt;- c(10, NA, 30, 50, NA, NaN, 20) sum(v4, na.rm = TRUE) length(v4[!is.na(v4)]) sort(v4, na.last = TRUE) which(is.na(v4)) # 5. categorias &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;C&quot;)) table(categorias) levels(categorias)[levels(categorias) == &quot;B&quot;] &lt;- &quot;X&quot;; table(categorias) categ_ord &lt;- factor(categorias, levels = sort(levels(categorias))); table(categ_ord) Acesso Professor 2.3 Matrizes Matrizes são estruturas bidimensionais de dados, onde todos os elementos devem ser do mesmo tipo. Uma matriz pode ser definida como: \\[ M = \\begin{bmatrix} m_{11} &amp; m_{12} &amp; \\dots &amp; m_{1n} \\\\ m_{21} &amp; m_{22} &amp; \\dots &amp; m_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ m_{m1} &amp; m_{m2} &amp; \\dots &amp; m_{mn} \\end{bmatrix} \\] onde \\(m\\) é o número de linhas e \\(n\\) é o número de colunas da matriz. Neste caso, diz-se que a matriz tem dimensão \\(m\\times n\\). \\(m_{ij}\\) representa o elemento na linha \\(i\\) e coluna \\(j\\). Em programação, matrizes são usadas para armazenar dados de forma estruturada e realizar operações como multiplicação e transposição de maneira eficiente. No R, matrizes podem ser criadas com a função matrix() e podem ser manipuladas com operações matemáticas vetorizadas. # Exemplo de matriz 2x3 matriz &lt;- matrix(1:6, nrow = 2, ncol = 3) matriz ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # Alterando o preenchimento da matriz por linhas: matriz_linhas &lt;- matrix(1:6, nrow = 2, ncol = 3, byrow = T) matriz_linhas ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 Para verificar a dimensão da matriz: dim(matriz) ## [1] 2 3 Adicionando colunas com cbind(): matriz_mais_colunas &lt;- cbind(matriz, rep(99, 2)) Adicionando linhas com rbind(): matriz_mais_linhas &lt;- rbind(matriz, rep(99, 3)) Renomeando linhas e colunas de uma matriz: colnames(matriz) &lt;- c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;) rownames(matriz) &lt;- c(&quot;l1&quot;,&quot;l2&quot;) matriz ## c1 c2 c3 ## l1 1 3 5 ## l2 2 4 6 # ou podemos fazer: matriz2 &lt;- matrix(1:6, nrow = 2, dimnames = list(c(&quot;l1&quot;, &quot;l2&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;))) matriz2 ## c1 c2 c3 ## l1 1 3 5 ## l2 2 4 6 Acessando Elementos de Matrizes # Criando uma matriz 3x3 matriz &lt;- matrix(1:9, nrow = 3) # Para acessar o elemento da linha 2, coluna 3: matriz[2, 3] # Acessando a segunda linha matriz[2, ] # Acessando a terceira coluna matriz[, 3] # Se a matriz tiver nomes nas linhas ou colunas: colnames(matriz) &lt;- c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;) rownames(matriz) &lt;- c(&quot;l1&quot;,&quot;l2&quot;, &quot;l3&quot;) matriz[&quot;l1&quot;,] # -&gt; linha 1 matriz[,&quot;c1&quot;] # -&gt; coluna 1 Também podemos modificar valores diretamente: matriz[1,2] &lt;- 10 # Muda o valor da posição (1,2) para 10 print(matriz) ## c1 c2 c3 ## l1 1 10 5 ## l2 2 4 6 Operações Básicas com Matrizes: ## Soma de matrizes A &lt;- matrix(1:4, nrow = 2) B &lt;- matrix(5:8, nrow = 2) nrow(A) # Número de linhas ncol(A) # Número de colunas dim(A) # dimensão da matriz: número de linhas e número de colunas A + B # Soma elemento a elemento ## Multiplicação elemento a elemento A * B ## Multiplicação de matrizes (produto matricial) A %*% B ## Transposta de uma matriz t(A) ## Diagonal de uma matriz diag(A) ## Determinante de uma matriz det(A) ## Inversão de uma matriz solve(A) ## Função solve para resolver sistemas de equações. Seja Ax=b, com b &lt;- c(2,5) # então a solução x do sistema é: solve(A, b) # para a inversão da matriz apenas, b = I não precisa ser declarado. Exercícios 1. Crie uma matriz de dimensão 4x3 contendo os números de 1 a 12 preenchidos por linha. Em seguida, realize as seguintes operações: Acesse o elemento da terceira linha e segunda coluna. Extraia a segunda linha da matriz. Substitua o elemento da quarta linha e terceira coluna por 99. 2. Crie uma matriz M de dimensão 3×5 contendo os números de 1 a 15 preenchidos por coluna. Exiba a matriz M. Descubra o número de linhas e colunas usando nrow() e ncol(). Exiba a matriz preenchida por linha em vez de coluna. Extraia o elemento na segunda linha e quarta coluna. Modifique o elemento da terceira linha e quinta coluna para 100. Substitua todos os valores da primeira coluna por 0. 3. Crie duas matrizes A e B, ambas 3x3, contendo valores de 1 a 9 e de 10 a 18, respectivamente. Realize a soma e a subtração entre A e B. Multiplique elemento a elemento. Faça o produto matricial entre A e B. 4. Crie as matrizes: Uma matriz identidade 4×4 Uma matriz diagonal com os números 2, 4, 6 e 8 na diagonal principal. Respostas # 1. mat &lt;- matrix(1:12, ncol = 3, byrow = T) mat[3,2] mat[2,] mat[4,3] &lt;- 99 # 2. M &lt;- matrix(1:15, ncol = 5) nrow(M); ncol(M) M &lt;- matrix(1:15, ncol = 5, byrow = T) M[2,4] M[3,5] &lt;- 100 M[,1] &lt;- 0 # 3. A &lt;- matrix(1:9, ncol = 3) B &lt;- matrix(10:18, ncol = 3) A + B A - B A*B A%*%B # 4. I &lt;- diag(4) matriz_diag &lt;- diag(c(2,4,6,8)) Acesso Professor 2.4 Listas Listas podem armazenar diferentes tipos de objetos, como vetores, matrizes, etc. Pode ser criada, fazendo: list(valor1, valor2, valor3). # Criando uma lista minha_lista &lt;- list(&quot;Ana&quot;, 25, c(8, 9, 10), matrix(1:4, ncol = 2)) minha_lista ## [[1]] ## [1] &quot;Ana&quot; ## ## [[2]] ## [1] 25 ## ## [[3]] ## [1] 8 9 10 ## ## [[4]] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Acessando elementos da lista: ## Retorna uma lista com o primeiro elemento minha_lista[1] ## [[1]] ## [1] &quot;Ana&quot; str(minha_lista[1]) ## List of 1 ## $ : chr &quot;Ana&quot; ## Retorna apenas o primeiro elemento da lista # Acessando o primeiro elemento minha_lista[[1]] ## [1] &quot;Ana&quot; str(minha_lista[[1]]) ## chr &quot;Ana&quot; # Acessando o quarto elemento minha_lista[[4]] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Visualizando a estrutura da lista: str(minha_lista) ## List of 4 ## $ : chr &quot;Ana&quot; ## $ : num 25 ## $ : num [1:3] 8 9 10 ## $ : int [1:2, 1:2] 1 2 3 4 Observe que é uma estrutura unidimensional: length(minha_lista) ## [1] 4 Renomeando os elementos da lista: names(minha_lista) &lt;- c(&quot;nome&quot;, &quot;idade&quot;, &quot;notas&quot;, &quot;matriz&quot;) minha_lista ## $nome ## [1] &quot;Ana&quot; ## ## $idade ## [1] 25 ## ## $notas ## [1] 8 9 10 ## ## $matriz ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 # ou já poderiamos ter criado com os nomes: minha_lista &lt;- list(nome = &quot;Ana&quot;, idade = 25, notas = c(8, 9, 10), matriz = matrix(1:4, ncol = 2)) Para acessar os elementos da lista pelo nome, podemos usar o operador $: minha_lista$nome # equivalente a minha_lista[[1]] ## [1] &quot;Ana&quot; minha_lista$matriz # equivalente a minha_lista[[4]] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Podemos também ter uma lista de listas: lista2 &lt;- list(nome = &quot;Ana&quot;, notas = list(sem1 = c(5,6,7), sem2 = c(8,6,9)), materias = list(sem1 = c(&quot;Matematica&quot;, &quot;Historia&quot;, &quot;Fisica&quot;), sem2 = c(&quot;Português&quot;, &quot;Artes&quot;, &quot;Geografia&quot;))) Neste caso, para acessar os elementos, fazemos: # Notas semestre 1 lista2$notas$sem1 ## [1] 5 6 7 # Disciplinas semestre 2 lista2$materias$sem2 ## [1] &quot;Português&quot; &quot;Artes&quot; &quot;Geografia&quot; # Disciplina 2 do semestre 2 # lista2$materias$sem2[2] Exercícios 1. Crie uma lista chamada aluno com os seguintes elementos: Nome: “Maria”, Idade: 22, Notas: 7, 8, 9, Curso: “Matemática”. Depois, realize as operações: Acesse e imprima o nome do aluno. Modifique a idade para 23. Adicione um novo elemento chamado “cidade” com o valor “Curitiba”. Remova o elemento “curso”. 2. Crie uma lista chamada meus_dados contendo um vetor numérico de 5 elementos, um vetor de caracteres com nomes de 3 cidades, um valor lógico (TRUE ou FALSE) e uma matriz 2x2 com números aleatórios. Extraia o vetor numérico. Acesse o segundo elemento do vetor de caracteres. Modifique o valor lógico para FALSE. Extraia o valor da matriz da linha 1, coluna 2. 3. Crie uma lista chamada familia, contendo: Pai: Lista com Nome = “Carlos” e Idade = 45. Mãe: Lista com Nome = “Mariana” e Idade = 42. Filhos: Um vetor com os nomes “Lucas” e “Ana”. Agora, realize as seguintes operações: Acesse e imprima a idade do pai. Acesse e imprima o nome da mãe. Acesse e imprima o segundo filho. Modifique a idade da mãe para 43 anos. Adicione um novo filho chamado “Pedro”. Respostas # 1. # Criando a lista aluno aluno &lt;- list( Nome = &quot;Maria&quot;, Idade = 22, Notas = c(7, 8, 9), Curso = &quot;Matemática&quot; ) # a. Acesse e imprima o nome do aluno aluno$Nome # b. Modifique a idade para 23 aluno$Idade &lt;- 23 # c. Adicione um novo elemento chamado &quot;cidade&quot; com o valor &quot;Curitiba&quot; aluno$Cidade &lt;- &quot;Curitiba&quot; # d. Remova o elemento &quot;curso&quot; aluno$Curso &lt;- NULL # 2. # Criando a lista meus_dados meus_dados &lt;- list( Numeros = c(10, 20, 30, 40, 50), # a. Vetor numérico de 5 elementos Cidades = c(&quot;São Paulo&quot;, &quot;Curitiba&quot;, &quot;Rio de Janeiro&quot;), # b. Vetor de caracteres Logico = TRUE, # c. Valor lógico Matriz = matrix(sample(1:10, 4), nrow = 2) # d. Matriz 2x2 com números aleatórios ) # a. Extraia o vetor numérico meus_dados$Numeros # b. Acesse o segundo elemento do vetor de caracteres meus_dados$Cidades[2] # c. Modifique o valor lógico para FALSE meus_dados$Logico &lt;- FALSE # d. Extraia o valor da matriz da linha 1, coluna 2. meus_dados$Matriz[1,2] # 3. # Criando a lista familia familia &lt;- list( Pai = list(Nome = &quot;Carlos&quot;, Idade = 45), Mae = list(Nome = &quot;Mariana&quot;, Idade = 42), Filhos = c(&quot;Lucas&quot;, &quot;Ana&quot;) ) # a. Acesse e imprima a idade do pai familia$Pai$Idade # b. Acesse e imprima o nome da mãe familia$Mae$Nome # c. Acesse e imprima o segundo filho familia$Filhos[2] # d. Modifique a idade da mãe para 43 anos familia$Mae$Idade &lt;- 43 # e. Adicione um novo filho chamado &quot;Pedro&quot; familia$Filhos &lt;- c(familia$Filhos, &quot;Pedro&quot;) Acesso Professor 2.5 Data Frames Os data.frames são estruturas de dados que armazenam colunas de diferentes tipos (numéricas, categóricas, lógicas). ## Criando um data frame dados &lt;- data.frame( Nome = c(&quot;Ana&quot;, &quot;Bruno&quot;, &quot;Carlos&quot;, &quot;Maria&quot;, &quot;Jose&quot;, &quot;Tata&quot;), Nivel_escolaridade = c(&quot;F&quot;,&quot;M&quot;,&quot;S&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;), Idade = c(25, 30, 22, 10, 15, 16), Nota = c(8,6,3,4,7,2), Aprovado = c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE) ) dados ## Nome Nivel_escolaridade Idade Nota Aprovado ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE ## 3 Carlos S 22 3 FALSE ## 4 Maria M 10 4 FALSE ## 5 Jose F 15 7 TRUE ## 6 Tata M 16 2 FALSE ## Algumas operações em data frames: ## Visualizar os primeiros valores: head(dados) # Mostra as primeiras 6 linhas (padrão) ## Nome Nivel_escolaridade Idade Nota Aprovado ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE ## 3 Carlos S 22 3 FALSE ## 4 Maria M 10 4 FALSE ## 5 Jose F 15 7 TRUE ## 6 Tata M 16 2 FALSE head(dados, 3) # Mostra as primeiras 3 linhas ## Nome Nivel_escolaridade Idade Nota Aprovado ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE ## 3 Carlos S 22 3 FALSE ## Visualizar os últimos valores: tail(dados) ## Nome Nivel_escolaridade Idade Nota Aprovado ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE ## 3 Carlos S 22 3 FALSE ## 4 Maria M 10 4 FALSE ## 5 Jose F 15 7 TRUE ## 6 Tata M 16 2 FALSE ## estrutura str(dados) ## &#39;data.frame&#39;: 6 obs. of 5 variables: ## $ Nome : chr &quot;Ana&quot; &quot;Bruno&quot; &quot;Carlos&quot; &quot;Maria&quot; ... ## $ Nivel_escolaridade: chr &quot;F&quot; &quot;M&quot; &quot;S&quot; &quot;M&quot; ... ## $ Idade : num 25 30 22 10 15 16 ## $ Nota : num 8 6 3 4 7 2 ## $ Aprovado : logi TRUE TRUE FALSE FALSE TRUE FALSE ## Selecionando colunas # Podemos fazer: dados[, 2] ## [1] &quot;F&quot; &quot;M&quot; &quot;S&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; # ou dados$Nivel_escolaridade ## [1] &quot;F&quot; &quot;M&quot; &quot;S&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; ## Selecionando linhas: dados[3,] ## Nome Nivel_escolaridade Idade Nota Aprovado ## 3 Carlos S 22 3 FALSE ## Selecionando um valor de uma linha e uma coluna: dados[2,3] ## [1] 30 # Adicionando uma nova coluna aos dados dados$Status &lt;- c(&quot;Aprovado&quot;, &quot;Aprovado&quot;, &quot;Reprovado&quot;, &quot;Reprovado&quot;, &quot;Aprovado&quot;, &quot;Reprovado&quot;) # Removendo uma coluna dos dados dados$Status &lt;- NULL # Renomeando colunas colnames(dados) &lt;- c(&quot;nome&quot;, &quot;nivel&quot;, &quot;idade&quot;, &quot;nota&quot;, &quot;aprovado&quot;) Ordenando e filtrando valores de um data.frame: # Ordenando os dados por idade -&gt; função order() dados[order(dados$idade), ] ## nome nivel idade nota aprovado ## 4 Maria M 10 4 FALSE ## 5 Jose F 15 7 TRUE ## 6 Tata M 16 2 FALSE ## 3 Carlos S 22 3 FALSE ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE # Ordenando por idade em ordem decrescente dados[order(dados$idade, decreasing = TRUE), ] ## nome nivel idade nota aprovado ## 2 Bruno M 30 6 TRUE ## 1 Ana F 25 8 TRUE ## 3 Carlos S 22 3 FALSE ## 6 Tata M 16 2 FALSE ## 5 Jose F 15 7 TRUE ## 4 Maria M 10 4 FALSE # Selecionando linhas em que Aprovado == T dados[dados$aprovado == T, ] ## nome nivel idade nota aprovado ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE ## 5 Jose F 15 7 TRUE # Selecionando linhas em que idade maior que 25 dados[dados$idade &gt; 25, ] ## nome nivel idade nota aprovado ## 2 Bruno M 30 6 TRUE Usando a função subset: # Selecionando linhas em que Aprovado == T subset(dados, aprovado == T) ## nome nivel idade nota aprovado ## 1 Ana F 25 8 TRUE ## 2 Bruno M 30 6 TRUE ## 5 Jose F 15 7 TRUE # Selecionando linhas em que idade maior que 25 subset(dados, idade &gt; 25) ## nome nivel idade nota aprovado ## 2 Bruno M 30 6 TRUE # Selecionando apenas a coluna &quot;Nome&quot; # onde a idade é maior que 25 subset(dados, idade &gt; 25, select = nome) ## nome ## 2 Bruno # Selecionando os estudantes aprovados # e com nota maior ou igual a 7. subset(dados, nota &gt;= 7 &amp; aprovado == T) ## nome nivel idade nota aprovado ## 1 Ana F 25 8 TRUE ## 5 Jose F 15 7 TRUE Podemos também acessar data frames disponíveis em pacotes do R: # Visualizando os dados de todos os pacotes: data(package = .packages(all.available = TRUE)) # Visualizando dados do pacote datasets data(package = &quot;datasets&quot;) # Chamando o conjunto `mtcars` do pacote datasets data(&quot;mtcars&quot;, package = &quot;datasets&quot;) # Visualizando as primeiras linhas do dataframe head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # Informações sobre os dados: ?mtcars # Estrutura dos dados str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... # Nomes das colunas names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; # Selecionando as variáveis mpg e cyl mtcars[, c(&quot;mpg&quot;, &quot;cyl&quot;)] Exercícios 1. Considere o data.frame: dados &lt;- data.frame( Nome = c(&quot;Ana&quot;, &quot;Bruno&quot;, &quot;Carlos&quot;, &quot;Daniela&quot;, &quot;Eduardo&quot;), Idade = c(25, 30, 22, 28, 35), Altura = c(1.65, 1.80, 1.75, 1.60, 1.85), Peso = c(60, 85, 70, 55, 90), Estudante = c(TRUE, FALSE, TRUE, FALSE, FALSE) ) Selecione apenas a coluna Nome. Selecione as colunas Nome e Idade. Selecione a linha correspondente a “Carlos”. Selecione os nomes das pessoas com idade superior a 28 anos. Selecione apenas os estudantes (Estudante == TRUE). Crie uma nova coluna chamada IMC usando a fórmula IMC = Peso / (Altura^2). Usando a função subset, selecione todas as pessoas com altura maior que 1.70m. Usando a função subset, selecione apenas os estudantes (Estudante == TRUE) e mostre apenas as colunas Nome e Idade. Usando a função subset, selecione as pessoas com IMC &gt;= 25 e que não são estudantes Usando a função subset, filtre os indivíduos com idade entre 25 e 35 anos. Ordenar o data frame em ordem crescente de idade Respostas # 1. # a. dados$Nome # b. dados[, c(&quot;Nome&quot;, &quot;Idade&quot;)] # c. dados[dados$Nome == &quot;Carlos&quot;, ] # d. dados[dados$Idade &gt; 28,]$Nome # e. dados[dados$Estudante == TRUE, ] # f. dados$IMC &lt;- dados$Peso / (dados$Altura^2) # g. subset(dados, Altura &gt; 1.70) # h. subset(dados, Estudante == TRUE, select = c(Nome, Idade)) # i. subset(dados, IMC &gt;= 25 &amp; Estudante == FALSE) # j. subset(dados, Idade &gt;= 25 &amp; Idade &lt;= 35) # k. dados[order(dados$Idade), ] Acesso Professor 2.6 Exercícios do Capítulo 2 (Entregar na lista 1) 1. Crie uma matriz M de dimensão 4x4 contendo números de 1 a 16 preenchidos por linha. Transponha a matriz M e salve o resultado em M_t. Substitua todos os valores da diagonal principal de M por 99. Multiplique cada linha da matriz M por um vetor c(1, 2, 3, 4). Crie uma matriz 3x3 e nomeie suas linhas como “Linha1”, “Linha2”, “Linha3” e colunas como “Col1”, “Col2”, “Col3”. Depois, selecione apenas os elementos da segunda e terceira linha. 2. Crie uma lista chamada minha_lista contendo um vetor numérico de 5 elementos, uma matriz 2x2 e um data frame de 3 linhas e 2 colunas. Substitua o segundo elemento da lista por um novo vetor de 5 números. Verifique se um dos elementos da lista é um data frame. Extraia a segunda coluna do data frame armazenado dentro da lista. Remova o último elemento da lista sem saber quantos elementos ela possui. 3. Crie um data frame chamado df com 5 observações e as colunas Nome (caractere), Idade (numérico) e Profissao (caractere). Converta a coluna Profissao em um fator e exiba seus níveis. Reordene o data frame pela coluna Idade em ordem decrescente. Selecione todas as linhas onde a idade seja um número par. Crie um novo data frame contendo apenas os três primeiros registros do data frame original. 4. Use o data frame airquality para responder às questões abaixo: Selecione apenas a coluna Temp. Selecione as colunas Ozone e Wind. Selecione os dados do dia 15. Selecione as medições do mês de julho (Month == 7). Selecione apenas as linhas onde Wind é maior que 10 mph. Adicione uma nova coluna chamada Temp_Celsius convertendo a temperatura para graus Celsius ((Temp - 32) * 5/9). Reordene o dataset do menor para o maior valor de Ozone. Usando a função %in% selecione apenas os dados dos meses de maio e junho (5 e 6). 5. Usando a função subset e considerando os dados anteriores airquality, faça o que se pede: Selecione todas as medições onde Ozone está acima de 50 e Wind está abaixo de 10 mph. Filtre apenas os registros onde a temperatura (Temp) está acima de 85°F e retorne apenas as colunas Temp e Wind. Selecione as medições para os dias 1 a 10. Extraia todas as medições onde a velocidade do vento (Wind) está entre 5 e 15 mph. 6. Crie um data frame chamado df com três colunas: “Nome”: c(“Ana”, “Bruno”, “Bia”, “Daniela”, “Eduardo”) “Idade”: c(25, NA, 31, 29, NA) “Altura”: c(1.65, 1.80, 1.75, NA, 1.68) Identifique quais colunas contêm valores NA. Conte quantos NA existem em cada coluna do data frame. Remova todas as observações que possuem pelo menos um NA no data frame. "],["controle-de-fluxo-e-funções.html", "Capítulo 3 Controle de Fluxo e Funções 3.1 Controle de Fluxo 3.2 Família de funções apply 3.3 Funções 3.4 Exercícios do Capítulo 3 (Entregar na lista 1)", " Capítulo 3 Controle de Fluxo e Funções 3.1 Controle de Fluxo 3.1.1 Execução Condicional 1. if e if-else O comando if é usado para executar um comando se alguma condição for satisfeita. Estrutura do if: if (condicao) { # comandos que serao rodados # se condicao = TRUE } Exemplo: x &lt;- 5 if (x &gt; 0) { print(&quot;O número é positivo&quot;) } ## [1] &quot;O número é positivo&quot; Caso queiramos executar um bloco alternativo, usamos o if em conjunto com o else: Estrutura do if-else: if (condicao) { # comandos que serao rodados # se condicao = TRUE } else { # comandos que serao rodados # se condicao = FALSE } Exemplo: x &lt;- -3 if (x &gt; 0) { print(&quot;O número é positivo&quot;) } else { print(&quot;O número é negativo ou zero&quot;) } ## [1] &quot;O número é negativo ou zero&quot; 2. ifelse A função ifelse() é útil quando precisamos aplicar uma condição de forma vetorizada. Estrutura do ifelse: ifelse(vetor_de_condicoes, valor_se_TRUE, valor_se_FALSE) Exemplo: notas &lt;- c(7, 4, 9, 5) resultado &lt;- ifelse(notas &gt;= 6, &quot;Aprovado&quot;, &quot;Reprovado&quot;) print(resultado) ## [1] &quot;Aprovado&quot; &quot;Reprovado&quot; &quot;Aprovado&quot; &quot;Reprovado&quot; Exercícios 1. Crie uma estrutura if que verifique se um número é maior do que 100 e em caso afirmativo print a mensagem: “O número é maior que 100”. 2. Crie uma estrutura if que verifique se um número é múltiplo de 5 e em caso afirmativo print a mensagem: “O número é múltiplo de 5”. 3. Crie uma estrutura usando if em conjunto com else que print “Aprovado”, caso a nota seja maior ou igual a 7, e “Reprovado”, caso contrário. 4. Crie um vetor de números e use ifelse para verificar quais são pares e ímpares. 5. Crie um vetor de idades e use ifelse para classificar cada idade como “Menor de idade”, se menor que 18, ou “Maior de idade”, caso contrário. Respostas # 1. numero &lt;- 200 if (numero &gt; 100) { print(&quot;O número é maior que 100&quot;) } # 2. numero &lt;- 15 if (numero %% 5 == 0) { print(&quot;O número é múltiplo de 5&quot;) } # 3. nota &lt;- 5 if (nota &gt;= 7) { print(&quot;Aprovado!&quot;) } else { print(&quot;Reprovado!&quot;) } # 4. numeros &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) resultado &lt;- ifelse(numeros %% 2 == 0, &quot;Par&quot;, &quot;Ímpar&quot;) print(resultado) # 5. idades &lt;- c(10, 18, 15, 21, 30, 12) classificacao &lt;- ifelse(idades &gt;= 18, &quot;Maior de idade&quot;, &quot;Menor de idade&quot;) print(classificacao) Acesso Professor 3.1.2 Loopings Os loops são usados para repetir blocos de código até que uma condição seja atendida. 1. for Usado para iterar sobre vetores, listas ou sequências. Estrutura do for: for(i in conjunto_de_valores){ # comandos que serão repetidos } Exemplo: Imprimindo números de 1 a 5 for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Exemplo: Iterando sobre um vetor de letras for (i in 1:5) { print(letters[i]) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;e&quot; # letters -&gt; vetor de letras do alfabeto disponíveis no R Exemplo: Iterando em vetores v &lt;- 1:10 for (i in 1:length(v)) { v[i] &lt;- v[i]/10 } v ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Mas o R é vetorizado este é o tipo de loop não faz sentido, pois é muito mais rápido e fácil fazer: v &lt;- v/10. Exemplo: Iterando em listas # Criando uma lista de vetores com tamanhos diferentes lista &lt;- list(c(2, 4, 6), c(10, 20, 30, 40)) # Dividindo cada vetor da lista pelo seu máximo: for (i in seq_along(lista)) { lista[[i]] &lt;- lista[[i]] / max(lista[[i]]) } lista ## [[1]] ## [1] 0.3333333 0.6666667 1.0000000 ## ## [[2]] ## [1] 0.25 0.50 0.75 1.00 # seq_along(lista) faz o mesmo que 1:length(lista) # Não podemos simplesmente fazer lista / max(lista), # pois lista não é um vetor numérico, mas uma lista de vetores. Exemplo: Iterando em matrizes (diferença entre &amp; e &amp;&amp;) ## Comparando os Tempos de Execução: n_linhas &lt;- 2000 set.seed(12345) x &lt;- matrix(sample(c(T,F), size = n_linhas^2, replace = T), nrow = n_linhas) y &lt;- matrix(sample(c(T,F), size = n_linhas^2, replace = T), nrow = n_linhas) result1 &lt;- matrix(0, nrow = n_linhas, ncol = n_linhas) # Usando &amp; (avalia todos) system.time({ for (i in 1:nrow(x)) { for (j in 1:ncol(x)) { if(x[i,j] &amp; y[i,j] &amp; (i%%2==0) &amp; (j%%2==0)) { result1[i,j] &lt;- 1 } } } }) # Usando &amp;&amp; (só avalia o primeiro) system.time({ for (i in 1:nrow(x)) { for (j in 1:ncol(x)) { if(x[i,j] &amp;&amp; y[i,j] &amp;&amp; (i%%2==0) &amp;&amp; (j%%2==0)) { result1[i,j] &lt;- 1 } } } }) ## Comparando os Termos Avaliados: x &lt;- matrix(c(FALSE, TRUE, TRUE, TRUE), nrow = 2, byrow = T) y &lt;- matrix(c(FALSE, TRUE, FALSE, TRUE), nrow = 2, byrow = T) result1 &lt;- matrix(0, nrow = 2, ncol = 2) # Função que identifica as avaliações print_eval &lt;- function(val, label, i, j) { cat(sprintf(&quot;[%d,%d] Avaliando: %s → %s\\n&quot;, i, j, label, val)) # printa uma mensagem substituindo %d e %s # pelos valores i, j, label, val # %d usado para números e %s para strings (textos) return(val) } # Usando &amp; (avalia todos) for (i in 1:nrow(x)) { for (j in 1:ncol(x)) { if (print_eval(x[i,j], &quot;x&quot;, i, j) &amp; print_eval(y[i,j], &quot;y&quot;, i, j) &amp; print_eval(i %% 2 == 0, &quot;i par&quot;, i, j) &amp; print_eval(j %% 2 == 0, &quot;j par&quot;, i, j)) { result1[i,j] &lt;- 1 } } } # Usando &amp;&amp; (só avalia o primeiro) for (i in 1:nrow(x)) { for (j in 1:ncol(x)) { if (print_eval(x[i,j], &quot;x&quot;, i, j) &amp;&amp; print_eval(y[i,j], &quot;y&quot;, i, j) &amp;&amp; print_eval(i %% 2 == 0, &quot;i par&quot;, i, j) &amp;&amp; print_eval(j %% 2 == 0, &quot;j par&quot;, i, j)) { result1[i,j] &lt;- 1 } } } 2. while o recurso for é útil se você souber com antecedência o conjunto de valores sobre o qual deseja repetir uma ação. Caso não saiba, o loop while é mais flexível. Estrutura do while: while (condição) { # comandos a serem executados # enquanto a condição for verdadeira } Exemplo: x &lt;- 1 while (x &lt;= 3) { print(x) x &lt;- x + 1 } ## [1] 1 ## [1] 2 ## [1] 3 3. repeat Executa comandos indefinidamente até que um break seja encontrado. Estrutura do repeat: repeat { # código if (condição) break } Exemplo: Parando quando x for 3 x &lt;- 1 repeat { print(x) x &lt;- x + 1 if (x &gt; 3) break } ## [1] 1 ## [1] 2 ## [1] 3 📌 Diferença entre while e repeat: while: A condição é testada antes de executar o bloco de código. O código só executa se a condição for verdadeira. Se a condição inicial for falsa, o bloco não será executado nem uma vez. repeat: Não há condição inicial. O código é executado sempre até que um break seja chamado manualmente. É como um loop infinito que só para com break. Exercicios 1. Usando for: Imprima os números de 1 a 10. Imprima os números pares de 2 a 20. Calcule a soma dos números de 1 a 100. Imprima o quadrado de cada número de 1 a 10. Dado um valor numérico, calcule o seu fatorial. Dado um vetor de nomes, imprima todos os nomes em letras maiúsculas. Imprima todos os elementos de uma matriz 3x3. Imprima a soma de cada linha de uma matriz. 2. Usando while: Imprima os números de 1 a 10. Imprima os elementos do vetor vetor &lt;- c(\"a\", \"b\", \"c\", \"d\") um por um. Conte quantos números pares existem no vetor v &lt;- c(2, 5, 8, 11, 14, 19). Some os elementos do vetor z &lt;- c(10, 15, 20, 5, 8, 3) até que a soma passe de 50. 3. Usando repeat: Simular lançamentos de um dado até sair um número 6 (dica: use a função sample() para simular os lançamentos). Some os números do vetor numeros &lt;- c(30, 20, 25, 10, 15, 5) até atingir ou ultrapassar 100. Respostas ## 1. # a. for (i in 1:10) { print(i) } # b. for (i in seq(2, 20, by = 2)) { print(i) } # c. soma &lt;- 0 for (i in 1:100) { soma &lt;- soma + i } print(soma) # d. for (i in 1:10) { print(i^2) } # e. num &lt;- 5 fatorial &lt;- 1 for (i in 1:num) { fatorial &lt;- fatorial * i } print(fatorial) # f. nomes &lt;- c(&quot;ana&quot;, &quot;joao&quot;, &quot;maria&quot;, &quot;carlos&quot;) for (nome in nomes) { print(toupper(nome)) } # g. matriz &lt;- matrix(1:9, nrow = 3, byrow = TRUE) for (i in 1:nrow(matriz)) { for (j in 1:ncol(matriz)) { print(paste(&quot;Elemento [&quot;, i, &quot;,&quot;, j, &quot;] =&quot;, matriz[i, j])) } } # h. matriz &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, byrow = TRUE) for (i in 1:nrow(matriz)) { linha_soma &lt;- sum(matriz[i, ]) print(linha_soma) # print(paste(&quot;Soma da linha&quot;, i, &quot;=&quot;, linha_soma)) } ## 2. # a. i &lt;- 1 while (i &lt;= 10) { print(i) i &lt;- i + 1 } # b. vetor &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) i &lt;- 1 while (i &lt;= length(vetor)) { print(vetor[i]) i &lt;- i + 1 } # c. v &lt;- c(2, 5, 8, 11, 14, 19) i &lt;- 1 pares &lt;- 0 while (i &lt;= length(v)) { if (v[i] %% 2 == 0) { pares &lt;- pares + 1 } i &lt;- i + 1 } # d. z &lt;- c(10, 15, 20, 5, 8, 3) soma &lt;- 0 i &lt;- 1 while (soma &lt;= 50 &amp;&amp; i &lt;= length(z)) { soma &lt;- soma + z[i] i &lt;- i + 1 } ## 3. # a. repeat { dado &lt;- sample(1:6, 1) print(paste(&quot;Resultado:&quot;, dado)) if (dado == 6) break } # b. numeros &lt;- c(30, 20, 25, 10, 15, 5) soma &lt;- 0 i &lt;- 1 repeat { soma &lt;- soma + numeros[i] if (soma &gt;= 100 || i == length(numeros)) break i &lt;- i + 1 } Acesso Professor 3.1.3 Controle de Fluxo (break e next) O R oferece mecanismos para interromper ou pular iterações em loops. 1. break Interrompe a execução de um loop. Exemplo: Parar quando encontrar um número maior que 5. v &lt;- c(2, 3, 6, 1, 4) for (i in 1:length(v)) { if (v[i] &gt; 5) { print(&quot;Número maior que 5 encontrado! Parando o loop.&quot;) break } print(v[i]) } ## [1] 2 ## [1] 3 ## [1] &quot;Número maior que 5 encontrado! Parando o loop.&quot; 2. next Pula a iteração atual e continua para a próxima. for (i in 1:5) { if (i %% 2 == 0) next print(i) } ## [1] 1 ## [1] 3 ## [1] 5 # Os números pares foram ignorados. Exercicios 1. Usando break: Imprima números de 1 a 10, mas parar se encontrar um múltiplo de 7. Imprima os valores do vetor valores &lt;- c(5, 3, 2, -1, 7) até encontrar o número negativo. Some os elementos do vetor numeros &lt;- c(5, 10, 15, 20, 30) até a soma ultrapassar 50. 2. Usando next: Imprima somente os números pares de 1 a 10. Dado o vetor vetor &lt;- c(10, -5, 7, -2, 4), imprima somente os seus valores positivos. Dado o vetor dados &lt;- c(10, NA, 20, 15, NA, 5), pule os valores NA ao calcular a soma. Respostas ## 1. # a. for (i in 1:10) { if (i %% 7 == 0) { break } print(i) } # b. valores &lt;- c(5, 3, 2, -1, 7) i &lt;- 1 for(i in 1:length(valores)) { if (valores[i] &lt; 0) { print(&quot;Número negativo encontrado.&quot;) break } else { print(valores[i]) } } # c. numeros &lt;- c(5, 10, 15, 20, 30) soma &lt;- 0 for (n in numeros) { soma &lt;- soma + n if (soma &gt; 50) { break } } ## 2. # a. for (i in 1:10) { if (i %% 2 != 0) { next } print(i) } # b. vetor &lt;- c(10, -5, 7, -2, 4) for (i in 1:length(v)) { if (vetor[i] &lt; 0) { next } print(vetor[i]) } # c. dados &lt;- c(10, NA, 20, 15, NA, 5) soma &lt;- 0 for (i in dados) { if (is.na(i)) { next } soma &lt;- soma + i } # ou soma &lt;- 0 for (i in 1:length(dados)) { if (is.na(dados[i])) { next } soma &lt;- soma + dados[i] } Acesso Professor 3.2 Família de funções apply Essas funções servem para evitar loops explícitos (for, while) e tornar o código mais limpo e eficiente. São funções vetorizadas que operam em listas, matrizes, data.frames, etc. apply Aplica uma função a linhas ou colunas de uma matriz ou data.frame. ## Estrutura do apply: apply(matriz, MARGIN = 1, FUN = sum) # aplica por linha apply(matriz, MARGIN = 2, FUN = sum) # aplica por coluna Exemplo: Comparando for e apply em operações com matrizes # Soma das linhas de uma matriz usando `for`: mat &lt;- matrix(1:9, ncol = 3) soma_for &lt;- c() for (i in 1:nrow(mat)) { soma_for[i] &lt;- sum(mat[i,]) } cat(&quot;Resultado com for:&quot;, soma_for) ## Resultado com for: 12 15 18 # Soma das linhas de uma matriz usando `apply`: soma_apply &lt;- apply(mat, 1, sum) cat(&quot;Resultado com apply:&quot;, soma_apply) ## Resultado com apply: 12 15 18 lapply Aplica uma função a cada elemento de uma lista, retornando outra lista. ## Estrutura do lapply: lapply(lista, sum) sapply Igual ao lapply(), mas simplifica o resultado (tenta transformar em vetor/matriz). ## Estrutura do sapply: sapply(lista, sum) Exemplo: Comparando for com lapply e sapply em operações com listas. # Soma de cada vetor de uma lista usando `for`: lista &lt;- list(v1 = c(1,2,3), v2 = c(4,5)) soma_for_lista &lt;- list(v1 = c(), v2 = c()) for (i in 1:length(lista)) { soma_for_lista[[i]] &lt;- sum(lista[[i]]) } soma_for_lista # resultado em lista ## $v1 ## [1] 6 ## ## $v2 ## [1] 9 unlist(soma_for_lista) # resultado em vetor ## v1 v2 ## 6 9 # Soma de cada vetor de uma lista usando `lapply` e `sapply`: (soma_lapply &lt;- lapply(lista, sum)) # resultado em lista ## $v1 ## [1] 6 ## ## $v2 ## [1] 9 (soma_sapply &lt;- sapply(lista, sum)) # resultado em vetor ## v1 v2 ## 6 9 tapply Aplica uma função a valores por grupo. ## Estrutura do tapply: tapply(valores, grupos, soma) Exemplo: Comparando for com tapply para grupos. # Soma dos valores por grupo usando `for`: valores &lt;- c(10, 20, 30, 40, 50, 60) grupos &lt;- c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;) resultado &lt;- c() grupos_unicos &lt;- unique(grupos) for (i in 1:length(grupos_unicos)) { resultado[i] &lt;- sum(valores[grupos == grupos_unicos[i]]) } print(resultado) ## [1] 80 130 # Soma dos valores por grupo usando `tapply`: tapply(valores, grupos, sum) ## A B ## 80 130 Exercicios 1. Usando apply, lapply, sapply ou tapply: Calcule a soma de cada coluna de uma matriz. Calcule o valor máximo de cada linha de uma matriz. Ordene cada coluna de uma matriz. Calcule o comprimento de cada vetor numa lista. Converta uma lista de strings com letras minúsculas para maiúsculas. Calcule a média para cada vetor da lista valores &lt;- list(x = 1:5, y = 2:6, z = 3:7) e retorne em um vetor. Calcule a média de salários por setor, para os dados: salario &lt;- c(2000, 2500, 2200, 4000, 5000, 4500) setor &lt;- c(&quot;RH&quot;, &quot;RH&quot;, &quot;RH&quot;, &quot;TI&quot;, &quot;TI&quot;, &quot;TI&quot;) Respostas ## 1. # a. Calcule a soma de cada coluna de uma matriz. matriz &lt;- matrix(1:9, nrow = 3) apply(matriz, 2, sum) # b. Calcule o valor máximo de cada linha de uma matriz. apply(matriz, 1, max) # c. Ordene cada coluna de uma matriz. apply(matriz, 2, sort) # d. Calcule o comprimento de cada vetor numa lista. lista &lt;- list(a = 1:3, b = 5:10, c = 20:30) lapply(lista, length) # e. Converta uma lista de strings com letras minúsculas para maiúsculas. palavras &lt;- list(&quot;gato&quot;, &quot;cachorro&quot;, &quot;papagaio&quot;) lapply(palavras, toupper) # f. Calcule a média para cada vetor da lista e retorne em um vetor. valores &lt;- list(x = 1:5, y = 2:6, z = 3:7) sapply(valores, mean) # g. Calcule a média de salários por setor. salario &lt;- c(2000, 2500, 2200, 4000, 5000, 4500) setor &lt;- c(&quot;RH&quot;, &quot;RH&quot;, &quot;RH&quot;, &quot;TI&quot;, &quot;TI&quot;, &quot;TI&quot;) tapply(salario, setor, mean) Acesso Professor 3.3 Funções Funções em R são blocos de código reutilizáveis que executam tarefas específicas. Estrutura de função nome_da_funcao &lt;- function(argumentos_separados_por_virgula) { # corpo da função # instruções e retorno return(valor) } Exemplo: Função que calcula a soma de dois valores. minha_soma &lt;- function(a, b) { soma &lt;- a + b return(soma) # resultado retornado } Essa função tem os seguintes componentes: minha_soma: nome da função a e b: argumentos da função soma &lt;- a + b: operação que a função executa return(soma): valor retornado pela função Após rodarmos o código de criar a função, podemos chamá-la como outras funções do R: minha_soma(2,5) ## [1] 7 Se criar a função sem retorno, ela cria o objeto, mas não o retorna ao ser chamada: minha_nova_soma &lt;- function(a, b) { soma &lt;- a + b } minha_nova_soma(2,2) No entanto, a última linha da função é a atribuição soma &lt;- x + y e esse será o “resultado retornado”. Assim, podemos visualizar este resultado da função se o atribuirmos para outro objeto: resultado &lt;- minha_nova_soma(2,2) resultado ## [1] 4 Na prática, no entanto, é sempre bom criarmos funções que retornem os seus resultados. Exemplo: Função que calcula o quadrado de um número. ## Forma mais sucinta ## se o corpo da função for na mesma linha não é necessário colocar chaves quad &lt;- function(x) x^2 quad(3) ## [1] 9 Componentes de uma função: nome_da_funcao: Nome que você escolhe para a função. function(): Palavra-chave que define uma função. argumentos: Parâmetros de entrada. corpo da função: Código executado. return(): (opcional) Retorna o valor final da função. Funções com argumentos padrão Voltando ao exemplo da soma de dois números. Se fixarmos um valor para algum dos argumentos, apenas o valor do outro argumento seria necessário: minha_soma2 &lt;- function(a, b = 0) { soma &lt;- a + b return(soma) # resultado retornado } minha_soma2(2) ## [1] 2 No R, muitas funções já tem alguns argumentos pré-definidos (default), ficando a critério do usuário modificá-los ou não. Funções anônimas Usadas geralmente dentro de funções como apply, lapply, etc. lista &lt;- list(c(1,2),c(2,3,4)) lapply(lista, function(x) x^2) ## [[1]] ## [1] 1 4 ## ## [[2]] ## [1] 4 9 16 Funções que usam outras funções Podemos também usar funções dentro de funções. # Função que calcula a soma das colunas de uma matriz: calcula_soma_matriz &lt;- function(mat){ soma_linhas &lt;- apply(mat, 2, sum) return(soma_linhas) } matriz &lt;- matrix(1:9, ncol = 3) calcula_soma_matriz(matriz) ## [1] 6 15 24 Funções que retornam multiplos objetos Funções podem retornar múltiplos valores. Podemos utilizar list() ou data.frame() para agrupar os retornos. # Função que retorna os valores minimos e máximos de um vetor: min_max_vetor &lt;- function(v){ min_vec &lt;- min(v) max_vec &lt;- max(v) return(list(minimo_vec = min_vec, maximo_vec = max_vec)) } v &lt;- c(1,6,3,90,0,3,7,8) min_max_vetor(v) ## $minimo_vec ## [1] 0 ## ## $maximo_vec ## [1] 90 Exercícios 1. Crie uma função raiz_numeros() que receba 2 números e devolva a raiz quadrada da soma desses números. 2. Crie uma função max_numeros() que receba dois valores (numéricos) e devolva o maior deles. 3. Crie uma função soma_pares() que recebe um vetor numérico e retorna a soma apenas dos números pares. 4. Crie a função remover_na(vetor) que remove os NA de um vetor e retorna o vetor limpo. 5. Defina uma função resumo_vetor() que retorne o mínimo, a mediana e o máximo de um vetor. Faça com que a função lide com NA’s e que isso seja um argumento com default. 6. Rode help(sample) para descobrir o que a função sample() faz. Em seguida use-a para escrever uma função linha_aleatoria() que devolva uma linha aleatória de um dataframe; generalize a função para linha_aleatoria_n() que retorne um número n qualquer de linhas do dataframe, especificado pelo usuário. Como tratar possíveis erros do código anterior? Respostas ## 1. raiz_numeros &lt;- function(a, b){ raiz_ab &lt;- sqrt(a+b) return(raiz_ab) } ## 2. max_numeros &lt;- function(a, b){ maior_ab &lt;- max(a, b) return(maior_ab) } ## 3. soma_pares &lt;- function(v){ soma &lt;- sum(v[v%%2==0]) return(soma) } ## 4. remover_na &lt;- function(vetor){ vetor_limpo &lt;- vetor[!is.na(vetor)] return(vetor_limpo) } ## 5. resumo_vetor &lt;- function(v, na.rm = TRUE) { min_vec = min(v, na.rm = na.rm) mediana_vec = median(v, na.rm = na.rm) max_vec = max(v, na.rm = na.rm) return(list(minimo = min_vec, mediana = mediana_vec, maximo = max_vec)) } ## 6. dados &lt;- data.frame(nome = c(&quot;Ana&quot;, &quot;Beto&quot;, &quot;Carlos&quot;), idade = c(50,48,37), escolaridade = c(&quot;F&quot;, &quot;M&quot;, &quot;S&quot;)) # a. linha_aleatoria &lt;- function(dados){ linha &lt;- sample(1:nrow(dados), size = 1) return(dados[linha,]) } # b. linha_aleatoria_n &lt;- function(dados, n){ linha &lt;- sample(1:nrow(dados), size = n_min) return(dados[linha,]) } # c. linha_aleatoria_n &lt;- function(dados, n){ if(n &lt;= 0) return(cat(&quot;n deve ser maior do que 0 e menor do que nrow(dados)&quot;)) n_min &lt;- min(n, nrow(dados)) linha &lt;- sample(1:nrow(dados), size = n_min) return(dados[linha,]) } Acesso Professor 3.4 Exercícios do Capítulo 3 (Entregar na lista 1) 1. Considere o dataframe com as colunas a seguir. Crie uma função filtra_dados() com os argumentos dados, variável e filtro, de modo que o usuário consiga definir um conjunto de valores no filtro, para alguma variavel especificada. Trate a possível situação de erro no caso do usuário entrar com outros nomes que não estão no conjunto de dados. nome = c(&quot;Ana&quot;, &quot;Bruno&quot;, &quot;Carlos&quot;, &quot;Diana&quot;) idade = c(20, 21, 19, 22) nota = c(8.5, 6.4, 9.2, 4.8) 2. Criar função que receba nota e retorne: “Aprovado”, se &gt;= 7 “Recuperação”, se &gt;= 5 e &lt; 7 “Reprovado”, se &lt; 5 3. Crie uma função que receba a idade de uma pessoa e classifique-a como “Criança” (se 0-12 anos), “Adolescente” (se 13-17 anos), “Adulto” (se 18-59 anos) ou “Idoso” (se 60+ anos). 4. Crie uma função que retorne todos os elementos pares de cada vetor dentro de uma lista. 5. Crie uma função chamada calculadora_soma() que: Peça ao usuário que digite vários números separados por vírgula (ex: 10, 20, 30). Leia esses valores usando a função readline(). Converta os valores digitados para números. Some todos os valores e mostre o resultado na tela. Dica: Use a função strsplit() para separar os números de entrada pela vírgula e as.numeric() para transformar os textos em números. "],["importação-e-manipulação-de-dados.html", "Capítulo 4 Importação e Manipulação de dados 4.1 Importação e exportação de Dados 4.2 Manipulação de Dados 4.3 Exercícios do Capítulo 4 (Entregar na lista 1)", " Capítulo 4 Importação e Manipulação de dados 4.1 Importação e exportação de Dados Caminhos: Funções de importação/exportação exigem um caminho/endereço do local onde os dados/arquivos estão salvos; Podemos passar para estas funções o caminho absoluto (caminhos completos que conduzem ao arquivo de interesse); O caminho absoluto pode dificultar que outras pessoas reproduzam o mesmo código em outros computadores; Deste modo, uma boa prática é especificar o diretório de trabalho que o R vai considerar como referência. E nas funções de importação ou exportação, nomear apenas o caminho relativo (caminho reduzido, ou seja, apenas o nome da pasta ou arquivo de interesse); Diretório de trabalho: Local/pasta que o R usa de referência para buscar, importar, exportar e salvar arquivos. Para identificar o diretório de trabalho da sessão R usamos getwd(). Para definir outro diretório usar setwd(\"caminho_do_seu_diretorio\"). Aqui vamos utilizar o diretório de trabalho: setwd(&quot;/home/angelica/Dropbox/UTFPR/Ensino/Estatistica Computacional com o R/ Capitulo 3 - Importacao&quot;) 4.1.1 Usando funções básicas do R Importando dados de pacotes Para visualizar os dados de pacotes instalados no R: data(package = .packages(all.available = TRUE)) Para visualizar dados específicos de algum pacote: data(package = &quot;carData&quot;) Para importar algum conjunto de dados de um pacote: # Carregando o conjunto &quot;Adler&quot; do pacote &quot;carData&quot; data(&quot;Adler&quot;, package = &quot;carData&quot;) Trabalhando com os dados importados: # Acessando variáveis destes dados: Adler$instruction # Visualizando a estrutura dos dados: str(Adler) ## &#39;data.frame&#39;: 108 obs. of 3 variables: ## $ instruction: Factor w/ 3 levels &quot;good&quot;,&quot;none&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ expectation: Factor w/ 2 levels &quot;high&quot;,&quot;low&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ rating : int 25 0 -16 5 11 -6 42 -2 -13 14 ... # Visualizando as primeiras linhas dos dados: head(Adler) ## instruction expectation rating ## 1 good high 25 ## 2 good high 0 ## 3 good high -16 ## 4 good high 5 ## 5 good high 11 ## 6 good high -6 Exportando dados do R para algum diretório ## Exportando arquivos CSV write.csv(Adler, file = &quot;dados_adler.csv&quot;, sep = &quot;,&quot;, dec = &quot;.&quot;, row.names = FALSE) ## Exportando arquivos TXT write.table(Adler, file = &quot;dados_adler.txt&quot;, sep = &quot; &quot;, dec = &quot;.&quot;, row.names = FALSE) Importando dados de arquivos locais ## Arquivos CSV dados &lt;- read.csv(&quot;dados.csv&quot;, sep = &quot;,&quot;, dec = &quot;.&quot;, header = TRUE) ## Arquivos TSV dados &lt;- read.delim(&quot;dados.tsv&quot;, sep = &quot;\\t&quot;, dec = &quot;.&quot;, header = TRUE) ## Arquivos TXT dados &lt;- read.table(&quot;dados.txt&quot;, sep = &quot;&quot;, dec = &quot;.&quot;, header = TRUE) Argumentos: sep → Define o separador de colunas. dec → Define o separador decimal. header = TRUE → Indica se a primeira linha contém nomes das colunas. Comparação: read.csv() → Arquivos CSV padrão (separador “,” e decimal “.”). read.delim() → Arquivos .tsv (tabulação “). read.table() → Arquivos .txt. Função mais genérica. Importa arquivos gerais # Exemplo: # Dados Adler - extensão txt dados_adler_txt &lt;- read.table(&quot;dados_adler.txt&quot;, header = T) # Dados Adler - extensão csv dados_adler_csv &lt;- read.csv(&quot;dados_adler.csv&quot;, header = T) # Dados Adler - extensão tsv dados_adler_tsv &lt;- read.delim(&quot;dados_adler.tsv&quot;, header = T) Importando dados da Web Podemos usar as funções read.table e read.csv também para importar dados da web: ## Extensão txt dados_web_txt &lt;- read.table(&quot;https://angelicamariatortola.github.io/academic/ figs/dados_adler.txt&quot;, header = T) ## Extensão csv dados_web_csv &lt;- read.csv(&quot;https://angelicamariatortola.github.io/academic/ figs/dados_adler.csv&quot;, header = T) Exercícios 1. Considere o pacote datasets: Liste os conjuntos de dados disponíveis no pacote. Carregue o conjunto “mtcars” e exiba suas primeiras 6 linhas. Carregue o conjunto “iris” e verifique a sua estrutura. Print os nomes das variáveis dos dados “mtcars” e “iris”. Quantas linhas e colunas tem cada um destes conjuntos de dados? 2. Crie um arquivo chamado “dados.txt” com o seguinte conteúdo (salve no seu diretório de trabalho): Nome Idade Altura Ana 25 1.68 João 30 1.75 Carlos 22 1.80 Importe esse arquivo usando read.table(), definindo corretamente os argumentos. Verifique se o dataset foi carregado corretamente printando seus valores e verificando a sua estrutura. 3. Crie um arquivo chamado “dados.csv” com o seguinte conteúdo: Nome,Idade,Altura Ana,25,1.68 João,30,1.75 Carlos,22,1.80 Maria,35,1.60 Bia,24,1.65 Joana,26,1.72 Carregue esse arquivo no R usando read.csv(). Exiba as primeiras 4 linhas do dataset. Renomeie as colunas dos dados para “nome”, “idade” e “alt”. 4. Use o dataset “mtcars” e com a função write.table(), exporte apenas os primeiros 10 registros dos dados em um arquivo chamado “mtcars.txt”. Centifique-se de que a primeira linha contenha os nomes das colunas, que ele não atribua nomes para as linhas e que os valores sejam separados por “;”. Respostas # 1. # a. data(package = &quot;datasets&quot;) # b. data(mtcars) head(mtcars) # c. data(iris) str(iris) # d. names(mtcars) names(iris) # e. nrow(mtcars); ncol(mtcars) nrow(iris); ncol(iris) # 2. setwd(&quot;/home/angelica/Dropbox/UTFPR/Ensino/Estatistica Computacional com o R/ Capitulo 3 - Importacao&quot;) # a. dados_txt &lt;- read.table(&quot;dados.txt&quot;, sep = &quot; &quot;, header = T) # b. str(dados_txt) # 3. # a. dados_csv &lt;- read.csv(&quot;dados.csv&quot;, sep = &quot;,&quot;, header = T) str(dados_csv) # b. head(dados_csv, 4) # c. names(dados_csv) &lt;- c(&quot;nome&quot;, &quot;idade&quot;, &quot;alt&quot;) # 4. write.table(head(mtcars, 10), &quot;mtcars.txt&quot;, row.names = F, sep = &quot;;&quot;) Acesso Professor 4.1.2 Usando funções do pacote readr Esse pacote possibilita ler dados de forma mais eficiente. Transforma os dados em “tibbles” um tipo de estrutura de dados mais “amigável”. O readr transforma arquivos de textos em tibbles usando as funções: read_csv(): arquivos separados por vírgula. read_tsv(): arquivos separados por tabulação. read_delim(): arquivos separados por um delimitador genérico. O argumento delim= indica qual caractere separa cada coluna no arquivo de texto. read_table(): arquivos de texto tabular com colunas separadas por espaço. library(readr) dados_readr_delim &lt;- read_delim(&quot;dados_adler.txt&quot;, col_names = T, delim = &quot; &quot;) # delim = &quot;\\t&quot; para arquivo separação por tabulação dados_readr_csv &lt;- read_csv(&quot;dados_adler.csv&quot;, col_names = T) 4.1.3 Usando funções do pacote readxl Para ler planilhas do Excel (arquivos .xlsx ou .xls), basta utilizarmos a função read_excel() do pacote readxl Exemplo: Fazer o download dos dados disponíveis no link: https://github.com/curso-r/livro-material/raw/master/assets/data/imdb.zip # install.packages(&quot;readxl&quot;) library(readxl) imdb &lt;- read_excel(&quot;imdb/imdb.xlsx&quot;, sheet = 1) View(imdb) excel_sheets(&quot;imdb/imdb.xlsx&quot;) # planilhas dos dados imdb colnames(imdb) Exercícios Para os exercícios a seguir, baixe os arquivos de dados no link abaixo e salve-os em alguma pasta do seu computador. 📥 Baixar arquivos de dados (.zip) 1. Usando funções do pacote readr, importe os arquivos: alunos.csv. vendas.csv. dados.txt. tabela.tsv. 2. Usando funções do pacote readxl: Importe a planilha 1 do arquivo notas.xlsx. Importe a planilha 2025 do arquivo financeiro.xlsx. Importe o intervalo B2:D10 do arquivo relatorio.xlsx. Liste os nomes das planilhas do arquivo multiaba.xlsx. 3. Para cada conjunto de dados anterior, print o seu número de linhas, de colunas e os nomes das variáveis. Respostas # 1. library(readr) setwd(&quot;/home/angelica/Dropbox/UTFPR/Ensino/Estatistica Computacional com o R/ ApostilaR/data&quot;) df_alunos &lt;- read_csv(&quot;exercicios_importacao_r/alunos.csv&quot;) df_vendas &lt;- read_csv2(&quot;exercicios_importacao_r/vendas.csv&quot;) df_pipe &lt;- read_delim(&quot;exercicios_importacao_r/dados.txt&quot;, delim = &quot;|&quot;) df_tsv &lt;- read_tsv(&quot;exercicios_importacao_r/tabela.tsv&quot;) # 2. library(readxl) df_notas &lt;- read_excel(&quot;exercicios_importacao_r/notas.xlsx&quot;) df_financeiro &lt;- read_excel(&quot;exercicios_importacao_r/financeiro.xlsx&quot;, sheet = &quot;2025&quot;) df_relatorio &lt;- read_excel(&quot;exercicios_importacao_r/relatorio.xlsx&quot;, range = &quot;B2:D10&quot;) abas &lt;- excel_sheets(&quot;exercicios_importacao_r/multiaba.xlsx&quot;) Acesso Professor 4.2 Manipulação de Dados A manipulação de dados consiste na transformação de dados de uma base “crua” para uma base que se possa trabalhar e extrair informações. Alguns pacotes úteis no R para esta finalidade são os pacotes dplyr e tidyr. Eles utilizam como inputs dados no formato de tibbles. 4.2.1 Tibbles Tibbles são estruturas de dados mais “amigáveis”. # Para instalar e carregar # install.packages(&quot;tibble&quot;) library(tibble) Para criar um tibble com a função as_tibble: as_tibble(mtcars) ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # ℹ 22 more rows Ele mostra apenas as primeiras linhas e oculta as colunas que não cabem na largura da tela. Para criar um tibble com a função tibble(): tibble( coluna1 = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), coluna2 = 1:4, coluna3 = coluna2 ^ 2, coluna4 = 0 ) ## # A tibble: 4 × 4 ## coluna1 coluna2 coluna3 coluna4 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 1 1 0 ## 2 b 2 4 0 ## 3 c 3 9 0 ## 4 d 4 16 0 Podemos observar que: Uma coluna pode ser criada a partir de outras; Valores únicos são reciclados para todas as linhas dos dados. o pacote tibble possui também algumas funções úteis: add_row(): para adicionar linhas a uma tibble; add_column(): para adicionar colunas a uma tibble; Exemplo: mtcars_tibble &lt;- as_tibble(mtcars[1:5,c(&quot;mpg&quot;, &quot;cyl&quot;)]) add_row(mtcars_tibble, mpg = 2, cyl = 3) ## # A tibble: 6 × 2 ## mpg cyl ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 ## 2 21 6 ## 3 22.8 4 ## 4 21.4 6 ## 5 18.7 8 ## 6 2 3 add_column(mtcars_tibble, mpg2 = mtcars_tibble$mpg^2) ## # A tibble: 5 × 3 ## mpg cyl mpg2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 441 ## 2 21 6 441 ## 3 22.8 4 520. ## 4 21.4 6 458. ## 5 18.7 8 350. 4.2.2 O Operador Pipe (%&gt;%) É uma ferramenta útil para deixar o código mais legível, encadeado e natural, especialmente quando você está aplicando várias funções uma após a outra. A ideia do operador pipe é bem simples: usar o valor resultante da expressão do lado esquerdo como primeiro argumento da função do lado direito. Exemplo: Vamos calcular a raiz quadrada da soma dos valores de 1 a 4. library(magrittr) x &lt;- c(1, 2, 3, 4) # Sem o Pipe: sqrt(sum(x)) ## [1] 3.162278 # Com o Pipe: x %&gt;% sum() %&gt;% sqrt() ## [1] 3.162278 Exemplo: Vamos transpor uma matriz (t()) e calcular a soma de suas colunas (colSums()). mat &lt;- matrix(1:9, nrow = 3, byrow = TRUE) # Sem o Pipe: colSums(t(mat)) ## [1] 6 15 24 # Com o Pipe: mat %&gt;% t() %&gt;% colSums() ## [1] 6 15 24 Exercícios Faça o que se pede com e sem o operador Pipe (%&gt;%): Crie um vetor de 5 números, multiplique cada elemento por 3 e calcule a sua média. Crie um vetor de 10 números, tire o seu valor absoluto e arredonde-o para 1 casa decimal. Crie uma matriz 4x2 com números de 1 a 8, aplique a soma às linhas da matriz e eleve esses valores ao quadrado. Crie uma matriz 2x4 com os números de 1 a 8, multiplique por 2 e calcule a média de cada coluna. Respostas # a. c(2, 4, 6, 8, 10) %&gt;% `*`(3) %&gt;% mean() # b. rnorm(10) %&gt;% abs() %&gt;% round(1) # c. mat2 &lt;- matrix(1:8, nrow = 4) mat2 %&gt;% apply(1, sum) %&gt;% `^`(2) # d. matrix(1:8, nrow = 2) %&gt;% `*`(2) %&gt;% colMeans() Acesso Professor 4.2.3 O pacote dplyr Permite a manipulação de dados de forma clara e eficiente. Algumas de suas principais funções, são: select(): seleciona colunas arrange(): ordena a base filter(): filtra linhas mutate(): cria ou modifica colunas summarise(): resume variáveis group_by(): agrupa os dados count(): conta observações Estas funções tem as seguintes características: O input e output são estruturas tibble. O tibble é colocado no primeiro argumento e o que queremos fazer nos outros argumentos. O operador Pipe pode ser usado para facilitar as manipulações. Vantagens de se usar o dplyr: A manipulação de dados fica mais simples. O código fica mais intuitivo. É possível trabalhar com diferentes fontes de dados. Primeiramente instalar e carregar o pacote: # install.packages(&quot;dplyr&quot;) # library(dplyr) Exemplos: Para ilustrar o pacote dplyr, vamos usar os dados do imdb, disponíveis no link: https://github.com/curso-r/livro-material/raw/master/assets/data/imdb.zip # library(readr) data_imdb &lt;- read_csv(&quot;data/imdb/imdb.csv&quot;, show_col_types = FALSE) head(data_imdb) ## # A tibble: 6 × 20 ## id_filme titulo ano data_lancamento generos duracao pais idioma orcamento ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt0092699 Broadc… 1987 1988-04-01 Comedy… 133 USA Engli… 20000000 ## 2 tt0037931 Murder… 1945 1945-06-23 Comedy… 91 USA Engli… NA ## 3 tt0183505 Me, My… 2000 2000-09-08 Comedy 116 USA Engli… 51000000 ## 4 tt0033945 Never … 1941 1947-05-02 Comedy… 71 USA Engli… NA ## 5 tt0372122 Adam &amp;… 2005 2007-05-17 Comedy… 99 USA Engli… NA ## 6 tt3703836 Henry … 2015 2016-01-08 Drama 87 USA Engli… NA ## # ℹ 11 more variables: receita &lt;dbl&gt;, receita_eua &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # num_avaliacoes &lt;dbl&gt;, direcao &lt;chr&gt;, roteiro &lt;chr&gt;, producao &lt;chr&gt;, ## # elenco &lt;chr&gt;, descricao &lt;chr&gt;, num_criticas_publico &lt;dbl&gt;, ## # num_criticas_critica &lt;dbl&gt; Função select (seleciona colunas) ## Selecionando a coluna título: # Sem o operador Pipe: select(data_imdb, titulo) ## # A tibble: 11,340 × 1 ## titulo ## &lt;chr&gt; ## 1 Broadcast News ## 2 Murder, He Says ## 3 Me, Myself &amp; Irene ## 4 Never Give a Sucker an Even Break ## 5 Adam &amp; Steve ## 6 Henry Gamble&#39;s Birthday Party ## 7 No Way Out ## 8 Welcome Home, Roscoe Jenkins ## 9 Some Kind of Wonderful ## 10 The Family That Preys ## # ℹ 11,330 more rows # Com o operador Pipe: data_imdb %&gt;% select(titulo) ## Selecionando as colunas título, ano e orcamento: # Sem o operador Pipe: select(data_imdb, titulo, ano, orcamento) ## # A tibble: 11,340 × 3 ## titulo ano orcamento ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Broadcast News 1987 20000000 ## 2 Murder, He Says 1945 NA ## 3 Me, Myself &amp; Irene 2000 51000000 ## 4 Never Give a Sucker an Even Break 1941 NA ## 5 Adam &amp; Steve 2005 NA ## 6 Henry Gamble&#39;s Birthday Party 2015 NA ## 7 No Way Out 1987 15000000 ## 8 Welcome Home, Roscoe Jenkins 2008 35000000 ## 9 Some Kind of Wonderful 1987 NA ## 10 The Family That Preys 2008 NA ## # ℹ 11,330 more rows # Com o operador Pipe: data_imdb %&gt;% select(titulo, ano, orcamento) Selecionando uma sequencia de colunas dos dados select(data_imdb, titulo:generos) ## # A tibble: 11,340 × 4 ## titulo ano data_lancamento generos ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Broadcast News 1987 1988-04-01 Comedy, Drama, Roman… ## 2 Murder, He Says 1945 1945-06-23 Comedy, Crime, Myste… ## 3 Me, Myself &amp; Irene 2000 2000-09-08 Comedy ## 4 Never Give a Sucker an Even Break 1941 1947-05-02 Comedy, Musical ## 5 Adam &amp; Steve 2005 2007-05-17 Comedy, Drama, Music ## 6 Henry Gamble&#39;s Birthday Party 2015 2016-01-08 Drama ## 7 No Way Out 1987 1987-12-11 Action, Crime, Drama ## 8 Welcome Home, Roscoe Jenkins 2008 2008-02-08 Comedy, Romance ## 9 Some Kind of Wonderful 1987 1988-01-13 Drama, Romance ## 10 The Family That Preys 2008 2008-09-12 Drama ## # ℹ 11,330 more rows # ou # select(data_imdb, 2:5) Funções úteis que podem ser usadas com a função select(): starts_with(): colunas que começam com um texto especificado ends_with(): colunas que terminam com um texto especificado contains(): colunas que contêm um texto especificado Exemplos: ## Selecionando colunas que começam com o texto &quot;num&quot;. select(data_imdb, starts_with(&quot;num&quot;)) ## # A tibble: 11,340 × 3 ## num_avaliacoes num_criticas_publico num_criticas_critica ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 26257 142 62 ## 2 1639 35 10 ## 3 219069 502 161 ## 4 2108 35 18 ## 5 2953 48 15 ## 6 2364 26 14 ## 7 34513 125 72 ## 8 13315 45 74 ## 9 27065 145 55 ## 10 6703 52 29 ## # ℹ 11,330 more rows ## Selecionando colunas que terminam com o texto &quot;cao&quot;. select(data_imdb, ends_with(&quot;cao&quot;)) ## # A tibble: 11,340 × 4 ## duracao direcao producao descricao ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 133 James L. Brooks Amercent Films Take two… ## 2 91 George Marshall Paramount Pictures A pollst… ## 3 116 Bobby Farrelly, Peter Farrelly Twentieth Century Fox A nice-g… ## 4 71 Edward F. Cline Universal Pictures A filmma… ## 5 99 Craig Chester Funny Boy Films Follows … ## 6 87 Stephen Cone Chicago Media Project Preacher… ## 7 114 Roger Donaldson Orion Pictures A coveru… ## 8 104 Malcolm D. Lee Universal Pictures Dr. RJ S… ## 9 95 Howard Deutch Hughes Entertainment When Kei… ## 10 111 Tyler Perry Louisiana Producers Film So… Two fami… ## # ℹ 11,330 more rows ## Selecionando colunas que contém &quot;_&quot;. select(data_imdb, contains(&quot;_&quot;)) ## # A tibble: 11,340 × 7 ## id_filme data_lancamento receita_eua nota_imdb num_avaliacoes ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 tt0092699 1988-04-01 51249404 7.2 26257 ## 2 tt0037931 1945-06-23 NA 7.1 1639 ## 3 tt0183505 2000-09-08 90570999 6.6 219069 ## 4 tt0033945 1947-05-02 NA 7.2 2108 ## 5 tt0372122 2007-05-17 309404 5.9 2953 ## 6 tt3703836 2016-01-08 NA 6.1 2364 ## 7 tt0093640 1987-12-11 35509515 7.1 34513 ## 8 tt0494652 2008-02-08 42436517 5.5 13315 ## 9 tt0094006 1988-01-13 18553948 7.1 27065 ## 10 tt1142798 2008-09-12 37105289 5.7 6703 ## # ℹ 11,330 more rows ## # ℹ 2 more variables: num_criticas_publico &lt;dbl&gt;, num_criticas_critica &lt;dbl&gt; Para remover colunas, adicionar “-” antes dos nomes: select(data_imdb, -c(ano, direcao)) ## # A tibble: 11,340 × 18 ## id_filme titulo data_lancamento generos duracao pais idioma orcamento ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt0092699 Broadcast N… 1988-04-01 Comedy… 133 USA Engli… 20000000 ## 2 tt0037931 Murder, He … 1945-06-23 Comedy… 91 USA Engli… NA ## 3 tt0183505 Me, Myself … 2000-09-08 Comedy 116 USA Engli… 51000000 ## 4 tt0033945 Never Give … 1947-05-02 Comedy… 71 USA Engli… NA ## 5 tt0372122 Adam &amp; Steve 2007-05-17 Comedy… 99 USA Engli… NA ## 6 tt3703836 Henry Gambl… 2016-01-08 Drama 87 USA Engli… NA ## 7 tt0093640 No Way Out 1987-12-11 Action… 114 USA Engli… 15000000 ## 8 tt0494652 Welcome Hom… 2008-02-08 Comedy… 104 USA Engli… 35000000 ## 9 tt0094006 Some Kind o… 1988-01-13 Drama,… 95 USA Engli… NA ## 10 tt1142798 The Family … 2008-09-12 Drama 111 USA Engli… NA ## # ℹ 11,330 more rows ## # ℹ 10 more variables: receita &lt;dbl&gt;, receita_eua &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # num_avaliacoes &lt;dbl&gt;, roteiro &lt;chr&gt;, producao &lt;chr&gt;, elenco &lt;chr&gt;, ## # descricao &lt;chr&gt;, num_criticas_publico &lt;dbl&gt;, num_criticas_critica &lt;dbl&gt; Função arrange (ordena a base) ## Ordenando os dados (crescente) pelo orcamento arrange(data_imdb, orcamento) ## # A tibble: 11,340 × 20 ## id_filme titulo ano data_lancamento generos duracao pais idioma orcamento ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt5345298 Patie… 2016 2016-10-11 Horror 116 USA Icela… 0 ## 2 tt7692822 Driven 2019 2019-02-09 Comedy… 90 USA Engli… 0 ## 3 tt3748918 To Yo… 2019 2020-03-17 Animat… 91 USA Engli… 1 ## 4 tt8196068 Twist… 2018 2018-10-03 Drama,… 89 USA Engli… 3 ## 5 tt0772152 Amate… 2006 2006-07-30 Crime,… 71 USA Engli… 45 ## 6 tt1260680 Pathf… 2011 2011-01-11 Action… 100 USA Engli… 50 ## 7 tt1701224 My Na… 2012 2012-10-19 Crime,… 90 USA Frenc… 300 ## 8 tt0054880 Flami… 1963 1963-04-29 Comedy… 45 USA Engli… 300 ## 9 tt1980185 Memor… 2012 2014-03-10 Crime,… 70 USA Engli… 300 ## 10 tt5009236 King … 2015 2015-03-27 Biogra… 46 USA Engli… 500 ## # ℹ 11,330 more rows ## # ℹ 11 more variables: receita &lt;dbl&gt;, receita_eua &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # num_avaliacoes &lt;dbl&gt;, direcao &lt;chr&gt;, roteiro &lt;chr&gt;, producao &lt;chr&gt;, ## # elenco &lt;chr&gt;, descricao &lt;chr&gt;, num_criticas_publico &lt;dbl&gt;, ## # num_criticas_critica &lt;dbl&gt; # Ordenando os dados (decrescente) pelo orcamento arrange(data_imdb, desc(orcamento)) ## # A tibble: 11,340 × 20 ## id_filme titulo ano data_lancamento generos duracao pais idioma orcamento ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt4154796 Aveng… 2019 2019-04-24 Action… 181 USA Engli… 356000000 ## 2 tt4154756 Aveng… 2018 2018-04-25 Action… 149 USA Engli… 321000000 ## 3 tt2527336 Star … 2017 2017-12-13 Action… 152 USA Engli… 317000000 ## 4 tt0449088 Pirat… 2007 2007-05-23 Action… 169 USA Engli… 300000000 ## 5 tt2527338 Star … 2019 2019-12-18 Action… 141 USA Engli… 275000000 ## 6 tt3778644 Solo:… 2018 2018-05-23 Action… 135 USA Engli… 275000000 ## 7 tt0348150 Super… 2006 2006-09-01 Action… 154 USA Engli… 270000000 ## 8 tt0398286 Tangl… 2010 2010-11-26 Animat… 100 USA Engli… 260000000 ## 9 tt0413300 Spide… 2007 2007-05-01 Action… 139 USA Engli… 258000000 ## 10 tt2975590 Batma… 2016 2016-03-23 Action… 152 USA Engli… 250000000 ## # ℹ 11,330 more rows ## # ℹ 11 more variables: receita &lt;dbl&gt;, receita_eua &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # num_avaliacoes &lt;dbl&gt;, direcao &lt;chr&gt;, roteiro &lt;chr&gt;, producao &lt;chr&gt;, ## # elenco &lt;chr&gt;, descricao &lt;chr&gt;, num_criticas_publico &lt;dbl&gt;, ## # num_criticas_critica &lt;dbl&gt; # Ordenando em relação a duas ou mais colunas. arrange(data_imdb, desc(ano), desc(orcamento)) ## # A tibble: 11,340 × 20 ## id_filme titulo ano data_lancamento generos duracao pais idioma orcamento ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt6587640 Troll… 2020 2020-04-10 Animat… 90 USA Engli… 90000000 ## 2 tt7713068 Birds… 2020 2020-02-06 Action… 109 USA Engli… 84500000 ## 3 tt5774060 Under… 2020 2020-01-30 Action… 95 USA Engli… 80000000 ## 4 tt6820324 Timmy… 2020 2020-03-24 Advent… 99 USA Engli… 45000000 ## 5 tt1634106 Blood… 2020 2020-03-27 Action… 109 USA Engli… 45000000 ## 6 tt100595… Unhin… 2020 2020-09-24 Action… 90 USA Engli… 33000000 ## 7 tt8461224 The T… 2020 2020-08-07 Action… 95 USA Engli… 30000000 ## 8 tt103089… Force… 2020 2020-06-30 Action… 91 USA Engli… 23000000 ## 9 tt4411584 The S… 2020 2020-07-31 Drama,… 107 USA Engli… 21000000 ## 10 tt8244784 The H… 2020 2020-03-24 Action… 90 USA Engli… 14000000 ## # ℹ 11,330 more rows ## # ℹ 11 more variables: receita &lt;dbl&gt;, receita_eua &lt;dbl&gt;, nota_imdb &lt;dbl&gt;, ## # num_avaliacoes &lt;dbl&gt;, direcao &lt;chr&gt;, roteiro &lt;chr&gt;, producao &lt;chr&gt;, ## # elenco &lt;chr&gt;, descricao &lt;chr&gt;, num_criticas_publico &lt;dbl&gt;, ## # num_criticas_critica &lt;dbl&gt; Exercícios 1. Considerando o conjunto de dados mtcars do pacote datasets, faça o que se pede usando o operador Pipe (%&gt;%) e as funções do pacote dplyr: Selecione todas as colunas que começam com a letra “d”. Selecione todas as colunas que terminam com a letra “t”. Selecione todas as colunas que contêm a letra “a” no nome. Remova todas as colunas que começam com “c”. Remova todas as colunas que contêm “ar”. Organize os dados em ordem crescente de mpg (milhas por galão). Organize os dados em ordem decrescente de hp (horsepower). Organize os dados em ordem crescente por cyl (cilindros) e por mpg (milhas por galão). 2. Considerando o conjunto de dados iris do pacote datasets, faça o que se pede usando o operador Pipe (%&gt;%) e as funções do pacote dplyr: Selecione apenas as colunas que contêm “Length”. Selecione todas as colunas exceto as que terminam com “Width”. Organize os dados por Sepal.Length em ordem decrescente. Organize os dados por Species e, dentro de cada espécie, por Petal.Width. Respostas # 1. mtcars %&gt;% select(starts_with(&quot;d&quot;)) mtcars %&gt;% select(ends_with(&quot;t&quot;)) mtcars %&gt;% select(contains(&quot;a&quot;)) mtcars %&gt;% select(-starts_with(&quot;c&quot;)) mtcars %&gt;% select(-contains(&quot;ar&quot;)) mtcars %&gt;% arrange(mpg) mtcars %&gt;% arrange(desc(hp)) mtcars %&gt;% arrange(cyl, mpg) # 2. iris %&gt;% select(contains(&quot;Length&quot;)) iris %&gt;% select(-ends_with(&quot;Width&quot;)) iris %&gt;% arrange(desc(Sepal.Length)) iris %&gt;% arrange(Species, Petal.Width) Acesso Professor Função filter (filtra linhas) Filtrando linhas para uma coluna: # Notas maiores do que 9: data_imdb %&gt;% filter(nota_imdb &gt; 9) ## # A tibble: 5 × 8 ## id_filme titulo ano data_lancamento generos duracao pais nota_imdb ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt10218912 As I Am 2019 2019-12-06 Drama,… 62 USA 9.3 ## 2 tt6735740 Love in Kiln… 2019 2019-06-23 Comedy 100 USA 9.3 ## 3 tt0111161 The Shawshan… 1994 1995-02-10 Drama 142 USA 9.3 ## 4 tt0068646 The Godfather 1972 1972-09-21 Crime,… 175 USA 9.2 ## 5 tt5980638 The Transcen… 2018 2020-06-19 Music,… 96 USA 9.2 Usando o filtro para mais de uma coluna: # Ano maior do que 2010 e nota maior do que 8.5 data_imdb %&gt;% filter(ano &gt; 2010, nota_imdb &gt; 8.5) # cada coluna é separada por vírgula ## # A tibble: 8 × 8 ## id_filme titulo ano data_lancamento generos duracao pais nota_imdb ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt10218912 As I Am 2019 2019-12-06 Drama,… 62 USA 9.3 ## 2 tt8503618 Hamilton 2020 2020-07-03 Biogra… 160 USA 8.7 ## 3 tt6735740 Love in Kiln… 2019 2019-06-23 Comedy 100 USA 9.3 ## 4 tt10765852 Metallica &amp; … 2019 2019-10-18 Music 150 USA 8.8 ## 5 tt6019206 Kill Bill: T… 2011 2011-03-27 Action… 247 USA 8.8 ## 6 tt8241876 5th Borough 2020 2020-06-03 Crime 95 USA 8.6 ## 7 tt2170667 Wheels 2014 2017-02-01 Drama 115 USA 8.8 ## 8 tt5980638 The Transcen… 2018 2020-06-19 Music,… 96 USA 9.2 Combinando as funções select() e filter() # Notas maiores do que 9 e selecionando as colunas titulo e nota_imdb data_imdb %&gt;% filter(nota_imdb &gt; 9) %&gt;% select(titulo, nota_imdb) ## # A tibble: 5 × 2 ## titulo nota_imdb ## &lt;chr&gt; &lt;dbl&gt; ## 1 As I Am 9.3 ## 2 Love in Kilnerry 9.3 ## 3 The Shawshank Redemption 9.3 ## 4 The Godfather 9.2 ## 5 The Transcendents 9.2 Combinando a função filter() com o operador %in%: # Filtrando os filmes de direção de Tarantino e Spielberg # e que tenham nota maior do que 8 data_imdb %&gt;% filter(direcao %in% c(&quot;Quentin Tarantino&quot;, &quot;Steven Spielberg&quot;), nota_imdb &gt; 8) ## # A tibble: 9 × 7 ## id_filme titulo ano data_lancamento generos direcao nota_imdb ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt0110912 Pulp Fiction 1994 1994-10-28 Crime,… Quenti… 8.9 ## 2 tt0082971 Raiders of the Lost… 1981 1981-06-12 Action… Steven… 8.4 ## 3 tt0097576 Indiana Jones and t… 1989 1989-10-06 Action… Steven… 8.2 ## 4 tt0120815 Saving Private Ryan 1998 1998-10-30 Drama,… Steven… 8.6 ## 5 tt6019206 Kill Bill: The Whol… 2011 2011-03-27 Action… Quenti… 8.8 ## 6 tt0108052 Schindler&#39;s List 1993 1994-03-11 Biogra… Steven… 8.9 ## 7 tt0105236 Reservoir Dogs 1992 1992-10-09 Crime,… Quenti… 8.3 ## 8 tt1853728 Django Unchained 2012 2013-01-17 Drama,… Quenti… 8.4 ## 9 tt0107290 Jurassic Park 1993 1993-09-17 Action… Steven… 8.1 Para filtrar strings contidas nos valores de alguma variável carater, podemos usar a função str_detect() do pacote stringr. Esta função serve para verificar se cada string de um vetor de caracteres contém um determinado padrão de texto. library(stringr) # Para visualizar a estrutura da variável &quot;generos&quot;: str(data_imdb$generos) ## chr [1:11340] &quot;Comedy, Drama, Romance&quot; &quot;Comedy, Crime, Mystery&quot; &quot;Comedy&quot; ... # Filtrando os filmes que contém genero &quot;Drama&quot;: head( data_imdb %&gt;% filter(str_detect(string = generos, pattern = &quot;Drama&quot;)) %&gt;% select(titulo, generos)) ## # A tibble: 6 × 2 ## titulo generos ## &lt;chr&gt; &lt;chr&gt; ## 1 Broadcast News Comedy, Drama, Romance ## 2 Adam &amp; Steve Comedy, Drama, Music ## 3 Henry Gamble&#39;s Birthday Party Drama ## 4 No Way Out Action, Crime, Drama ## 5 Some Kind of Wonderful Drama, Romance ## 6 The Family That Preys Drama # Se não usássemos a função str_detect, ele retornaria apenas as linhas # que contém exatamente a palavra &quot;Drama&quot;: head( data_imdb %&gt;% filter(generos == &quot;Drama&quot;) %&gt;% select(titulo, generos)) ## # A tibble: 6 × 2 ## titulo generos ## &lt;chr&gt; &lt;chr&gt; ## 1 Henry Gamble&#39;s Birthday Party Drama ## 2 The Family That Preys Drama ## 3 Curse of the Starving Class Drama ## 4 The Effect of Gamma Rays on Man-in-the-Moon Marigolds Drama ## 5 Storm Center Drama ## 6 The Ticket Drama Função mutate Usado para modificar uma coluna existente ou criar uma nova coluna. # Transformando a variável duracao de minutos para horas: data_imdb %&gt;% mutate(duracao = duracao/60) # Ou criando uma nova variável: data_imdb %&gt;% mutate(duracao_horas = duracao/60) ## # A tibble: 11,340 × 6 ## id_filme titulo ano data_lancamento generos duracao ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 tt0092699 Broadcast News 1987 1988-04-01 Comedy… 2.22 ## 2 tt0037931 Murder, He Says 1945 1945-06-23 Comedy… 1.52 ## 3 tt0183505 Me, Myself &amp; Irene 2000 2000-09-08 Comedy 1.93 ## 4 tt0033945 Never Give a Sucker an Even … 1941 1947-05-02 Comedy… 1.18 ## 5 tt0372122 Adam &amp; Steve 2005 2007-05-17 Comedy… 1.65 ## 6 tt3703836 Henry Gamble&#39;s Birthday Party 2015 2016-01-08 Drama 1.45 ## 7 tt0093640 No Way Out 1987 1987-12-11 Action… 1.9 ## 8 tt0494652 Welcome Home, Roscoe Jenkins 2008 2008-02-08 Comedy… 1.73 ## 9 tt0094006 Some Kind of Wonderful 1987 1988-01-13 Drama,… 1.58 ## 10 tt1142798 The Family That Preys 2008 2008-09-12 Drama 1.85 ## # ℹ 11,330 more rows ## # A tibble: 11,340 × 7 ## id_filme titulo ano data_lancamento generos duracao duracao_horas ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 tt0092699 Broadcast News 1987 1988-04-01 Comedy… 133 2.22 ## 2 tt0037931 Murder, He Says 1945 1945-06-23 Comedy… 91 1.52 ## 3 tt0183505 Me, Myself &amp; I… 2000 2000-09-08 Comedy 116 1.93 ## 4 tt0033945 Never Give a S… 1941 1947-05-02 Comedy… 71 1.18 ## 5 tt0372122 Adam &amp; Steve 2005 2007-05-17 Comedy… 99 1.65 ## 6 tt3703836 Henry Gamble&#39;s… 2015 2016-01-08 Drama 87 1.45 ## 7 tt0093640 No Way Out 1987 1987-12-11 Action… 114 1.9 ## 8 tt0494652 Welcome Home, … 2008 2008-02-08 Comedy… 104 1.73 ## 9 tt0094006 Some Kind of W… 1987 1988-01-13 Drama,… 95 1.58 ## 10 tt1142798 The Family Tha… 2008 2008-09-12 Drama 111 1.85 ## # ℹ 11,330 more rows Aplicando mutate() com mais colunas: # Criando a variável lucro e modificando pais de USA para Estados Unidos data_imdb_lucro_pais &lt;- data_imdb %&gt;% mutate(lucro = receita - orcamento, pais = &quot;Estados Unidos&quot;) head(data_imdb %&gt;% select(pais)) ## # A tibble: 6 × 1 ## pais ## &lt;chr&gt; ## 1 USA ## 2 USA ## 3 USA ## 4 USA ## 5 USA ## 6 USA head(data_imdb_lucro_pais %&gt;% select(lucro, pais)) ## # A tibble: 6 × 2 ## lucro pais ## &lt;dbl&gt; &lt;chr&gt; ## 1 47331309 Estados Unidos ## 2 NA Estados Unidos ## 3 98270999 Estados Unidos ## 4 NA Estados Unidos ## 5 NA Estados Unidos ## 6 NA Estados Unidos Exercícios Nos exercicios a seguir, utilize o operador Pipe (%&gt;%) e as funções do pacote dplyr. 1. Considerando o conjunto de dados mtcars do pacote datasets: Filtre os carros com mpg (milhas por galão) maior que 25. Filtre os carros com hp maior que 150 e mostre apenas mpg, hp e wt. Filtre os carros com cyl igual a 4 ou 8 (use %in%). Crie uma nova coluna peso_relativo em mtcars que seja wt / max(wt) (peso relativo). 2. Considerando o conjunto de dados iris do pacote datasets: Filtre apenas as observações da espécie que contém “set” no nome. Filtre a espécie que contém “ver” e mostre apenas colunas com “Length”. 3. Utilize a base imdb nos exercícios a seguir. Ordene os filmes em ordem crescente de ano e decrescente de receita e salve em um objeto chamado filmes_ordenados. Selecione apenas as colunas titulo e orcamento e então ordene de forma decrescente pelo orcamento. Crie uma coluna chamada prejuizo (orcamento - receita) e salve a nova tabela em um objeto chamado imdb_prejuizo. Em seguida, filtre apenas os filmes que deram prejuízo e ordene a tabela por ordem crescente de prejuízo. Fazendo apenas uma chamada da função mutate(), crie as seguintes colunas novas na base imdb: lucro = receita - orcamento lucro_medio lucro_relativo = (lucro - lucro_medio)/lucro_medio houve_lucro = “sim”, se lucro &gt; 0 e “não” caso contrário Crie uma nova coluna que classifique o filme em “recente” (posterior a 2000) e “antigo” (de 2000 para trás). Respostas # 1. # a. mtcars %&gt;% filter(mpg &gt; 25) # b. mtcars %&gt;% filter(hp &gt; 150) %&gt;% select(mpg, hp, wt) # c. mtcars %&gt;% filter(cyl %in% c(4, 8)) # d. mtcars %&gt;% mutate(peso_relativo = wt / max(wt)) # 2. # a. iris %&gt;% filter(str_detect(Species, &quot;set&quot;)) # b. iris %&gt;% filter(str_detect(Species, &quot;ver&quot;)) %&gt;% select(contains(&quot;Length&quot;)) # 3. # a. filmes_ordenados &lt;- data_imdb %&gt;% arrange(ano, desc(receita)) # b. data_imdb %&gt;% select(titulo, orcamento) %&gt;% arrange(desc(orcamento)) # c. imdb_prejuizo &lt;- data_imdb %&gt;% mutate(prejuizo = orcamento - receita) %&gt;% filter(prejuizo &gt; 0) %&gt;% arrange(prejuizo) # d. data_imdb &lt;- data_imdb %&gt;% mutate( lucro = receita - orcamento, lucro_medio = mean(lucro, na.rm = TRUE), lucro_relativo = (lucro - lucro_medio) / lucro_medio, houve_lucro = if_else(lucro &gt; 0, &quot;sim&quot;, &quot;não&quot;) ) # e. data_imdb &lt;- data_imdb %&gt;% mutate(classificacao = if_else(ano &gt; 2000, &quot;recente&quot;, &quot;antigo&quot;)) Acesso Professor Funções summarise, group_by e count Para ilustrar estas funções considere os dados: filmes &lt;- tibble::tibble( titulo = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;), ano = c(2020, 2021, 2020, 2021, 2021, 2022, 2022, 2020, 2022, 2021), genero = c(&quot;Ação&quot;, &quot;Comédia&quot;, &quot;Ação&quot;, &quot;Comédia&quot;, &quot;Drama&quot;, &quot;Ação&quot;, &quot;Drama&quot;, &quot;Ação&quot;, &quot;Comédia&quot;, &quot;Drama&quot;), receita = c(100, 200, 150, 180, 90, 300, 120, 80, 220, 70), orcamento = c(50, 100, 60, 90, 40, 80, 50, 30, 100, 35), nota = c(7.5, 8.2, 7.0, 6.8, 7.9, 8.5, 7.2, 6.5, 8.0, 7.4) ) A função summarise possibilita calcular medidas resumo para os dados: # Calculando a média dos orcamentos: filmes %&gt;% summarize(media_receita = mean(receita, na.rm = TRUE)) ## # A tibble: 1 × 1 ## media_receita ## &lt;dbl&gt; ## 1 151 # Calculando a mediana dos orcamentos: filmes %&gt;% summarize(mediana_receita = median(receita, na.rm = TRUE)) ## # A tibble: 1 × 1 ## mediana_receita ## &lt;dbl&gt; ## 1 135 Calculando várias medidas para a mesma variável: filmes %&gt;% summarise( media = mean(receita, na.rm = TRUE), mediana = median(receita, na.rm = TRUE), minimo = min(receita, na.rm = TRUE), maximo = max(receita, na.rm = TRUE) ) ## # A tibble: 1 × 4 ## media mediana minimo maximo ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 151 135 70 300 Calculando medidas para variáveis distintas: filmes %&gt;% summarize( media_orcamento = mean(orcamento, na.rm = TRUE), media_receita = mean(receita, na.rm = TRUE), media_nota = mean(nota, na.rm = TRUE) ) ## # A tibble: 1 × 3 ## media_orcamento media_receita media_nota ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 63.5 151 7.5 A função group_by, possibilita aplicar o summarise para uma variável por categorias de uma ou mais variáveis. # Calculando a receita média dos filmes por ano. filmes %&gt;% group_by(ano) %&gt;% summarise(receita_media = mean(receita, na.rm = TRUE)) ## # A tibble: 3 × 2 ## ano receita_media ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2020 110 ## 2 2021 135 ## 3 2022 213. # Calculando a receita média dos filmes por genero. filmes %&gt;% group_by(genero) %&gt;% summarise(receita_media = mean(receita, na.rm = TRUE)) ## # A tibble: 3 × 2 ## genero receita_media ## &lt;chr&gt; &lt;dbl&gt; ## 1 Ação 158. ## 2 Comédia 200 ## 3 Drama 93.3 # Calculando a receita média dos filmes por ano e genero. filmes %&gt;% group_by(ano, genero) %&gt;% summarise(receita_media = mean(receita, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;ano&#39;. You can override using the `.groups` ## argument. ## # A tibble: 6 × 3 ## # Groups: ano [3] ## ano genero receita_media ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2020 Ação 110 ## 2 2021 Comédia 190 ## 3 2021 Drama 80 ## 4 2022 Ação 300 ## 5 2022 Comédia 220 ## 6 2022 Drama 120 A função group_by em conjunto com summarise também permite contar o número de observações. # Calculando o total de filmes por ano. filmes %&gt;% group_by(ano) %&gt;% summarise(n = n()) ## # A tibble: 3 × 2 ## ano n ## &lt;dbl&gt; &lt;int&gt; ## 1 2020 3 ## 2 2021 4 ## 3 2022 3 # Calculando o total de filmes por genero filmes %&gt;% group_by(genero) %&gt;% summarise(n = n()) ## # A tibble: 3 × 2 ## genero n ## &lt;chr&gt; &lt;int&gt; ## 1 Ação 4 ## 2 Comédia 3 ## 3 Drama 3 # Calculando o total de filmes por ano e genero filmes %&gt;% group_by(ano, genero) %&gt;% summarise(n = n()) ## `summarise()` has grouped output by &#39;ano&#39;. You can override using the `.groups` ## argument. ## # A tibble: 6 × 3 ## # Groups: ano [3] ## ano genero n ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 2020 Ação 3 ## 2 2021 Comédia 2 ## 3 2021 Drama 2 ## 4 2022 Ação 1 ## 5 2022 Comédia 1 ## 6 2022 Drama 1 Para contagem de observações, a função count também pode ser usada: # Calculando o total de filmes por ano. filmes %&gt;% count(ano) ## # A tibble: 3 × 2 ## ano n ## &lt;dbl&gt; &lt;int&gt; ## 1 2020 3 ## 2 2021 4 ## 3 2022 3 # Calculando o total de filmes por genero filmes %&gt;% count(genero, sort = TRUE) ## # A tibble: 3 × 2 ## genero n ## &lt;chr&gt; &lt;int&gt; ## 1 Ação 4 ## 2 Comédia 3 ## 3 Drama 3 # Calculando o total de filmes por ano e por genero filmes %&gt;% count(ano, genero) ## # A tibble: 6 × 3 ## ano genero n ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 2020 Ação 3 ## 2 2021 Comédia 2 ## 3 2021 Drama 2 ## 4 2022 Ação 1 ## 5 2022 Comédia 1 ## 6 2022 Drama 1 Exercícios Utilize a base imdb e as funções do pacote dplyr nos exercícios a seguir. Calcule a duração média e mediana dos filmes da base. Calcule o lucro médio dos filmes com duração maior que 2 horas (ou seja, 120 minutos). Apresente na mesma tabela o lucro médio dos filmes com duracao menor que 120 minutos e o lucro médio dos filmes com duracao maior ou igual a 120 minutos. Calcule a nota IMDB média dos filmes por ano de lançamento e ordene em relação ao ano. Calcule a receita média e mediana dos filmes por ano e ordene em relação ao ano. Retorne a tabela sem NA’s. Respostas # a. data_imdb %&gt;% summarise( duracao_media = mean(duracao, na.rm = TRUE), duracao_mediana = median(duracao, na.rm = TRUE) ) # b. data_imdb %&gt;% filter(duracao &gt; 120) %&gt;% mutate(lucro = receita - orcamento) %&gt;% summarise(lucro_medio = mean(lucro, na.rm = TRUE)) # c. data_imdb %&gt;% mutate(lucro = receita - orcamento, grupo_duracao = ifelse(duracao &lt; 120, &quot;&lt; 120 min&quot;, &quot;≥ 120 min&quot;)) %&gt;% group_by(grupo_duracao) %&gt;% summarise(lucro_medio = mean(lucro, na.rm = TRUE)) # d notas_por_ano &lt;- data_imdb %&gt;% group_by(ano) %&gt;% summarise(nota_media = mean(nota_imdb, na.rm = TRUE)) %&gt;% arrange(ano) # e. receita_por_ano &lt;- data_imdb %&gt;% group_by(ano) %&gt;% summarise( receita_media = mean(receita, na.rm = TRUE), receita_mediana = median(receita, na.rm = TRUE) ) %&gt;% arrange(ano) %&gt;% filter(!is.na(receita_media), !is.na(receita_mediana)) Acesso Professor 4.3 Exercícios do Capítulo 4 (Entregar na lista 1) 1 Crie um data frame no R com os dados fictícios. Após isso, crie uma pasta no computador chamada “meus_dados” e usando as funções do pacote readr, use as funções de exportação para enviar os dados do R, nos formatos txt e csv, para a pasta “meus_dados”. Após isso utilize as funções de importação para trazer novamente estes dados para o R. 2. Crie dois conjuntos de dados em duas planilhas distintas de um arquivo de excel e salve o arquivo em alguma pasta do seu computador com a extensão .xlsx. Na sequencia, importe estes dados para o R e exiba os nomes das planilhas, usando funções do pacote readxl. 3. Considerando os dados do imdb e as funções do pacote dplyr: Filtre os filmes lançados entre 1990 e 1999 com lucro (receita - orçamento) positivo. Em seguida, mostre apenas titulo, ano e lucro, ordenados por lucro decrescente. Crie uma nova variável lucro = receita - orcamento, e depois: selecione os gêneros “Action”, “Drama” e “Comedy”, calcule o lucro médio por gênero, ordene do maior para o menor lucro. Crie uma tabela apenas com os diretores que: dirigiram mais de 10 filmes e cuja nota média no IMDb ultrapassa 7. Filtre todos os filmes cujo título contém “Love” e mostre titulo, ano, genero, e nota_imdb, ordenados da maior para a menor nota. Crie uma coluna faixa_lucro com os seguintes critérios: “grande prejuízo” se lucro &lt; -10 milhões “prejuízo moderado” se entre -10M e 0 “pequeno lucro” se entre 0 e 10M “grande lucro” se lucro &gt; 10M Depois, mostre a contagem de filmes em cada faixa. 4. Pesquise, explique o conceito e dê exemplos de outras 3 funções do pacote dplyr. "],["análises-estatísticas-básicas.html", "Capítulo 5 Análises Estatísticas Básicas 5.1 Análises Descritivas 5.2 Probabilidade 5.3 Análises Inferenciais 5.4 Exercícios do Capítulo 5 (Entregar na lista 1)", " Capítulo 5 Análises Estatísticas Básicas A Estatística é a ciência que fornece métodos para a coleta, organização, descrição, análise e interpretação de dados e para a utilização dos mesmos na tomada de decisões. A coleta, a organização e a descrição dos dados estão a cargo da Estatística Descritiva, enquanto que a análise e a interpretação desses dados ficam a cargo da Estatística Indutiva ou Inferencial. O aspecto essencial da Estatística é o de proporcionar métodos inferenciais, que permitam conclusões que transcendam os dados obtidos inicialmente. População: É o conjunto de indivíduos, itens ou observações, portadores de pelo menos uma característica em comum. Amostra: É qualquer subconjunto finito de uma população. Variável: São as características de interesse de uma população. As variáveis se classificam por: 5.1 Análises Descritivas 5.1.1 Tabelas de Frequência Tabelas de Frequência Sem Classes Utilizadas em geral para representar variáveis qualitativas ou numéricas discretas transformadas em fator. ## Dados de filmes: filmes &lt;- tibble::tibble( titulo = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;), ano = c(2020, 2021, 2020, 2021, 2021, 2022, 2022, 2020, 2022, 2021), genero = c(&quot;Ação&quot;, &quot;Comédia&quot;, &quot;Ação&quot;, &quot;Comédia&quot;, &quot;Drama&quot;, &quot;Ação&quot;, &quot;Drama&quot;, &quot;Ação&quot;, &quot;Comédia&quot;, &quot;Drama&quot;), receita = c(100, 200, 150, 180, 90, 300, 120, 80, 220, 70), orcamento = c(50, 100, 60, 90, 40, 80, 50, 30, 100, 35), nota = c(7.5, 8.2, 7.0, 6.8, 7.9, 7.5, 7.2, 6.5, 8.0, 7.4) ) ## Frequências absolutas table(filmes$genero) ## ## Ação Comédia Drama ## 4 3 3 ## Frequências relativas prop.table(table(filmes$genero)) ## ## Ação Comédia Drama ## 0.4 0.3 0.3 ### Com `dplyr` ## Frequências absolutas freq_abs &lt;- filmes %&gt;% count(genero) ## Frequências relativas freq_rel &lt;- freq_abs %&gt;% mutate(freq_relativa = n / sum(n)) Tabelas de Frequência Com Classes Utilizadas para representar variáveis contínuas. # Definir as classes (intervalos) de notas breaks &lt;- seq(6, 8.5, by = 0.5) # Quebrando os dados nas classes filmes$nota_classes &lt;- cut(filmes$nota, breaks = breaks, include.lowest = FALSE, right = TRUE) # include.lowest = FALSE e right = TRUE (default) # para não incluir o limite inferior e incluir o limite superior. # Tabela de frequências absolutas com classes freq_abs_classe &lt;- filmes %&gt;% count(nota_classes) # Tabela de frequências relativas com classes freq_rel_classes &lt;- freq_abs_classe %&gt;% mutate(freq_relativa = n/sum(n)) Podemos também calcular as frequências acumuladas: ## Calcular frequências acumuladas (absolutas e relativas) freq_acumulada_classes &lt;- freq_rel_classes %&gt;% mutate(freq_abs_acum = cumsum(n), # Frequência absoluta acumulada freq_rel_acum = cumsum(freq_relativa)) # Frequência relativa acumulada # nomes em cumsum referentes aos nomes da tabela freq_rel_classes # Resultado: freq_acumulada_classes ## # A tibble: 5 × 5 ## nota_classes n freq_relativa freq_abs_acum freq_rel_acum ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 (6,6.5] 1 0.1 1 0.1 ## 2 (6.5,7] 2 0.2 3 0.3 ## 3 (7,7.5] 4 0.4 7 0.7 ## 4 (7.5,8] 2 0.2 9 0.9 ## 5 (8,8.5] 1 0.1 10 1 5.1.2 Medidas Descritivas Nos conceitos básicos a seguir, vamos considerar \\(x_1, x_2, \\dots, x_n\\), um conjunto de valores. Medidas de posição Principais Medidas de Posição: Medida Descrição Fórmula / Observações Média Valor médio dos dados \\[ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i \\] Mediana Valor central de um conjunto ordenado Se \\(n\\) ímpar: \\(\\tilde{x} = x_{(\\frac{n+1}{2})}\\) Se \\(n\\) par: \\(\\tilde{x} = \\frac{x_{(n/2)} + x_{(n/2 + 1)}}{2}\\) Moda Valor mais frequente A moda é o valor que ocorre com maior frequência. Quantis Dividem os dados em partes iguais Quartis (4), Decis (10), Percentis (100). Mínimo/Máximo Valores extremos do conjunto Mínimo: \\(\\min(x)\\), Máximo: \\(\\max(x)\\) Medidas de posição usando funções básicas do R: ## Média mean(filmes$nota) ## [1] 7.4 ## Mediana median(filmes$nota) ## [1] 7.45 ## Moda - não tem função básica no R moda &lt;- function(x) { tb &lt;- table(x) as.numeric(names(tb)[tb == max(tb)]) } moda(filmes$nota) ## [1] 7.5 ## Mínimo min(filmes$nota) ## [1] 6.5 ## Máximo max(filmes$nota) ## [1] 8.2 ## Quantis # Quartis - 4 partes iguais quantile(filmes$nota) ## 0% 25% 50% 75% 100% ## 6.50 7.05 7.45 7.80 8.20 # Percentis - 100 partes iguais # Ex: 10º e 90º percentis quantile(filmes$nota, probs = c(0.10, 0.90)) ## 10% 90% ## 6.77 8.02 ## Summary - resume várias medidas dos dados summary(filmes$nota) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 6.50 7.05 7.45 7.40 7.80 8.20 Para calcular medidas de alguma variável por categorias de outra, podemos usar a função aggregate. ## Sintaxe: aggregate(formula, data, FUN) - formula: do tipo variável ~ agrupador - data: o nome do dataframe - FUN: a função que será aplicada ## Média da nota por gênero: aggregate(nota ~ genero, data = filmes, FUN = mean) ## genero nota ## 1 Ação 7.125000 ## 2 Comédia 7.666667 ## 3 Drama 7.500000 ## Média da nota e da receita por gênero aggregate(cbind(nota, receita) ~ genero, data = filmes, FUN = mean) ## genero nota receita ## 1 Ação 7.125000 157.50000 ## 2 Comédia 7.666667 200.00000 ## 3 Drama 7.500000 93.33333 ## Média da nota por ano e gênero aggregate(nota ~ ano + genero, data = filmes, FUN = mean) ## ano genero nota ## 1 2020 Ação 7.00 ## 2 2022 Ação 7.50 ## 3 2021 Comédia 7.50 ## 4 2022 Comédia 8.00 ## 5 2021 Drama 7.65 ## 6 2022 Drama 7.20 ## Outras funções em FUN aggregate(nota ~ ano + genero, data = filmes, FUN = function(x) c(media = mean(x), n = length(x))) ## ano genero nota.media nota.n ## 1 2020 Ação 7.00 3.00 ## 2 2022 Ação 7.50 1.00 ## 3 2021 Comédia 7.50 2.00 ## 4 2022 Comédia 8.00 1.00 ## 5 2021 Drama 7.65 2.00 ## 6 2022 Drama 7.20 1.00 Medidas de posição usando o pacote dplyr: ## Medidas de Posição das notas filmes %&gt;% summarise( media_nota = mean(nota), mediana_nota = median(nota), moda_nota = moda(nota), min_nota = min(nota), max_nota = max(nota) ) ## # A tibble: 1 × 5 ## media_nota mediana_nota moda_nota min_nota max_nota ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7.4 7.45 7.5 6.5 8.2 ## Medidas de Posição das notas por categoria de genero filmes %&gt;% group_by(genero) %&gt;% summarise( media_nota = mean(nota), mediana_nota = median(nota), min_nota = min(nota), max_nota = max(nota), n = n(), .groups = &quot;drop&quot;) ## # A tibble: 3 × 6 ## genero media_nota mediana_nota min_nota max_nota n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Ação 7.12 7.25 6.5 7.5 4 ## 2 Comédia 7.67 8 6.8 8.2 3 ## 3 Drama 7.5 7.4 7.2 7.9 3 # .groups = &quot;drop&quot;: Desfaz o agrupamento após o resumo. # Ou seja, você retorna a tabela sem a variável de Groups. ## Medidas de Posição das notas por categoria de ano e genero filmes %&gt;% group_by(ano, genero) %&gt;% summarise( media_nota = mean(nota), mediana_nota = median(nota), min_nota = min(nota), max_nota = max(nota), n = n(), .groups = &quot;drop&quot;) ## # A tibble: 6 × 7 ## ano genero media_nota mediana_nota min_nota max_nota n ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2020 Ação 7 7 6.5 7.5 3 ## 2 2021 Comédia 7.5 7.5 6.8 8.2 2 ## 3 2021 Drama 7.65 7.65 7.4 7.9 2 ## 4 2022 Ação 7.5 7.5 7.5 7.5 1 ## 5 2022 Comédia 8 8 8 8 1 ## 6 2022 Drama 7.2 7.2 7.2 7.2 1 Medidas de Dispersão Principais Medidas de Dispersão: Medida Descrição Fórmula / Observações Amplitude Total Diferença entre o maior e o menor valor \\[ A = \\max(x) - \\min(x) \\] Variância Média dos quadrados dos desvios em relação à média \\[ s^2 = \\frac{1}{n - 1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2 \\] Desvio-Padrão Raiz quadrada da variância \\[ s = \\sqrt{s^2} \\] Coeficiente de Variação (CV) Dispersão relativa em relação à média, expressa em porcentagem \\[ CV = \\frac{s}{\\bar{x}} \\times 100\\% \\] Medidas de dispersão usando funções básicas do R: ## Amplitude Total diff(range(filmes$nota)) ## [1] 1.7 ## Variância var(filmes$nota) ## [1] 0.2933333 ## Desvio-Padrão sd(filmes$nota) ## [1] 0.5416026 ## Coeficiente de Variação (CV) cv &lt;- function(x) sd(x)/mean(x) * 100 cv(filmes$nota) # Coeficiente de variação (%) ## [1] 7.318954 Medidas de dispersão usando o pacote dplyr: ## Medidas de Posição das notas filmes %&gt;% summarise( at_nota = diff(range(filmes$nota)), var_nota = var(filmes$nota), sd_nota = sd(nota), cv_nota = cv(nota) ) ## # A tibble: 1 × 4 ## at_nota var_nota sd_nota cv_nota ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.7 0.293 0.542 7.32 5.1.3 Gráficos Gráficos para Variáveis Qualitativas 1. Gráfico de Barras O gráfico de barras pode ser usado para representar a frequência absoluta de variáveis qualitativas (nominais ou ordinais). # Contando as frequências dos generos freq_genero &lt;- table(filmes$genero) barplot(freq_genero, main = &quot;Frequência dos generos dos filmes&quot;, xlab = &quot;genero&quot;, ylab = &quot;frequencias&quot;, col = &quot;lightblue&quot;) 2. Gráfico de Setores Este gráfico é ideal para representar a distribuição percentual de categorias de uma variável qualitativa. Ele é especialmente útil para mostrar a proporção de cada categoria em relação ao todo. pie(freq_genero, main = &quot;Distribuição dos generos dos filmes&quot;, col = rainbow(length(freq_genero)), labels = paste(names(freq_genero), &quot;\\n&quot;, round(100*freq_genero/sum(freq_genero), 1), &quot;%&quot;)) 3. Gráfico de Barras Empilhadas Se você quiser empilhar barras para visualizar a distribuição de uma variável qualitativa em função de outra. barplot(table(filmes$genero, filmes$ano), beside = FALSE, col = rainbow(3), legend = names(freq_genero), main = &quot;Distribuição do genero por ano&quot;, xlab = &quot;genero&quot;, ylab = &quot;ano&quot;) Gráficos para Variáveis Quantitativas 1. Gráfico de Dispersão É utilizado para verificar a relação entre duas variáveis quantitativas. plot(filmes$orcamento, filmes$receita, main = &quot;Gráfico de Dispersão para o orçamento&quot;, xlab = &quot;Orçamento&quot;, ylab = &quot;Receita&quot;, col = &quot;blue&quot;, pch = 19) # pch = 19 faz os pontos aparecerem como círculos sólidos 2. Histograma O histograma é útil para visualizar a distribuição de variáveis quantitativas contínuas. # usando breaks, criado anteriormente: breaks &lt;- seq(6, 8.5, by = 0.5) hist(filmes$nota, col = &quot;orange&quot;, main = &quot;Histograma das notas&quot;, xlab = &quot;Classes de notas&quot;, ylab = &quot;Frequência&quot;, breaks = breaks) # O argumento breaks define o número de intervalos 3. Boxplot O boxplot é útil para visualizar a distribuição de uma variável quantitativa e identificar outliers. boxplot(filmes$nota, main = &quot;Boxplot das notas&quot;, ylab = &quot;Notas&quot;, col = &quot;lightgreen&quot;) O boxplot também pode ser usado para ver o comportamento de uma variável quantitativa por categorias de outra variável. boxplot(nota ~ genero, data = filmes, xlab = &quot;Genero&quot;, ylab = &quot;Notas&quot;, col = &quot;lightgreen&quot;) Adicionando as informações das médias também no gráfico: boxplot(nota ~ genero, data = filmes, xlab = &quot;Genero&quot;, ylab = &quot;Notas&quot;, col = &quot;lightgreen&quot;) # Calculando as médias por genero medias &lt;- tapply(filmes$nota, filmes$genero, mean, na.rm = TRUE) # Adicionando as médias no gráfico points(x = 1:length(medias), y = medias, col = &quot;black&quot;, pch = 19, cex = 1) # pch -&gt; formato do objeto # cex -&gt; tamanho do objeto Exercícios 1. Considere a variável a seguir representando o número de filhos de 30 famílias: filhos &lt;- c(0, 1, 2, 2, 3, 1, 0, 2, 1, 3, 2, 2, 0, 1, 2, 3, 2, 4, 1, 2, 1, 0, 2, 2, 3, 1, 2, 0, 1, 2) Usando o pacote dplyr, construa uma tabela com as frequências absolutas, relativas e acumuladas. Calcule, com dplyr, as medidas de posição e dispersão: média, mediana, moda, mínimo, máximo, quartis, amplitude total, variância, desvio padrão e coeficiente de variação. Construa um gráfico de dispersão que mostre a frequência absoluta de cada valor distinto de filhos. Personalize o gráfico: altere o título, os nomes dos eixos e a cor dos pontos. 2. Considere o vetor a seguir com salários mensais (em mil R$) de um grupo de pessoas: salarios &lt;- c(2.5, 3.2, 2.8, 4.1, 5.5, 6.0, 7.3, 3.0, 2.7, 6.5, 5.9, 2.6, 3.4, 4.0, 6.2, 4.5, 3.6, 5.0) Agrupe os salários em intervalos de classe iniciando em 2, com amplitude 1 (aberto à esquerda e fechado à direita) usando cut() e construa uma tabela com as frequências absolutas, relativas e acumuladas com dplyr. Calcule as medidas de posição e dispersão dos salários usando dplyr. Construa um histograma dos salários. Personalize o histograma: modifique as cores, o título e os nomes dos eixos. 3. Utilize o conjunto de dados mtcars, já disponível no R: data(mtcars) Para a variável mpg (milhas por galão), construa uma tabela com as frequências absolutas, relativas e acumuladas agrupando os dados em intervalor de classe de amplitude 5. Calcule as medidas de posição e dispersão da variável mpg. Construa um boxplot de mpg por número de cilindros (cyl). Personalize o gráfico: modifique cores, título, nomes dos eixos e adicione bordas aos boxplots. 4. Considere os dados agrupados para a variável X: Nº de atendimentos diários: Table 5.1: Tabela de Frequência para a variável X: nº de atendimentos diários X Frequência 10 2 12 5 14 7 16 9 18 4 20 3 Com base nessa tabela: Calcule as seguintes medidas: média, mediana, mínimo e máximo, amplitude total, desvio padrão e coeficiente de variação (CV). Construa o gráfico de dispersão da frequência de atendimentos. Personalize o gráfico anterior com título, nomes nos eixos e cor dos pontos. Respostas ## 1. Número de filhos filhos &lt;- c(0, 1, 2, 2, 3, 1, 0, 2, 1, 3, 2, 2, 0, 1, 2, 3, 2, 4, 1, 2, 1, 0, 2, 2, 3, 1, 2, 0, 1, 2) # a. Tabela de frequências tabela_freq &lt;- data.frame( filhos = sort(unique(filhos)) ) %&gt;% mutate( freq_abs = as.numeric(table(filhos)), freq_rel = freq_abs / sum(freq_abs), freq_acum = cumsum(freq_abs) ) # b. Medidas de posição e dispersão summary_stats &lt;- tibble::tibble(filhos = filhos) %&gt;% summarise( media = mean(filhos), mediana = median(filhos), moda = as.numeric(names(table(filhos))[table(filhos) == max(table(filhos))]), minimo = min(filhos), maximo = max(filhos), Q1 = quantile(filhos, 0.25), Q3 = quantile(filhos, 0.75), amplitude = max(filhos) - min(filhos), variancia = var(filhos), desvio_padrao = sd(filhos), cv = sd(filhos) / mean(filhos) * 100 ) # c. Gráfico de dispersão das frequências plot(tabela_freq$filhos, tabela_freq$freq_abs, main = &quot;Frequência de número de filhos&quot;, xlab = &quot;Número de filhos&quot;, ylab = &quot;Frequência absoluta&quot;, col = &quot;blue&quot;, pch = 19) # d. Personalização do gráfico plot(tabela_freq$filhos, tabela_freq$freq_abs, main = &quot;Distribuição de Filhos por Família&quot;, xlab = &quot;Filhos&quot;, ylab = &quot;Frequência Absoluta&quot;, col = &quot;darkred&quot;, pch = 17) ## 2. Salários salarios &lt;- c(2.5, 3.2, 2.8, 4.1, 5.5, 6.0, 7.3, 3.0, 2.7, 6.5, 5.9, 2.6, 3.4, 4.0, 6.2, 4.5, 3.6, 5.0) # a. Tabela de frequência com classes breaks = seq(2, 8, by = 1) classes &lt;- cut(salarios, breaks = breaks, right = TRUE) tabela_sal &lt;- data.frame(classe = levels(classes)) %&gt;% mutate( freq_abs = as.numeric(table(classes)), freq_rel = freq_abs / sum(freq_abs), freq_acum = cumsum(freq_abs) ) # b. Medidas de posição e dispersão moda_sal &lt;- as.numeric(names(sort(table(salarios), decreasing = TRUE)[1])) tibble(salarios) %&gt;% summarise( media = mean(salarios), mediana = median(salarios), moda = moda_sal, minimo = min(salarios), maximo = max(salarios), Q1 = quantile(salarios, 0.25), Q3 = quantile(salarios, 0.75), amplitude = max(salarios) - min(salarios), variancia = var(salarios), desvio_padrao = sd(salarios), cv = sd(salarios) / mean(salarios) * 100 ) # c. Histograma hist(salarios, col = &quot;lightblue&quot;, main = &quot;Histograma dos Salários&quot;, xlab = &quot;Salário (mil R$), breaks = breaks)) # d. Personalização do histograma hist(salarios, col = &quot;darkgreen&quot;, border = &quot;white&quot;, main = &quot;Distribuição de Salários&quot;, xlab = &quot;Salário (R$ mil)&quot;, breaks = breaks)) ## 3. mtcars – Consumo (mpg) data(mtcars) # a. Frequência de mpg por classes de largura 5 classes_mpg &lt;- cut(mtcars$mpg, breaks = seq(10, 35, by = 5), right = FALSE) tabela_mpg &lt;- data.frame(classe = levels(classes_mpg)) %&gt;% mutate( freq_abs = as.numeric(table(classes_mpg)), freq_rel = freq_abs / sum(freq_abs), freq_acum = cumsum(freq_abs) ) tabela_mpg # b. Medidas de posição e dispersão de mpg tibble(mpg = mtcars$mpg) %&gt;% summarise( media = mean(mpg), mediana = median(mpg), minimo = min(mpg), maximo = max(mpg), Q1 = quantile(mpg, 0.25), Q3 = quantile(mpg, 0.75), amplitude = max(mpg) - min(mpg), variancia = var(mpg), desvio_padrao = sd(mpg), cv = sd(mpg) / mean(mpg) * 100 ) # c. Boxplot por número de cilindros boxplot(mpg ~ cyl, data = mtcars) # d. Personalização do boxplot boxplot(mpg ~ cyl, data = mtcars, col = c(&quot;lightblue&quot;, &quot;lightgreen&quot;, &quot;tomato&quot;), main = &quot;Consumo por Nº de Cilindros&quot;, xlab = &quot;Cilindros&quot;, ylab = &quot;Milhas por Galão&quot;, border = &quot;black&quot;) Acesso Professor 5.2 Probabilidade O que são Probabilidades em Modelos Estatísticos? Probabilidades em modelos estatísticos nos permitem calcular a chance de ocorrência de eventos em distribuições teóricas. Esses modelos são fundamentais para inferência estatística e testes de hipóteses. 5.2.1 Principais Modelos Discretos 1. Distribuição Binomial Notação: \\(X \\sim B(n,p)\\) Função de Probabilidade: \\[ P(X = k) = \\binom{n}{k} p^k (1 - p)^{n - k}, \\quad \\text{para} \\quad k = 0, 1, \\dots, n \\] Média e Variância: \\(E(X)=np\\) e \\(Var(X)=np(1-p)\\) Parâmetros no R: size = n (número de tentativas), prob = p (probabilidade de sucesso em cada tentativa) Funções no R: ## Probabilidades # P(X = k): Probabilidade do valor X=k dbinom(k, size, prob) # P(X ≤ k): Probabilidade acumulada até o valor X=k pbinom(k, size, prob, lower.tail = TRUE) # equialente a sum(dbinom(0:k, size, prob)) # P(X &gt; k): Probabilidade maior do que o valor X=k 1 - pbinom(k, size, prob) ## Geração de números aleatórios rbinom(n, size, prob) Exemplos: # Seja X ~ B(n=5, p=0.2). Então, # 1. P(X=2) dbinom(2, size = 5, prob = 0.2) ## [1] 0.2048 # 2. P(X ≤ 1) = P(X=0) + P(X=1) dbinom(0, size = 5, prob = 0.2) + dbinom(1, size = 5, prob = 0.2) ## [1] 0.73728 # ou pbinom(1, size = 5, prob = 0.2) ## [1] 0.73728 # 3. P(X&gt;1) 1-pbinom(1, size = 5, prob = 0.2) ## [1] 0.26272 # ou pbinom(1, size = 5, prob = 0.2, lower.tail = F) ## [1] 0.26272 Gráfico: x &lt;- 0:20 plot(x, dbinom(x, size=20, prob=0.5), type=&quot;h&quot;, lwd=2, main=&quot;Distribuição Binomial (n=20, p=0.5)&quot;, xlab=&quot;Número de sucessos&quot;, ylab=&quot;Probabilidade&quot;) 2. Distribuição Poisson Notação: \\(X \\sim Poisson(\\lambda)\\) Função de Probabilidade: \\[ P(X = k) = \\frac{e^{-\\lambda}\\lambda^x}{x!}, \\quad \\text{para} \\quad x \\ge 0 \\] Média e Variância: \\(E(X)=\\lambda\\) e \\(Var(X)=\\lambda\\) Parâmetros no R: lambda = \\(\\lambda\\) Funções no R: ## Probabilidades # P(X = k): Probabilidade do valor X=k dpois(k, lambda, log = FALSE) # P(X ≤ k): Probabilidade acumulada até o valor X=k ppois(k, lambda, lower.tail = TRUE) # equialente a sum(dpois(0:k, lambda)) # P(X &gt; k): Probabilidade maior do que o valor X=k 1 - ppois(k, lambda) ## Geração de números aleatórios rpois(n, lambda) Exemplos: # Seja X ~ Poisson(λ = 3). Então, # 1. P(X=1) dpois(1, lambda = 3) ## [1] 0.1493612 # 2. P(X &gt; 1) = 1 - P(X ≤ 1) = 1 - [P(X=0) + P(X=1)] 1 - (dpois(0, lambda = 3) + dpois(1, lambda = 3)) ## [1] 0.8008517 # ou ppois(1, lambda = 3, lower.tail = F) ## [1] 0.8008517 Gráfico: x &lt;- 0:10 plot(x, dpois(x, lambda = 3), type=&quot;h&quot;, lwd=2, main=&quot;Distribuição Poisson (lambda = 3)&quot;, xlab=&quot;Valores de X&quot;, ylab=&quot;Probabilidade&quot;) 5.2.2 Principais Modelos Contínuos 1. Distribuição Uniforme Contínua Notação: \\(X \\sim U_c(a,b)\\) Função de Densidade de Probabilidade: \\[ f(x)=\\frac{1}{b-a}, \\quad \\text{para} \\quad x\\in [a,b] \\] Média e Variância: \\(E(X)=\\frac{(a+b)}{2}\\) e \\(Var(X)=\\frac{(b-a)^2}{12}\\) Parâmetros no R: min = \\(a\\) e max = \\(b\\) Funções no R: ## Probabilidades # f(x): Valor da função densidade em x dunif(x, min, max, log = FALSE) # P(X ≤ x): Probabilidade acumulada até o valor x punif(x, min, max, lower.tail = TRUE) # P(X &gt; k): Probabilidade maior do que o valor x 1 - punif(x, min, max) ## Geração de números aleatórios runif(n, min, max) ## Quantis qunif(p, min, max, lower.tail = TRUE) Exemplos: # Seja X ~ Uc(1,5). Então, # 1. P(X ≤ 2) punif(2, min = 1, max = 5) ## [1] 0.25 # 2. P(X &gt; 3) punif(3, min = 1, max = 5, lower.tail = FALSE) ## [1] 0.5 # 3. Gerando 10 valores desta distribuição: runif(10, min = 1, max = 5) ## [1] 3.391909 2.218477 2.538593 3.969590 4.395748 1.948953 3.359917 2.274944 ## [9] 1.917143 4.566176 # 4. O valor x tal que P(X ≤ x) = 0,25 qunif(0.25, min = 1, max = 5) ## [1] 2 Gráfico: curve(dunif(x, 1, 5), from = 1, to = 5, col = &quot;blue&quot;, lwd = 2, ylab = &quot;Densidade&quot;, xlab = &quot;x&quot;) 2. Distribuição Normal Notação: \\(X \\sim N(\\mu, \\sigma^2)\\) Função de Densidade de Probabilidade: \\[ f(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{-\\frac{1}{2}\\left(\\frac{x - \\mu}{\\sigma} \\right)^2} \\] Média e Variância: \\(E(X)=\\mu\\) e \\(Var(X)=\\sigma^2\\), desvio-padrão: \\(\\sigma = \\sqrt{\\sigma^2}\\) Parâmetros no R: mean = \\(\\mu\\) (média), sd = \\(\\sigma\\) (desvio-padrão) Funções no R: ## Probabilidades # f(x): Valor da função densidade em x dnorm(x, mean, sd, log = FALSE) # P(X ≤ x): Probabilidade acumulada até o valor x pnorm(x, mean, sd, lower.tail = TRUE) # P(X &gt; k): Probabilidade maior do que o valor x 1 - pnorm(x, mean, sd) # equivalente a pnorm(x, mean, sd, lower.tail = FALSE) ## Geração de números aleatórios rnorm(n, mean, sd) ## Quantis qnorm(p, mean = 0, sd = 1, lower.tail = TRUE) Exemplos: # Seja X ~ N(μ=10, σ²=4). Então, # 1. P(X ≤ 8) pnorm(8, mean = 10, sd = 2) ## [1] 0.1586553 # 2. P(X &gt; 10) pnorm(10, mean = 10, sd = 2, lower.tail = FALSE) ## [1] 0.5 # 3. Gerando 10 valores desta distribuição: rnorm(10, mean = 10, sd = 2) ## [1] 9.952253 6.751808 7.109670 10.124945 11.874016 11.802563 10.324212 ## [8] 12.922326 9.831610 10.646412 # 4. O valor x tal que P(X ≤ x) = 0,25 qnorm(0.25, mean = 10, sd = 2) ## [1] 8.65102 Um caso particular da distribuição Normal é quando \\(\\mu=0\\) e \\(\\sigma = 1\\). Neste caso, dizemos que \\(Z \\sim N(0,1)\\) e a chamamos de distribuição Normal Padrão. Gráfico: curve(dnorm(x, mean = 10, sd = 2), from = -5, to = 15, col = &quot;blue&quot;, lwd = 2, ylim = c(0,0.5), ylab = &quot;Distribuições Normais&quot;) curve(dnorm(x), from = -5, to = 5, add = TRUE, lwd = 2, col = &quot;red&quot;) legend(&quot;topright&quot;, legend = c(&quot;Normal padrão: N(0,1)&quot;, &quot;N(10,4)&quot;), col = c(&quot;red&quot;, &quot;blue&quot;), lty = c(1, 1), lwd = 2) Podemos transformar uma variável \\(X \\sim N(\\mu, \\sigma^2)\\) em uma Normal Padrão, fazendo: \\[ Z = \\frac{X-\\mu}{\\sigma} \\sim N(0,1) \\] 3. Distribuição t-Student Notação: \\(X \\sim t_v\\) Média e Variância: \\(E(X)=0\\) e \\(Var(X)=\\frac{v}{v-2}\\), se \\(v &gt; 2\\). Parâmetros no R: df = \\(v\\) (graus de liberdade) Funções no R: ## Probabilidades # f(x): Valor da função densidade em x dt(x, df, log = FALSE) # P(X ≤ x): Probabilidade acumulada até o valor x pt(x, df, lower.tail = TRUE) # P(X &gt; k): Probabilidade maior do que o valor x 1 - pt(x, df) ## Geração de números aleatórios rt(n, df) ## Quantis qt(p, df, lower.tail = TRUE) Exemplos: # Seja X ~ t(5). Então, # 1. P(X ≤ 4) pt(4, df = 5) ## [1] 0.9948383 # 2. P(X &gt; 4.5) pt(4.5, df = 5, lower.tail = FALSE) ## [1] 0.003199768 # 3. Gerando 10 valores desta distribuição: rt(10, df = 5) ## [1] -1.26390850 0.67346318 -0.47999264 -0.32674250 0.37638425 0.17740310 ## [7] 0.02049149 1.52012916 2.01968941 0.65584442 # 4. O valor x tal que P(X ≤ x) = 0,25 qt(0.25, df = 5) ## [1] -0.7266868 Obs.: Quando df aumenta, a distribuição t-student se aproxima da distribuição N(0,1). Gráfico: curve(dt(x, df = 3), from = -5, to = 5, col = &quot;blue&quot;, lwd = 2, ylim = c(0,0.4), ylab = &quot;Densidade&quot;, xlab = &quot;t&quot;) curve(dt(x, df = 7), from = -5, to = 5, col = &quot;purple&quot;, lwd = 2, add = TRUE) curve(dt(x, df = 30), from = -5, to = 5, col = &quot;green&quot;, lwd = 2, add = TRUE) curve(dnorm(x), from = -5, to = 5, col = &quot;red&quot;, lwd = 2, add = TRUE) legend(&quot;topright&quot;, legend = c(&quot;t (df = 3)&quot;, &quot;t (df = 7)&quot;, &quot;t (df = 30)&quot;, &quot;N(0,1)&quot;), col = c(&quot;blue&quot;, &quot;purple&quot;, &quot;green&quot;, &quot;red&quot;), lwd = 2) Tabela de Referência Rápida Distribuição Probabilidades Quantil Números Aleatórios Binomial dbinom() ou pbinom() qbinom() rbinom() Poisson dpois() ou ppois() qpois() rpois() Uniforme punif() qunif() runif() Normal pnorm() qnorm() rnorm() t-Student pt() qt() rt() Exercícios 1. Numa distribuição \\(B(n=15, p=0,4)\\), calcule: P(X = 7) P(X ≤ 5) P(X &gt; 10) 2. Para \\(X \\sim N(100, 10)\\), calcule: P(X ≤ 110) P(90 &lt; X ≤ 105) O valor x, tal que P(X ≤ x) = 0,95 3. Gere 20 valores das seguintes distribuições: \\(B(n=20, p=0,25)\\) \\(N(\\mu=50, \\sigma^2=25)\\) \\(U_c(0,1)\\) \\(t_{(7)}\\) 4. Para as distribuições a seguir, encontre os quartis (Q1 e Q3): \\(N(\\mu=10, \\sigma^2=25)\\) \\(U_c(2,10)\\) \\(t_{(20)}\\) Respostas ## 1. # Parâmetros n &lt;- 15; p &lt;- 0.4 # a) P(X = 7) dbinom(7, size=n, prob=p) # b) P(X ≤ 5) pbinom(5, size=n, prob=p) # c) P(X &gt; 10) = 1 - P(X ≤ 10) 1 - pbinom(10, size=n, prob=p) ## 2. # a) P(X ≤ 110) media &lt;- 100; desvio &lt;- 10 pnorm(110, mean=media, sd=desvio) # b) P(90 &lt; X ≤ 105) = P(X ≤ 105) - P(X ≤ 90) pnorm(105, mean=media, sd=desvio) - pnorm(90, mean=media, sd=desvio) # c) Valor de x tal que P(X ≤ x) = 0.95 qnorm(0.95, mean=media, sd=desvio) ## 3. set.seed(123) # Para reprodutibilidade # a) Binomial (n=20, p=0.25) rbinom(20, size=20, prob=0.25) # b) Normal (μ=50, σ=5) rnorm(20, mean=50, sd=5) # c) Uniforme (0,1) runif(20, min=0, max=1) # d) t-student(7) rt(20, df=7) ## 4. # a) Normal (μ=10, σ=5) q1_normal &lt;- qnorm(0.25, mean=10, sd=5) q3_normal &lt;- qnorm(0.75, mean=10, sd=5) # b) Uniforme (2,10) q1_uniforme &lt;- qunif(0.25, min=2, max=10) q3_uniforme &lt;- qunif(0.75, min=2, max=10) # c) t-student(20) q1_t &lt;- qt(0.25, df=20) q3_t &lt;- qt(0.75, df=20) Acesso Professor 5.3 Análises Inferenciais Inferência Estatística Conjunto de técnicas utilizadas para tirar conclusões sobre determinada(s) característica(s) da população, a partir de informações colhidas de uma amostra. Para a distribuição Normal: 5.3.1 Intervalo de Confiança Intervalo de Confiança São utilizados na estatística para encontrar limites que contenham alguma probabilidade conhecida de conter o valor do parâmetro De modo geral, seja \\(\\theta\\) o parâmetro de interesse, então o intervalo de confiança para \\(\\theta\\) com probabilidade \\(1 − \\alpha\\) (nível de confiança) é: \\[ IC(θ,(1 − α)) = [Li; Ls] \\] onde: \\(P(Li ≤ θ ≤ Ls) = 1 − α\\) Li → limite inferior do intervalo; Ls → limite superior do intervalo; Intervalo de Confiança: média \\(µ\\) de uma população Normal \\[ IC(µ,(1 − α)) = [\\bar{X} − e; \\bar{X} + e] \\] Se \\(σ^2\\) conhecida: \\(e = z\\frac{s}{\\sqrt{n}}\\) \\(z\\) é tal que \\(P(Z ≥ z) = \\frac{\\alpha}{2}\\). no R: qnorm(1-α/2) Se \\(σ^2\\) desconhecida: \\(e = t_{(n-1)}\\frac{s}{\\sqrt{n}}\\) \\(t\\) é tal que \\(P(t ≥ t_{(n-1)}) = \\frac{\\alpha}{2}\\). no R: qt(1-α/2, df = n-1) Exemplo: Uma amostra de 8 clientes de um banco apresentou os seguintes tempos (em minutos) para completar um atendimento: 12, 15, 14, 13, 16, 14, 15, 13 Assumindo que o tempo de atendimento tem distribuição normal, construa um intervalo de confiança de 95% para a média populacional. ## Dados x &lt;- c(12, 15, 14, 13, 16, 14, 15, 13) ## Nivel de confiança # 1-alpha = 0.95 alpha = 1-0.95 ## Informações da Amostra n &lt;- length(x) # Tamanho da amostra media &lt;- mean(x) # Média amostral desvio &lt;- sd(x) # Desvio padrão amostral erro &lt;- desvio / sqrt(n) # Erro padrão da média ## Valor crítico da t com n - 1 graus de liberdade t_critico &lt;- qt(1-alpha/2, df = n - 1) ## Limites do intervalo de confiança limite_inferior &lt;- media - t_critico * erro limite_superior &lt;- media + t_critico * erro cbind(limite_inferior, limite_superior) ## limite_inferior limite_superior ## [1,] 12.90539 15.09461 Usando o pacote DescTools: # Instalar se ainda não tiver # install.packages(&quot;DescTools&quot;) # Carregar library(DescTools) x &lt;- c(12, 15, 14, 13, 16, 14, 15, 13) # Intervalo de confiança de 95% MeanCI(x, conf.level = 0.95) ## mean lwr.ci upr.ci ## 14.00000 12.90539 15.09461 5.3.2 Testes de Hipóteses Testes de Hipóteses Ferramenta usada na estatística para verificar alguma informação sobre um parâmetro. Etapas básicas num teste de hipóteses: Formulação das hipóteses Cálculo da Estatística Teste Região Crítica ou p-valor Conclusão Seja \\(\\mu\\) a altura média de uma população (parâmetro) sobre o qual queremos verificar uma afirmação (testar uma hipótese). Queremos verificar se \\(\\mu\\) é igual a uma quantidade fixada, por exemplo, se \\(\\mu\\) é igual a 180. Então, formulamos as hipóteses: Hipótese nula (H0): é a hipótese que estamos colocando à prova. Hipótese alternativa (H1): é a hipótese que será considerada aceitável, caso a hipótese nula seja rejeitada. Neste caso, H₀: µ = 180 H₁: µ ≠ 180 Qualquer que seja a decisão tomada, estamos sujeitos a cometer erros: Erro de tipo I: Rejeitar a hipótese nula quando essa é verdadeira. \\[ α = P(\\text{Erro Tipo I}) = P(\\text{Rejeitar } H_0|H_0 \\text{ é verdadeira}) \\] Erro de tipo II: Não rejeitar a hipótese nula quando essa é falsa. \\[ β = P(\\text{Erro Tipo II}) = P(\\text{Não rejeitar } H_0|H_0 \\text{ é falsa}) \\] A probabilidade α é também chamada de nível de significância e é geralmente fixada em 10%, 5% ou 1%. Tipos de Hipóteses para µ: Comparando µ com algum valor hipotético µ₀: Hipótese Bilateral Unilateral esquerda Unilateral direita H₀ µ = µ₀ µ ≥ µ₀ µ ≤ µ₀ H₁ µ ≠ µ₀ µ &lt; µ₀ µ &gt; µ₀ Teste de Hipótese para µ (com σ² desconhecida) Estatística Teste: \\[ T_0 = \\frac{\\bar{X}-\\mu_0}{S/\\sqrt{n}} \\] Usando a Região Crítica: Usando o p-valor: O p-valor é a probabilidade de obter um resultado tão extremo (ou mais extremo) quanto o observado nos dados, assumindo que a hipótese nula (H₀) é verdadeira. Em outras palavras, mede quão compatíveis os dados estão com H₀. Teste unilateral à direita: p-valor = \\(P(T &gt; T_0)\\). Teste unilateral à esquerda: p-valor = \\(P(T &lt; T_0)\\). Teste bilateral: p-valor = \\(2P(T &gt; |T_0|)\\). Conclusão: Se \\(T_0 \\in RC\\) ou \\(p-valor \\le \\alpha\\), rejeitamos a hipótese nula. Ou seja, existem evidências amostrais de que a média é diferente de \\(\\mu_0\\) (ou maior/menor, dependendo do teste). Exemplo: Tempo de Resposta de um Servidor Um provedor afirma que seu servidor responde, em média, em até 200 ms. Um analista de desempenho quer verificar se o tempo de resposta médio real é maior que isso. Ele coleta uma amostra de 12 requisições, obtendo os tempos de resposta em milissegundos: tempos &lt;- c(210, 198, 203, 215, 220, 205, 199, 211, 208, 202, 219, 217) Hipóteses: H₀: μ ≤ 200 ms (o tempo de resposta está dentro do prometido) H₁: μ &gt; 200 ms (o tempo de resposta é maior que o prometido) No R: ### Teste t unilateral à direita # Considerando alpha = 5% tempos &lt;- c(210, 198, 203, 215, 220, 205, 199, 211, 208, 202, 219, 217) ## Estatística Teste n &lt;- length(tempos) t0 &lt;- (mean(tempos) - 200)/(sd(tempos)/sqrt(n)) ## Região crítica alpha = 0.05 ts=qt(1-alpha, df = n-1) t0 &gt; ts # rejeita H0 ## [1] TRUE ## p-valor p_valor &lt;- pt(t0, df = n-1, lower.tail = F) ## No R: t.test(tempos, mu = 200, alternative = &quot;greater&quot;, conf.level = 1-alpha) ## ## One Sample t-test ## ## data: tempos ## t = 4.0216, df = 11, p-value = 0.001005 ## alternative hypothesis: true mean is greater than 200 ## 95 percent confidence interval: ## 204.9348 Inf ## sample estimates: ## mean of x ## 208.9167 Conclusão: Como p-valor &lt; 5%, rejeitamos H₀. Existem evidências amostrais de que o tempo de resposta médio do servidor é maior que 200 ms. Exemplo: Tempo Médio Diário em Redes Sociais entre Universitários Pesquisas indicam que jovens universitários passam, em média, 3 horas por dia em redes sociais. Um pesquisador suspeita que esse valor mudou recentemente, devido ao aumento de conteúdo acadêmico e profissional nas plataformas. Ele coleta dados de 10 estudantes de uma universidade local: tempos &lt;- c(3.5, 3.8, 2.9, 3.3, 4.0, 2.7, 3.2, 3.6, 2.8, 3.1) Hipóteses: H₀: μ = 3.0 horas H₁: μ ≠ 3.0 horas (teste bilateral, para verificar se houve mudança) ### Teste t bilateral # Considerando alpha = 5% tempos &lt;- c(3.5, 3.8, 2.9, 3.3, 4.0, 2.7, 3.2, 3.6, 2.8, 3.1) ## Estatística Teste n &lt;- length(tempos) t0 &lt;- (mean(tempos) - 3)/(sd(tempos)/sqrt(n)) ## Região crítica alpha &lt;- 0.05 ti &lt;- qt(alpha/2, df = n-1) ts &lt;- -ti t0 &lt; ti || t0 &gt; ts # Não rejeita H0 ## [1] FALSE ## p-valor p_valor &lt;- 2*pt(abs(t0), df = n-1, lower.tail = F) ## No R: t.test(tempos, mu = 3, alternative = &quot;two.sided&quot;, conf.level = 1-alpha) ## ## One Sample t-test ## ## data: tempos ## t = 2.1169, df = 9, p-value = 0.06335 ## alternative hypothesis: true mean is not equal to 3 ## 95 percent confidence interval: ## 2.980104 3.599896 ## sample estimates: ## mean of x ## 3.29 Conclusão: Como p-valor &gt; 5%, não rejeitamos H₀. Existem evidências amostrais de que o tempo médio diário gasto em redes sociais pelos estudantes é de 3h. Exercícios 1. Um estudo afirma que o escore médio de ansiedade de jovens universitários (medido por um questionário validado) é 40 pontos. Um psicólogo deseja verificar se, em sua universidade, os estudantes apresentam um nível diferente de ansiedade. scores &lt;- c(43, 39, 45, 41, 38, 42, 46, 40, 44, 43, 47, 41) a. Calcule o intervalo de confiança de 95% para a média do escore de ansiedade. b. Teste as hipóteses (Use α = 0,05): H₀: μ = 40 H₁: μ ≠ 40 2. Estudos indicam que jovens usam o celular por cerca de 5 horas diárias. Um pesquisador quer saber se esse valor aumentou com a popularização dos vídeos curtos. horas &lt;- c(5.2, 5.5, 6.1, 5.8, 6.4, 6.0, 5.7, 5.9, 6.3, 5.6) a. Calcule o intervalo de confiança de 95% para o tempo médio diário de uso. b. Teste as hipóteses (Use α = 0,05): H₀: μ ≤ 5 H₁: μ &gt; 5 3. Em uma escala de 0 a 10, a média nacional de satisfação com o ensino remoto foi 6. Um professor quer saber se seus alunos estão mais satisfeitos que a média nacional. notas &lt;- c(6.5, 7.2, 7.0, 6.8, 7.5, 7.1, 6.9, 7.3) a. Estime o IC de 90% para a média de satisfação dos alunos. b. Teste as hipóteses (Use α = 0,10): H₀: μ ≤ 6 H₁: μ &gt; 6 Respostas library(DescTools) ## 1. # a. scores &lt;- c(43, 39, 45, 41, 38, 42, 46, 40, 44, 43, 47, 41) alpha = 0.05 n &lt;- length(scores) # Intervalo de confiança de 95% MeanCI(scores, conf.level = 1-alpha) # ou Li &lt;- mean(scores) - qt(1-alpha/2, df = n-1)*sd(scores)/sqrt(n) Ls &lt;- mean(scores) + qt(1-alpha/2, df = n-1)*sd(scores)/sqrt(n) # b. # Estatística Teste mu0 &lt;- 40 t0 &lt;- (mean(scores) - mu0)/(sd(scores)/sqrt(n)) # p-valor p_valor &lt;- 2*pt(abs(t0), df = n-1, lower.tail = F) # No R: t.test(scores, mu = mu0, alternative = &quot;two.sided&quot;, conf.level = 1-alpha) ## 2. # a. horas &lt;- c(5.2, 5.5, 6.1, 5.8, 6.4, 6.0, 5.7, 5.9, 6.3, 5.6) alpha = 0.05 n &lt;- length(horas) # Intervalo de confiança de 95% MeanCI(horas, conf.level = 1-alpha) # ou Li &lt;- mean(horas) - qt(1-alpha/2, df = n-1)*sd(horas)/sqrt(n) Ls &lt;- mean(horas) + qt(1-alpha/2, df = n-1)*sd(horas)/sqrt(n) # b. # Estatística Teste mu0 &lt;- 5 t0 &lt;- (mean(horas) - mu0)/(sd(horas)/sqrt(n)) # p-valor p_valor &lt;- pt(t0, df = n-1, lower.tail = F) # No R: t.test(horas, mu = mu0, alternative = &quot;greater&quot;, conf.level = 1-alpha) ## 3. # a. notas &lt;- c(6.5, 7.2, 7.0, 6.8, 7.5, 7.1, 6.9, 7.3) alpha = 0.10 n &lt;- length(notas) # Intervalo de confiança de 95% MeanCI(notas, conf.level = 1-alpha) # ou Li &lt;- mean(notas) - qt(1-alpha/2, df = n-1)*sd(notas)/sqrt(n) Ls &lt;- mean(notas) + qt(1-alpha/2, df = n-1)*sd(notas)/sqrt(n) c(Li,Ls) # b. # Estatística Teste mu0 &lt;- 5 t0 &lt;- (mean(notas) - mu0)/(sd(notas)/sqrt(n)) # p-valor p_valor &lt;- pt(t0, df = n-1, lower.tail = F) # No R: t.test(notas, mu = mu0, alternative = &quot;greater&quot;, conf.level = 1-alpha) Acesso Professor 5.4 Exercícios do Capítulo 5 (Entregar na lista 1) Considerando o conjunto de dados a seguir, apresente as funções no R necessárias para os cálculos dos itens solicitados: a. Transforme as variáveis Curso e Genero em fatores cujos níveis são ordenados (em ordem decrescente) pela frequência. b. Construa uma tabela de frequências absoluta, relativa e absoluta acumulada para a variável Curso. Faça o mesmo para a variável Gênero. c. Construa uma tabela de frequências absoluta, relativa e absoluta acumulada (com classes) para a variável Tempo_Estudo. Considere classes iniciando em 6, com amplitude intervalar 4. d. Calcule: média, mediana, variância, desvio padrão e coeficiente de variação para as variáveis Tempo_Estudo e Nota_Final. e. Construa os gráficos a seguir (coloridos e com nomes nos eixos): Histograma (com densidades no eixo das ordenadas e amplitude do item (c)) para a variável Tempo_Estudo. Boxplot para a variável Tempo_Estudo por Curso. Gráficos de barras para as variáveis Curso e Genero. Diagrama de dispersão entre as variáveis Tempo_Estudo e Nota_Final. f. Estime os intervalos de confiança de 95% para as médias de: Tempo_Estudo e Nota_Final. g. Teste as hipóteses (com conclusão) para o tempo médio de estudo (Use α = 0.05): H₀: μ = 12 H₁: μ ≠ 12 h. Teste as hipóteses (com conclusão) para o nota média final (Use α = 0.05): H₀: μ ≤ 6.5 H₁: μ &gt; 6.5 i. Interprete os principais resultados observados nas analises anteriores. Table 5.2: Conjunto de Dados Simulado ID Curso Genero Tempo_Estudo Nota_Final 1 FI M 12 7.5 2 SI M 10 6.8 3 FI F 15 8.0 4 SI M 8 6.2 5 EC M 20 9.1 6 EC M 11 7.2 7 EC M 7 5.5 8 SI F 18 8.8 9 EC M 13 7.0 10 FI F 9 6.4 11 SI M 16 8.0 12 SI F 17 8.5 Legenda: SI = Sistemas de Informação EC = Engenharia da Computação FI = Física "],["gráficos-e-visualização-de-dados.html", "Capítulo 6 Gráficos e visualização de dados 6.1 Gráficos básicos com graphics 6.2 Gráficos com ggplot2 6.3 Gráficos Interativos com plotly", " Capítulo 6 Gráficos e visualização de dados A visualização de dados é fundamental na análise estatística, permite visualizar relações e padrões que podem ser relevantes para o conjunto de dados. 6.1 Gráficos básicos com graphics Considere os dados mtcars. 1. plot(): Dispersão, linhas, etc. plot(x = mtcars$wt, y = mtcars$mpg, # dados main = &quot;Consumo vs Peso&quot;, # título principal xlab = &quot;Peso do carro&quot;, ylab = &quot;MPG&quot;, # rótulos dos eixos col = &quot;blue&quot;, pch = 19, cex = 1.2) # cor, tipo e tamanho dos pontos type = “p” (pontos), “l” (linhas), “b” (pontos + linhas), “n” (nada) pch = símbolo do ponto (1 a 25 ou letras, ex: “*“), cex = tamanho col = cor, aceita nomes ou códigos hexadecimais 2. hist(): Histograma hist(mtcars$mpg, main = &quot;Distribuição de MPG&quot;, xlab = &quot;MPG&quot;, col = &quot;lightblue&quot;, border = &quot;white&quot;, breaks = 10) breaks: número de bins freq = FALSE: mostra densidade em vez de contagem 3. boxplot(): Boxplots boxplot(mpg ~ cyl, data = mtcars, main = &quot;MPG por número de cilindros&quot;, xlab = &quot;Cilindros&quot;, ylab = &quot;MPG&quot;, col = c(&quot;lightgreen&quot;, &quot;lightblue&quot;, &quot;pink&quot;)) Fórmulas permitem separar por grupos Pode usar horizontal = TRUE 4. barplot(): Barras counts &lt;- table(mtcars$cyl) barplot(counts, main = &quot;Frequência de Cilindros&quot;, col = &quot;orange&quot;, border = NA) Também aceita valores contínuos Pode usar horiz = TRUE para barras horizontais Personalizações gerais: Títulos e eixos main, sub, xlab, ylab: título principal, subtítulo, rótulos dos eixos xlim, ylim: limites dos eixos, ex: xlim = c(0, 10) axes = FALSE: remove eixos (útil para desenhar personalizados com axis()) Cores e símbolos col: cor dos pontos, barras, etc. pch: tipo de ponto (0 a 25), também pode usar “*” ou “+” cex: tamanho do símbolo lty, lwd: tipo e espessura de linha Funções auxiliares úteis abline(h = …) ou abline(v = …): adiciona linhas horizontais/verticais text(x, y, labels): adiciona texto manualmente legend(“topright”, legend = …, col = …, pch = …): adiciona legenda par(mfrow = c(2,2)): permite múltiplos gráficos em uma janela Exemplo: par(mfrow = c(2, 2)) # 2x2 gráficos plot(mtcars$wt, mtcars$mpg, main = &quot;MPG vs Peso&quot;, xlab = &quot;Peso&quot;, ylab = &quot;MPG&quot;, col = &quot;darkgreen&quot;, pch = 16) hist(mtcars$mpg, main = &quot;Histograma de MPG&quot;, freq = F, breaks = 5, col = &quot;lightblue&quot;) boxplot(mpg ~ cyl, data = mtcars, main = &quot;MPG por cilindros&quot;, col = &quot;lightgreen&quot;, horizontal = T) barplot(table(mtcars$gear), main = &quot;Contagem de marchas&quot;, col = &quot;salmon&quot;, horiz = T) Exemplo: # Dados de exemplo x &lt;- mtcars$wt # peso y &lt;- mtcars$mpg # milhas por galão # Gráfico básico com várias personalizações plot(x, y, type = &quot;p&quot;, # tipo de gráfico: pontos main = &quot;MPG vs Peso do carro&quot;, # título principal sub = &quot;Dados do conjunto mtcars&quot;, # subtítulo xlab = &quot;Peso (1000 lbs)&quot;, # rótulo do eixo x ylab = &quot;Milhas por galão (MPG)&quot;, # rótulo do eixo y xlim = c(1.5, 5.5), # limites do eixo x ylim = c(10, 35), # limites do eixo y col = &quot;blue&quot;, pch = 19, cex = 1.2, # cor, tipo e tamanho dos pontos axes = FALSE # remove eixos para desenhar manualmente ) # Adicionando eixos personalizados axis(1, at = seq(2, 5, by = 0.5)) # eixo x com marcações axis(2, las = 1) # eixo y com rótulos na horizontal # O eixo é colocado da seguinte forma: # 1=abaixo, 2=esquerda, 3=acima e 4=direita. box() # desenha a caixa ao redor do gráfico # Adicionando linhas de referência abline(h = 20, col = &quot;red&quot;, lty = 2, lwd = 2) # linha horizontal em y = 20 abline(v = 3.5, col = &quot;darkgreen&quot;, lty = 3, lwd = 2) # linha vertical # Adicionando texto no gráfico text(x = 3.8, y = 33, labels = &quot;Alto consumo&quot;, col = &quot;purple&quot;, cex = 0.9) # Adicionando legenda legend(&quot;topright&quot;, legend = c(&quot;Carros&quot;, &quot;MPG = 20&quot;, &quot;Peso = 3.5&quot;), col = c(&quot;blue&quot;, &quot;red&quot;, &quot;darkgreen&quot;), pch = c(19, NA, NA), lty = c(NA, 2, 3), lwd = c(NA, 2, 2), bty = &quot;n&quot;) # sem borda na legenda Exercícios 1. Considerando o conjunto de dados mtcars disponível no R, crie um gráfico de dispersão entre wt (peso) e mpg (milhas por galão) do dataset mtcars, com os seguintes elementos: Título: “Relação entre peso e consumo” Eixo X: “Peso (1000 lbs)” Eixo Y: “Consumo (milhas/galão)” 2. Utilize o mesmo gráfico do exercício anterior, mas agora: Defina os limites do eixo X entre 1 e 6 Defina os limites do eixo Y entre 10 e 35 Use pch = 16 para pontos preenchidos Desative os eixos automáticos e crie eixos personalizados com axis() 3. Usando o mesmo gráfico do exercício anterior, mas agora: Adicione uma linha horizontal em mpg = 20 Adicione uma linha vertical em wt = 3 4. Ainda no gráfico anterior: Adicione o nome dos carros ao lado dos pontos com text() Use pos = 4 para colocar o texto à direita dos pontos 5. Crie um gráfico de dispersão entre hp (potência) e mpg, com: Cores diferentes para carros com 4, 6 e 8 cilindros (use cyl) Uma legenda explicando as cores Título: “Consumo vs Potência por número de cilindros” 6. Crie uma visualização com 4 gráficos diferentes em uma janela 2x2: plot(mpg ~ wt) hist(mtcars$mpg) boxplot(mpg ~ cyl) plot(density(mtcars$mpg)) Respostas ## 1. plot(mtcars$wt, mtcars$mpg, main = &quot;Relação entre peso e consumo&quot;, xlab = &quot;Peso (1000 lbs)&quot;, ylab = &quot;Consumo (milhas/galão)&quot;) ## 2. plot(mtcars$wt, mtcars$mpg, xlim = c(1, 6), ylim = c(10, 35), pch = 16, axes = FALSE, # remove eixos automáticos xlab = &quot;Peso&quot;, ylab = &quot;Consumo&quot;, main = &quot;Eixos personalizados&quot;) # Eixo inferior (x) axis(1, at = seq(1, 6, by = 1)) # Eixo esquerdo (y) axis(2, at = seq(10, 35, by = 5)) # Caixa ao redor do gráfico box() ## 3. plot(mtcars$wt, mtcars$mpg, pch = 16, xlab = &quot;Peso&quot;, ylab = &quot;Consumo&quot;, main = &quot;Linhas de referência&quot;) # Linha horizontal em mpg = 20 abline(h = 20, col = &quot;red&quot;, lty = 2) # Linha vertical em wt = 3 abline(v = 3, col = &quot;darkgreen&quot;, lty = 2) ## 4. plot(mtcars$wt, mtcars$mpg, pch = 16, xlab = &quot;Peso&quot;, ylab = &quot;Consumo&quot;, main = &quot;Identificando os carros&quot;) text(mtcars$wt, mtcars$mpg, labels = rownames(mtcars), pos = 4, cex = 0.7) # pos = 4 coloca à direita ## 5. # Criar vetor de cores com base nos cilindros cores &lt;- ifelse(mtcars$cyl == 4, &quot;blue&quot;, ifelse(mtcars$cyl == 6, &quot;green&quot;, &quot;red&quot;)) plot(mtcars$hp, mtcars$mpg, col = cores, pch = 16, xlab = &quot;Potência (hp)&quot;, ylab = &quot;Consumo (mpg)&quot;, main = &quot;Consumo vs Potência por número de cilindros&quot;) legend(&quot;topright&quot;, legend = c(&quot;4 cilindros&quot;, &quot;6 cilindros&quot;, &quot;8 cilindros&quot;), col = c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;), pch = 16) ## 6. par(mfrow = c(2, 2)) # layout 2x2 plot(mtcars$wt, mtcars$mpg) hist(mtcars$mpg) boxplot(mpg ~ cyl, data = mtcars) plot(density(mtcars$mpg)) Acesso Professor 6.2 Gráficos com ggplot2 É um pacote muito usado em visualizações gráficas em estatística. Possibilita construir os gráficos de maneira modular, combinando diferentes camadas e componentes. Conceitos básicos do ggplot2: 1. Camadas (layers): o gráfico é feito em camadas — primeiro define os dados e os eixos, depois adiciona geometrias, escalas, temas, entre outros. 2. Gramática dos Gráficos: Dados (data) Mapeamentos estéticos (aes, de aesthetics): relacionam variáveis aos elementos visuais do gráfico (eixo x, y, cor, tamanho, etc.) Geometrias (geom_*): definem o tipo de gráfico, como pontos, barras, linhas, boxplots, etc. Opcionais: Temas (theme): ajustam a aparência visual; Rótulos (labs): define títulos, rótulos e legendas; Facetas (facet_*): permitem dividir os dados em subgráficos. Estrutura geral: ggplot(data, aes(...)) + → base e mapeamento geom_*() + → tipo de gráfico theme_*() ou + labs() → (opcional) ajustes de estilo Para carregar o pacote: library(ggplot2) Exemplo de gráficos com diferentes geometrias: ## Gráfico de dispersão: ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_point() # aes() define os eixos x e y (aqui: wt e mpg) # geom_point() desenha os pontos ## Gráfico de linhas: ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_line() # geom_line() conecta os pontos com uma linha ## Histograma: ggplot(data = mtcars, aes(x = mpg)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # geom_histogram() faz um histograma ## Gráfico de barras: ggplot(data = mtcars, aes(x = as.factor(cyl))) + geom_bar() # x = as.factor(cyl): transforma os números de cilindros em categorias # geom_bar(): conta quantas vezes cada valor aparece # (por padrão, usa stat = &quot;count&quot;) ## Boxplot: # para uma variável ggplot(data = mtcars, aes(y = mpg)) + geom_boxplot() # considerando grupos ggplot(data = mtcars, aes(x = as.factor(cyl), y = mpg)) + geom_boxplot() # as.factor(cyl) transforma o número de cilindros em categorias # geom_boxplot() mostra distribuição de valores Personalizações adicionais: 1. Cores, formato, tamanho, transparência ## Gráfico de dispersão: ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_point(alpha = 0.8, shape = 22, color = &quot;red&quot;, fill = &quot;blue&quot;, size = 4) # alpha -&gt; transparencia: valor de 0 a 1 # shape -&gt; formato do ponto: valor de 0 a 25 # color -&gt; cor dos pontos (ou borda, se for o caso) # fill -&gt; cor do interior do ponto. Formas que aceitam fill: shape 21 a 25 # size -&gt; tamanho dos pontos # Gráfico de linhas: ggplot(mtcars, aes(x = wt, y = mpg)) + geom_line(color = &quot;blue&quot;, size = 1.2, linetype = &quot;dashed&quot;) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. # color: cor da linha (&quot;blue&quot;, &quot;red&quot;, etc.) # size: espessura da linha # linetype: tipo da linha (&quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, # &quot;dotdash&quot;, &quot;longdash&quot;, etc.) # Gráfico de histograma: ggplot(mtcars, aes(x = mpg)) + geom_histogram(fill = &quot;skyblue&quot;, color = &quot;black&quot;, alpha = 0.7, binwidth = 5) # fill: cor de preenchimento das barras # color: cor da borda das barras # alpha: transparência (0 a 1) # binwidth: largura de cada barra # Gráfico de barras: ggplot(mtcars, aes(x = as.factor(cyl))) + geom_bar(fill = &quot;lightsalmon&quot;, color = &quot;black&quot;, width = 0.7) # fill: cor do interior das barras # color: borda das barras # width: largura das barras # Gráfico Boxplot: ggplot(data = mtcars, aes(x = as.factor(cyl), y = mpg)) + geom_boxplot(alpha = 0.7, size = 1, fill = &quot;skyblue&quot;, color = &quot;darkblue&quot;, outlier.color = &quot;red&quot;, outlier.shape = 21, outlier.fill = &quot;yellow&quot;, outlier.size = 3, outlier.stroke = 1.5) # alpha -&gt; transparencia: valor de 0 a 1 (0 = transparente, 1 = opaco). # size -&gt; espessura das bordas # fill = &quot;skyblue&quot; -&gt; Cor de preenchimento da caixa. # color = &quot;darkblue&quot; -&gt; Cor da borda do boxplot. # outlier.color = &quot;red&quot; -&gt; Cor da borda dos outliers. # outlier.shape = 21 -&gt; Formato dos pontos outliers. # Formas de 21 a 25 aceitam fill. # outlier.fill = &quot;yellow&quot; -&gt; Cor do interior dos outliers # (se outlier.shape permite fill). # outlier.size = 3 Tamanho dos pontos outliers. # outlier.stroke = espessura das bordas dos outliers ## Outros tipos de cores podem ser encontradas em colors(). Cores variando conforme os grupos: ## Cores do preenchimento variando conforme os grupos: fill ggplot(mtcars, aes(x = wt, y = mpg, fill = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, color = &quot;darkblue&quot;) # fill = as.factor(cyl): cores do interior das caixas # variam conforme as categorias de cilindros ## Cores das bordas variando conforme os grupos: color ggplot(mtcars, aes(x = factor(cyl), y = mpg, color = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, fill = &quot;white&quot;) # color = as.factor(cyl): cores das bordas das caixas # variam conforme as categorias de cilindros Para controlar manualmente as cores associadas aos grupos (categorias), podemos usar scale_fill_manual() para o fill e scale_color_manual() para o color. Isso vale para formas preenchíveis, como boxplots, barras, pontos com shape 21–25, etc. ## Cores do preenchimento manuais variando conforme os grupos: fill ggplot(mtcars, aes(x = wt, y = mpg, fill = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, color = &quot;darkblue&quot;) + scale_fill_manual(values = c(&quot;4&quot; = &quot;lightgreen&quot;, &quot;6&quot; = &quot;lightblue&quot;, &quot;8&quot; = &quot;pink&quot;)) # scale_fill_manual() → define manualmente as cores do interior. ## Cores das bordas manuais variando conforme os grupos: color ggplot(mtcars, aes(x = factor(cyl), y = mpg, color = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, fill = &quot;white&quot;) + scale_color_manual(values = c(&quot;4&quot; = &quot;darkgreen&quot;, &quot;6&quot; = &quot;steelblue&quot;, &quot;8&quot; = &quot;darkred&quot;)) # scale_color_manual() → define manualmente as cores das bordas. 2. Legendas, rótulos e limites Com o scale_fill_manual() e o scale_color_manual(), podemos modificar também as informações das legendas. ggplot(mtcars, aes(x = wt, y = mpg, fill = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, color = &quot;darkblue&quot;) + scale_fill_manual( values = c(&quot;4&quot; = &quot;lightgreen&quot;, &quot;6&quot; = &quot;lightblue&quot;, &quot;8&quot; = &quot;pink&quot;), labels = c(&quot;4 cilindros&quot;, &quot;6 cilindros&quot;, &quot;8 cilindros&quot;), name = &quot;Categorias de cilindros&quot; ) ggplot(mtcars, aes(x = factor(cyl), y = mpg, color = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, fill = &quot;white&quot;) + scale_color_manual( values = c(&quot;4&quot; = &quot;lightgreen&quot;, &quot;6&quot; = &quot;lightblue&quot;, &quot;8&quot; = &quot;pink&quot;), labels = c(&quot;4 cilindros&quot;, &quot;6 cilindros&quot;, &quot;8 cilindros&quot;), name = &quot;Categorias de cilindros&quot; ) Para modificar rótulos, nomes de títulos e nomes dos eixos, podemos utilizar a função labs(). Já para modificar valores minimos e maximos dos eixos, usamos xlim() e ylim(). ## Gráfico de dispersão: ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_point(alpha = 0.8, shape = 22, color = &quot;red&quot;, fill = &quot;blue&quot;, size = 4) + labs( title = &quot;Relação entre peso e consumo de combustível&quot;, subtitle = &quot;Dados do dataset mtcars&quot;, x = &quot;Peso do carro (1000 lbs)&quot;, y = &quot;Milhas por galão (mpg)&quot;, caption = &quot;Fonte: Motor Trend US magazine (1974)&quot; ) + xlim(1, 6) + ylim(10, 35) # labs() possibilita adicionar: # - title: título do gráfico # - subtitle: subtítulo # - x, y: rótulos dos eixos # - caption: legenda inferior (útil para fonte ou nota) # xlim() e ylim() -&gt; Definem os limites visuais dos eixos x e y. # Dados fora desses limites são cortados 3. Temas: Para persoalizar temas, podemos usar theme_*() ou theme(). theme_*(): Funções predefinidas para aplicar temas específicos, com ajustes padrão. Você escolhe um tema e aplica com um único comando. Aplicam um conjunto pré-definido de estilos para o gráfico, como fundo, eixos, grid, etc. theme(): Permite personalizações detalhadas e específicas, configurando cada elemento do gráfico individualmente. Exemplo: Usando theme_*() ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_point(alpha = 0.8, shape = 22, color = &quot;red&quot;, fill = &quot;blue&quot;, size = 4) + labs( title = &quot;Relação entre peso e consumo de combustível&quot;, subtitle = &quot;Dados do dataset mtcars&quot;, x = &quot;Peso do carro (1000 lbs)&quot;, y = &quot;Milhas por galão (mpg)&quot;, caption = &quot;Fonte: Motor Trend US magazine (1974)&quot; ) + xlim(1, 6) + ylim(10, 35) + theme_minimal() Você pode substituir theme_minimal() por qualquer uma destas funções para estilos diferentes: Tema Estilo theme_gray() Padrão do ggplot2 (cinza claro com grade branca) theme_bw() Fundo branco com linhas de grade theme_minimal() Visual leve, sem bordas e poucas linhas theme_classic() Fundo branco com eixos e borda, sem grade theme_void() Quase tudo removido (bom para mapas, logos, etc.) theme_light() Semelhante ao bw(), mas mais suave theme_dark() Fundo escuro com texto claro Exemplo: Usando theme() ggplot(mtcars, aes(x = factor(cyl), y = mpg, color = as.factor(cyl))) + geom_boxplot(alpha = 0.7, size = 1, fill = &quot;white&quot;) + labs( title = &quot;Boxplot do mpg por valor de cyl&quot;, x = &quot;cyl&quot;, y = &quot;Milhas por galão (mpg)&quot; ) + scale_color_manual( values = c(&quot;4&quot; = &quot;lightgreen&quot;, &quot;6&quot; = &quot;lightblue&quot;, &quot;8&quot; = &quot;pink&quot;), labels = c(&quot;4 cilindros&quot;, &quot;6 cilindros&quot;, &quot;8 cilindros&quot;), name = &quot;Categorias de cilindros&quot; ) + theme_minimal() + theme( plot.title = element_text(size = 16, face = &quot;bold&quot;, color = &quot;darkblue&quot;), axis.title = element_text(size = 12, color = &quot;darkblue&quot;), axis.text = element_text(size = 12, color = &quot;darkblue&quot;) ) # - plot.title = element_text(size = 16, face = &quot;bold&quot;): # Altera o título do gráfico: tamanho da fonte (size = 16) # e o estilo como negrito (face = &quot;bold&quot;). # - axis.text = element_text(size = 14, color = &quot;darkblue&quot;): # Muda o tamanho e a cor dos números dos eixos (x e y). # panel.grid.major = element_line(color = &quot;gray90&quot;) # Altera a cor das linhas principais da grade (linhas de referência horizontais e verticais). Outras personalizações podem ser encontradas em: help(theme). Exemplo: Gráfico ggplot com várias personalizações # Dados base dados &lt;- mtcars # Gráfico ggplot ggplot(dados, aes(x = wt, y = mpg)) + # Pontos geom_point(color = &quot;blue&quot;, size = 3) + # Linha horizontal de referência (y = 20) geom_hline(yintercept = 20, color = &quot;red&quot;, linetype = &quot;dashed&quot;, linewidth = 1) + # Linha vertical de referência (x = 3.5) geom_vline(xintercept = 3.5, color = &quot;darkgreen&quot;, linetype = &quot;dotted&quot;, linewidth = 1) + # Texto anotativo annotate(&quot;text&quot;, x = 3.8, y = 33, label = &quot;Alto consumo&quot;, color = &quot;purple&quot;, size = 4) + # Limites dos eixos xlim(1.5, 5.5) + ylim(10, 35) + # Títulos e rótulos labs( title = &quot;MPG vs Peso do carro&quot;, subtitle = &quot;Dados do conjunto mtcars&quot;, x = &quot;Peso (1000 lbs)&quot;, y = &quot;Milhas por galão (MPG)&quot;, caption = &quot;Fonte: mtcars&quot; ) + # Tema para ajustar aparência geral theme_minimal() + theme( plot.title = element_text(face = &quot;bold&quot;, size = 14), axis.title = element_text(size = 12) ) Exercícios Considere o conjunto de dados mpg do pacote ggplot2. 1. Crie um gráfico de dispersão com geom_point() mostrando a relação entre displ (cilindrada) e hwy (consumo em estrada). Adicione título e rótulos aos eixos. Use tamanho 3 e cor azul para os pontos. Use o tema theme_minimal(). 2. Considerando novamente o gráfico de dispersão anterior: Faça com que a cor dos pontos varie conforme a variável class. Aumente o tamanho dos pontos para 4 e reduza a sua opacidade para 0.5 (alpha) 3. Considerando novamente o gráfico de dispersão anterior: Faça com que a cor dos pontos varie conforme a variável class. Use uma paleta manual de cores com scale_color_manual() com pelo menos 3 cores distintas. 4. Considerando novamente o gráfico de dispersão anterior: Adicione uma linha horizontal em hwy = 25 e uma linha vertical em displ = 4 (ambas devem ser tracejadas e vermelhas) Um texto no canto superior direito dizendo “Meta de eficiência” Limite o eixo X entre 2 e 6 Limite o eixo Y entre 15 e 40 5. Crie um gráfico de barras com a contagem de carros por class. Use fill = class para mudar a cor de preenchimento das barras. Mude manualmente as cores de preenchimento com scale_fill_manual(). Remova a legenda e use o tema theme_bw(). 6. Crie um boxplot de hwy por class. Use fill = class e color = drv para mostrar grupos diferentes. Personalize com scale_fill_manual() e scale_color_manual(). Respostas library(ggplot2) ## 1. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(color = &quot;blue&quot;, size = 3) + labs( title = &quot;Relação entre Cilindrada e Consumo&quot;, x = &quot;Cilindrada (litros)&quot;, y = &quot;Consumo na estrada (mpg)&quot; ) + theme_minimal() ## 2. ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point(size = 4, alpha = 0.5) + theme_light() ## 3. cl &lt;- colors() # vetor de cores ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point(size = 3) + scale_color_manual(values = cl[2:8]) + # scale_color_manual(values = c(&quot;suv&quot; = &quot;red&quot;, &quot;compact&quot; = &quot;blue&quot;, &quot;midsize&quot; = &quot;green&quot;)) + theme_minimal() ## 4. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_hline(yintercept = 25, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + geom_vline(xintercept = 4, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + annotate(&quot;text&quot;, x = 5.5, y = 40, label = &quot;Meta de eficiência&quot;, size = 4, fontface = &quot;bold&quot;) + # annotate(&quot;segment&quot;, x = 5.5, y = 38, xend = 3, yend = 35, arrow = arrow(length = unit(0.2, &quot;cm&quot;)), color = &quot;blue&quot;) + xlim(2, 6) + ylim(15, 40) + theme_classic() ## 5. ggplot(mpg, aes(x = class, fill = class)) + geom_bar() + scale_fill_manual(values = c(&quot;suv&quot; = &quot;darkred&quot;, &quot;compact&quot; = &quot;skyblue&quot;, &quot;midsize&quot; = &quot;darkgreen&quot;, &quot;pickup&quot; = &quot;orange&quot;, &quot;subcompact&quot; = &quot;purple&quot;, &quot;2seater&quot; = &quot;pink&quot;)) + guides(fill = &quot;none&quot;) + # Remove legenda theme_bw() ## 6. ggplot(mpg, aes(x = class, y = hwy, fill = class, color = drv)) + geom_boxplot() + scale_fill_manual(values = c(&quot;suv&quot; = &quot;darkred&quot;, &quot;compact&quot; = &quot;skyblue&quot;, &quot;midsize&quot; = &quot;darkgreen&quot;, &quot;pickup&quot; = &quot;orange&quot;, &quot;subcompact&quot; = &quot;purple&quot;, &quot;2seater&quot; = &quot;pink&quot;)) + scale_color_manual(values = c(&quot;f&quot; = &quot;black&quot;, &quot;r&quot; = &quot;red&quot;, &quot;4&quot; = &quot;blue&quot;)) + theme_minimal() Acesso Professor 6.3 Gráficos Interativos com plotly O plotly é um pacote que transforma gráficos em interativos. Ele possibilita: transformar gráficos ggplot em interativos criar gráficos interativos Alguns de seus recursos: observar os valores do gráfico com o mouse, dar zoom, arrastar, girar imagens 3D, exportar. Primeiramente instalar e carregar o pacote: # install.packages(&quot;plotly&quot;) library(plotly) Transformar um gráfico ggplot2 em interativo library(ggplot2) library(plotly) # Gráfico com ggplot2 p &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point() # Tornar interativo ggplotly(p) Recursos: desmarcar itens da legenda download do gráfico zoom em uma região específica arrastar o gráfico caixa de seleção laço de seleção resetar eixos mostrar os dados mais próximos ao passar o mouse comparar dados ao passar o mouse Criando gráficos diretamente com plot_ly() ## Gráfico de dispersão: plot_ly(data = mtcars, x = ~wt, y = ~mpg, type = &quot;scatter&quot;, mode = &quot;markers&quot;) # type = &quot;scatter&quot; → gráfico de dispersão # mode = &quot;markers&quot; → só pontos (sem linhas) ## Gráfico de linhas plot_ly(data = economics, x = ~date, y = ~unemploy, type = &quot;scatter&quot;, mode = &quot;lines&quot;) # mode = &quot;lines&quot;: só linhas ## Gráfico de linhas + pontos plot_ly(data = economics, x = ~date, y = ~unemploy, type = &quot;scatter&quot;, mode = &quot;lines+markers&quot;) ## Gráfico de barras # Contagem das frequencias # library(dplyr) df_contagem &lt;- mpg %&gt;% count(class) # Gráfico com as contagens plot_ly(data = df_contagem, x = ~class, y = ~n, type = &quot;bar&quot;) # type = &quot;bar&quot;: gráfico de barras verticais # x = ~class: mostra a frequência de cada tipo de carro ## Histograma - com frequencias plot_ly(data = mpg, x = ~hwy, type = &quot;histogram&quot;) # type = &quot;histogram&quot;: conta quantos valores caem em cada faixa de hwy # x = ~hwy: cria histograma da variável hwy (consumo em estrada) ## Histograma - com densidades plot_ly(data = mpg, x = ~hwy, type = &quot;histogram&quot;, histnorm = &quot;probability density&quot;, xbins = list(size = 5)) # histnorm = &quot;probability density&quot; Normaliza a altura das barras para representar densidade (área = 1) # xbins = list(size = 2) Define a amplitude dos intervalos (ex: de 2 em 2 unidades) ## Boxplot plot_ly(data = mpg, x = ~class, y = ~hwy, type = &quot;box&quot;) # type = &quot;box&quot;: boxplot (mediana, quartis, outliers) Personalizações comuns: # Cores automáticas por grupo: color = ~class # Título e rótulos: layout(title = &quot;Meu gráfico&quot;, xaxis = list(title = &quot;Eixo X&quot;), yaxis = list(title = &quot;Eixo Y&quot;)) # Texto ao passar o mouse: text = ~paste(&quot;MPG:&quot;, mpg), hoverinfo = &quot;text&quot; Exemplo: gráfico de dispersão com personalizações library(plotly) # Usando o dataset mpg plot_ly(data = mpg, x = ~displ, # eixo X: cilindrada y = ~hwy, # eixo Y: consumo na estrada type = &quot;scatter&quot;, # gráfico de dispersão mode = &quot;markers&quot;, # só pontos color = ~class, # cor por tipo de carro text = ~paste(&quot;Classe:&quot;, class, &quot;&lt;br&gt;Cilindrada:&quot;, displ, &quot;&lt;br&gt;Consumo (hwy):&quot;, hwy), # texto ao passar o mouse hoverinfo = &quot;text&quot; # mostra só o texto definido ) %&gt;% layout(title = &quot;Cilindrada vs Consumo (Estrada)&quot;, xaxis = list(title = &quot;Cilindrada (litros)&quot;), yaxis = list(title = &quot;Consumo na estrada (MPG)&quot;)) # color = ~class → as cores dos pontos mudam conforme o tipo de carro # text = ~paste(...) + hoverinfo = &quot;text&quot; → personaliza o texto exibido no tooltip # layout() → define o título do gráfico e os nomes dos eixos Exercícios 1. Usando o pacote plotly e o dataset iris, crie: Um gráfico de dispersão entre Sepal.Length e Petal.Length. Personalize com: (1) Cores dos pontos por Species; (2) Texto ao passar o mouse nos pontos com valores de todas as variáveis; (3) Título e rótulos dos eixos. Um gráfico de barras das frequências de Species. Personalize com: (1) Cores por Species; (2) Rótulos e título. Um histograma da variável Sepal.Width. Personalize com: (1) Densidades no eixo das ordenadas; (2) Amplitude dos intervalos de 0.5; (3) Rótulos nos eixos. Boxplots da variável Sepal.Width por Species. Personalize com: (1) Cores por Species; (2) Rótulos e título. 2. Usando o pacote plotly e o dataset airquality, plote o gráfico de linhas da variação da temperatura (Temp) ao longo dos dias (Day) no mês de maio. Personalize com: (1) Modo = “lines+markers”; (2) Título: “Temperatura em maio”; (3) Rótulos dos eixos. Respostas ## 1. Dataset iris # a. Gráfico de dispersão entre `Sepal.Length` e `Petal.Length` library(plotly) plot_ly(data = iris, x = ~Sepal.Length, y = ~Petal.Length, type = &quot;scatter&quot;, mode = &quot;markers&quot;, color = ~Species, text = ~paste(&quot;Espécie:&quot;, Species, &quot;&lt;br&gt;Sépala (comp.):&quot;, Sepal.Length, &quot;&lt;br&gt;Sépala (larg.):&quot;, Sepal.Width, &quot;&lt;br&gt;Pétala (comp.):&quot;, Petal.Length, &quot;&lt;br&gt;Pétala (larg.):&quot;, Petal.Width), hoverinfo = &quot;text&quot;) %&gt;% layout(title = &quot;Dispersão: Sépala vs. Pétala&quot;, xaxis = list(title = &quot;Comprimento da Sépala&quot;), yaxis = list(title = &quot;Comprimento da Pétala&quot;)) # b. Gráfico de barras das frequências de Species df_barras &lt;- iris %&gt;% count(Species) plot_ly(data = df_barras, x = ~Species, y = ~n, type = &quot;bar&quot;, color = ~Species) %&gt;% layout(title = &quot;Frequência das Espécies de Íris&quot;, xaxis = list(title = &quot;Espécie&quot;), yaxis = list(title = &quot;Contagem&quot;)) # c. Histograma de Sepal.Width com densidade e amplitude de 0.2 plot_ly(data = iris, x = ~Sepal.Width, type = &quot;histogram&quot;, histnorm = &quot;probability density&quot;, xbins = list(size = 0.5)) %&gt;% layout(title = &quot;Distribuição da Largura da Sépala&quot;, xaxis = list(title = &quot;Largura da Sépala&quot;), yaxis = list(title = &quot;Densidade&quot;)) # d. Boxplots de Sepal.Width por Species plot_ly(data = iris, x = ~Species, y = ~Sepal.Width, type = &quot;box&quot;, color = ~Species) %&gt;% layout(title = &quot;Boxplots da Largura da Sépala por Espécie&quot;, xaxis = list(title = &quot;Espécie&quot;), yaxis = list(title = &quot;Largura da Sépala&quot;)) ## 2. library(dplyr) dados_maio &lt;- airquality %&gt;% filter(Month == 5) plot_ly(data = dados_maio, x = ~Day, y = ~Temp, type = &quot;scatter&quot;, mode = &quot;lines+markers&quot;) %&gt;% layout(title = &quot;Temperatura em maio (NY, 1973)&quot;, xaxis = list(title = &quot;Dia&quot;), yaxis = list(title = &quot;Temperatura (°F)&quot;)) Acesso Professor "],["r-markdown.html", "Capítulo 7 R Markdown 7.1 Conceitos Básicos 7.2 Corpo do documento 7.3 Slides e Apresentações 7.4 Exercícios do Capítulo 7 (Entregar na lista 2)", " Capítulo 7 R Markdown 7.1 Conceitos Básicos O que é R Markdown? É uma linguagem de texto simples que permite combinar código R, resultados de análises e texto explicativo em um único documento. É uma ferramenta poderosa para criar relatórios, apresentações, livros e páginas web de forma automatizada e reproduzível. Ele permite: Combinar texto, código R e resultados de análises em um único arquivo. Gerar relatórios de forma automatizada e, se necessário, reproduzir os resultados com as mesmas configurações. Vários formatos de saída como PDF, HTML, Word, PowerPoint, entre outros. Os arquivos R Markdown têm a extensão .Rmd e são compostos por: Texto: Formatação de texto utilizando a linguagem Markdown (negrito, itálico, títulos, etc.). Blocos de código: Pedaços de código R que são executados e os resultados são incorporados ao documento. Resultados: Inclui tabelas, gráficos, textos e outros outputs gerados pela execução do código. Para criar um novo arquivo .Rmd: File &gt; New File &gt; R Markdown. Após salvar este arquivo, e clicar no botão Knit, é possível compilar e visualizar a saída do exemplo de referência. Os arquivos em R Markdown têm a seguinte estrutura: YAML: cabeçalho YAML (Yet Another Markup Language) é o cabeçalho do documento RMarkdown, delimitado por três tracinhos --- no início e no fim. Ele serve para configurar metadados e o formato de saída do documento. --- title: &quot;Meu Primeiro Relatório&quot; author: &quot;Seu Nome&quot; date: &quot;`r Sys.Date()`&quot; output: html_document --- Corpo do documento: Chunks: blocos de código Texto: Markdown Elementos especiais (imagens e figuras, tabelas, equações) 7.2 Corpo do documento (i) Chunks São blocos de código que você insere no meio do texto para executar comandos. Em geral, utilizam-se códigos em R, mas também é possível adicionar chunks de outras linhuagens, como Python, SQL, etc. A estrutura geral do chunk é: ```{linguagem nome_do_chunk, opções} código ``` Exemplo de um chunk com código em R: ```{r} summary(mtcars[,1:3]) ``` ## mpg cyl disp ## Min. :10.40 Min. :4.000 Min. : 71.1 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 ## Median :19.20 Median :6.000 Median :196.3 ## Mean :20.09 Mean :6.188 Mean :230.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Opções de Chunk: Table 7.1: Principais opções de chunk em R Markdown Opção Descrição Valor Padrão echo Mostra ou oculta o código no documento TRUE eval Executa ou ignora o código TRUE message Mostra mensagens geradas pelo código TRUE warning Mostra avisos gerados pelo código TRUE include Inclui ou não o código e resultado no documento TRUE results Controla como os resultados de texto aparecem ‘markup’ fig.width Define a largura do gráfico (em polegadas) 7 fig.height Define a altura do gráfico (em polegadas) 7 fig.align Alinhamento do gráfico no documento ‘default’ cache Armazena resultados em cache para acelerar o knit FALSE Exemplos: Oculta o código, mas mostra o resultado: Código: ```{r, echo=FALSE} summary(mtcars[,1:3]) ``` Saída: ## mpg cyl disp ## Min. :10.40 Min. :4.000 Min. : 71.1 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 ## Median :19.20 Median :6.000 Median :196.3 ## Mean :20.09 Mean :6.188 Mean :230.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Mostra o código, mas não executa (útil para exemplos): Código: ```{r, eval=FALSE} hist(mtcars$mpg) ``` Saída: hist(mtcars$mpg) Executa, mas não mostra resultado nem código: Código: ```{r, include=FALSE} set.seed(123) ``` Oculta mensagens e avisos: Código: ```{r, message=FALSE, warning=FALSE} library(dplyr) ``` Saída: library(dplyr) Personaliza tamanho e alinhamento do gráfico: Código: ```{r, fig.width=6, fig.height=4, fig.align='center'} plot(mtcars$wt, mtcars$mpg) ``` Saída: plot(mtcars$wt, mtcars$mpg) Opções globais: Podemos definir opções que se aplicam a todos os chunks do documento usando: ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE) ``` Exercícios 1. Crie um relatório no R Markdown. Modifique o título e nome do autor e adicione, para cada item, um chunk em R que: Mostre um gráfico de dispersão entre Sepal.Length e Sepal.Width do dataset iris, mas não mostre o código-fonte no relatório. Mostre o código boxplot(len ~ supp, data = ToothGrowth), mas não execute o código. Carregue os pacotes dplyr e ggplot2 e suprima as mensagens e avisos. Crie um histograma da variável hwy do dataset mpg (pacote ggplot2), com as seguintes configurações: Largura: 5 polegadas Altura: 3 polegadas Alinhamento: esquerda Respostas --- title: &quot;Relatório&quot; author: &quot;Nome&quot; date: &quot;2025-05-26&quot; output: html_document --- # a. Gráfico de dispersão entre `Sepal.Length` e `Sepal.Width`, sem exibir o código: &lt;!-- ```{r, echo=FALSE} --&gt; &lt;!-- plot(iris$Sepal.Length, iris$Sepal.Width) --&gt; &lt;!-- ``` --&gt; # b. Mostrar o código, mas não executá-lo: &lt;!-- ```{r, eval=FALSE} --&gt; &lt;!-- boxplot(len ~ supp, data = ToothGrowth) --&gt; &lt;!-- ``` --&gt; # c. Carregar pacotes suprimindo mensagens e avisos: &lt;!-- ```{r, message=FALSE, warning=FALSE} --&gt; &lt;!-- library(dplyr) --&gt; &lt;!-- library(ggplot2) --&gt; &lt;!-- ``` --&gt; # d. Histograma da variável `hwy` com dimensões personalizadas: &lt;!-- ```{r, fig.width=5, fig.height=3, fig.align=&#39;left&#39;} --&gt; &lt;!-- library(ggplot2) --&gt; &lt;!-- ggplot(mpg, aes(x = hwy)) + --&gt; &lt;!-- geom_histogram(binwidth = 2, fill = &quot;steelblue&quot;, color = &quot;white&quot;) + --&gt; &lt;!-- labs(title = &quot;Histograma de hwy&quot;, x = &quot;hwy&quot;, y = &quot;Frequência&quot;) --&gt; &lt;!-- ``` --&gt; Acesso Professor (ii) Texto: Markdown São escritos usando a sintaxe Markdown. Títulos e Subtítulos: Use # para definir hierarquia: # Título (nível 1) ## Seção (nível 2) ### Subseção (nível 3) Eles aparecem com estilos diferentes e também podem gerar sumário automático (toc: true no YAML). Exemplo: --- title: &quot;Relatório&quot; author: &quot;nome&quot; date: &quot;2025-05-26&quot; output: html_document: toc: true # ativa o sumário automático toc_depth: 2 # mostra até 2 niveis no sumário # e ## number_sections: true # enumera as seções --- Formatação de textos: Negrito: **texto** ou __texto__ → texto Itálico: *texto* ou _texto_ → texto Negrito e itálico: ***Texto*** → Texto Riscado: ~~Texto~~ → Texto Listas: # Não ordenadas: - Item A - Item B - Subitem B.1 * Outro item # Ordenadas: 1. Primeiro 2. Segundo 1. Subitem Código embutido ou inline: `mean()` # mostra a sintaxe de código `r mean(mtcars$mpg)` # mostra o resultado do código compilado Exemplo: A frase: A média da variável speed no dataset cars é 15.4. foi escrita como: A média da variável `speed` no dataset `cars` é `r mean(cars$speed)`. Separadores e Linhas: --- cria uma linha horizontal para dividir seções. Links: [Texto do link](https://exemplo.com) # ou em html: &lt;a href=&quot;https://exemplo.com&quot; target=&quot;_blank&quot;&gt;Clique aqui&lt;/a&gt; Exercícios Reproduza, com as configurações adequadas, o seguinte relatório em RMarkdown: Relatório RMarkdown (iii) Elementos especiais Imagens e Figuras Imagens em Markdown (fora do chunk): # Inserir uma imagem local: ![Descrição da imagem](caminho/para/imagem.png) # Inserir uma imagem da internet: ![RStudio logo](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/724px-R_logo.svg.png?20240131042527) # Controlando o tamanho da imagem: ![RStudio logo](https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/724px-R_logo.svg.png?20240131042527){width=50%} Imagens com o knitr::include_graphics() (dentro do chunk): knitr::include_graphics(&quot;caminho/para/imagem.png&quot;) # Opções úteis: # out.width=&quot;300px&quot; ou &quot;50%&quot; # fig.align = &#39;center&#39; | &#39;left&#39; | &#39;right&#39; # fig.cap = &quot;Legenda da imagem&quot; Exemplo: Imagem com personalizações: Figure 7.1: Titulo Tabelas Tabela em Markdown (fora do chunk): Código: | Nome | Idade | Cidade | |--------|-------|-------------| | João | 25 | São Paulo | | Maria | 30 | Rio de Janeiro | Saída: Nome Idade Cidade João 25 São Paulo Maria 30 Rio de Janeiro Tabela com knitr::kable() (dentro do chunk): knitr::kable(head(mtcars[,1:3]), caption = &quot;Tabela com kable&quot;) Table 7.2: Tabela com kable mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 Valiant 18.1 6 225 Considerando dados simulados: set.seed(1234) dados &lt;- data.frame( Aluno = paste(&quot;Aluno&quot;, 1:5), Curso = c(rep(&quot;Engenharia&quot;, 2), rep(&quot;Informática&quot;,2), &quot;Física&quot;), Idade = round(runif(5, 18, 25), 0), Periodo = round(runif(5, 2, 9), 0), Nota = round(runif(5, 5, 10), 1) ) dados %&gt;% knitr::kable(caption = &quot;Notas dos alunos&quot;) Table 7.3: Notas dos alunos Aluno Curso Idade Periodo Nota Aluno 1 Engenharia 19 6 8.5 Aluno 2 Engenharia 22 2 7.7 Aluno 3 Informática 22 4 6.4 Aluno 4 Informática 22 7 9.6 Aluno 5 Física 24 6 6.5 Equações Fórmula em linha $...$ ou \\(...\\): \\(E = mc^2\\) → \\(E = mc^2\\) Fórmula em bloco $$...$$ ou \\[...\\]: Código: $$ x = \\frac{2a}{b} $$ Saída: \\[ x = \\frac{2a}{b} \\] Operações Básicas: Descrição Código Renderização Soma \\sum_{i=1}^{n} x_i \\(\\sum_{i=1}^{n} x_i\\) Produto \\prod_{i=1}^{n} x_i \\(\\prod_{i=1}^{n} x_i\\) Exponencial \\exp{(a)} \\(\\exp{(a)}\\) Integral \\int_a^b f(x)\\,dx \\(\\int_a^b f(x)\\,dx\\) Fração \\frac{a}{b} \\(\\frac{a}{b}\\) Raiz \\sqrt{x} \\(\\sqrt{x}\\) Potência x^2 \\(x^2\\) Índice x_i \\(x_i\\) Operadores e Símbolos: Código Renderização \\pm \\(\\pm\\) \\cdot \\(\\cdot\\) \\times \\(\\times\\) \\div \\(\\div\\) \\leq \\(\\leq\\) \\geq \\(\\geq\\) \\neq \\(\\neq\\) \\approx \\(\\approx\\) \\infty \\(\\infty\\) (\\frac{a}{b}) ou \\left(\\frac{a}{b}\\right) \\((\\frac{a}{b})\\) ou \\(\\left(\\frac{a}{b}\\right)\\) [\\frac{2a}{b}] ou \\left[\\frac{2a}{b}\\right] \\([\\frac{2a}{b}]\\) ou \\(\\left[\\frac{2a}{b}\\right]\\) \\{\\frac{2a}{b}\\} ou \\left\\{\\frac{2a}{b}\\right\\} \\(\\{\\frac{2a}{b}\\}\\) ou \\(\\left\\{\\frac{2a}{b}\\right\\}\\) Letras Gregas: Nome Código Renderização Alfa \\alpha \\(\\alpha\\) Beta \\beta \\(\\beta\\) Gama \\gamma \\(\\gamma\\) Delta \\delta \\(\\delta\\) Lambda \\lambda \\(\\lambda\\) Mi \\mu \\(\\mu\\) Pi \\pi \\(\\pi\\) Sigma \\sigma \\(\\sigma\\) Teta \\theta \\(\\theta\\) Ômega \\omega \\(\\omega\\) Matrizes: Código: $$ A = \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{bmatrix} $$ Saída: \\[ A = \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{bmatrix} \\] Código: $$ A = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix} $$ Saída: \\[ A = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix} \\] Exemplos: Fórmula de Bhaskara Código: $$ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ Saída: \\[ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] Média amostral Código: $$ \\bar{x} = \\frac{1}{n} \\left(\\sum_{i=1}^{n} x_i \\right) $$ Saída: \\[ \\bar{x} = \\frac{1}{n} \\left(\\sum_{i=1}^{n} x_i \\right) \\] Exercícios 1. Adicione uma imagem da internet em seu arquivo de Rmarkdown usando: (1) Markdown puro (fora do chunk) e (2) knitr::include_graphics() (dentro do chunk). 2. Crie a tabela a seguir usando: (1) Markdown puro (fora do chunk) e (2) knitr::kable() (dentro do chunk). Explore outros argumentos da função knitr::kable. Aluno Nota Ana 9.0 Beto 7.5 Carla 8.0 3. Reproduza o texto a seguir em RMarkdown: Em estatística a distribuição Normal é um modelo muito utilizado. Dizemos que uma variável se comporta de acordo com o modelo Normal com média \\(\\mu\\) e variância \\(\\sigma^2\\) se a sua função densidade de probabilidade for dada por: \\[ f(x) = \\dfrac{1}{\\sqrt{2\\pi \\sigma^2}} \\exp{\\left\\{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2\\right\\}} \\] para \\(-\\infty &lt; x &lt; \\infty\\), onde \\(E(X) = \\mu\\) e \\(\\sigma^2 &gt; 0\\). Ao coletarmos uma amostra de uma população, podemos calcular a média amostral, representada por \\(\\bar{x}\\), que é uma estimativa para a média populacional \\(\\mu\\). A média amostral é dada por: \\[ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^n x_i \\] A variância amostral é uma estimativa para a variância da população \\(\\sigma^2\\), e é calculada por: \\[ s^2 = \\frac{1}{n - 1} \\sum_{i=1}^n (x_i - \\bar{x})^2 \\] Respostas ## 1. # Imagem (1) - Markdown puro ![RStudio Logo](https://www.rstudio.com/wp-content/uploads/2018/10/RStudio-Logo-Flat.png) # Imagem (2) - Usando `knitr::include_graphics()` # knitr::include_graphics(&quot;https://www.rstudio.com/wp-content/uploads/2018/10/RStudio-Logo-Flat.png&quot;) ## 2. # Tabela (1) - Markdown puro | Aluno | Nota | |-------|------| | Ana | 9.0 | | Beto | 7.5 | | Carla | 8.0 | # Tabela (2) - Usando knitr::kable() library(knitr) # Dados da tabela dados &lt;- data.frame( Aluno = c(&quot;Ana&quot;, &quot;Beto&quot;, &quot;Carla&quot;), Nota = c(9.0, 7.5, 8.0) ) # Tabela com kable e alguns argumentos extras kable(dados, format = &quot;html&quot;, caption = &quot;Notas dos Alunos&quot;, align = &quot;c&quot;) ## 3. Texto Em estatística a distribuição **Normal** é um modelo muito utilizado. Dizemos que uma variável se comporta de acordo com o modelo Normal com média \\(\\mu\\) e variância $\\sigma^2$ se a sua função densidade de probabilidade for dada por: \\[ f(x) = \\dfrac{1}{\\sqrt{2\\pi \\sigma^2}} \\exp{\\left\\{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2\\right\\}} \\] para $-\\infty &lt; x &lt; \\infty$, onde $E(X) = \\mu$ e $\\sigma^2 &gt; 0$. Ao coletarmos uma amostra de uma população, podemos calcular a **média amostral**, representada por $\\bar{x}$, que é uma estimativa para a **média populacional** $\\mu$. A média amostral é dada por: $$ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^n x_i $$ A **variância amostral** é uma estimativa para a variância da população $\\sigma^2$, e é calculada por: $$ s^2 = \\frac{1}{n - 1} \\sum_{i=1}^n (x_i - \\bar{x})^2 $$ Acesso Professor 7.3 Slides e Apresentações Para criar apresentações: File &gt; New File &gt; Quarto Presentation… Opções de visualização: source e visual O arquivo salvo tem a extensão .qmd Criando Slides Os slides são delimitados por títulos ou por ---. Exemplo: apresentação com dois slides. # Divisão de slides feita por títulos de nível 2 ( ##) --- title: &quot;Hábitos&quot; author: &quot;John Doe&quot; format: revealjs --- ## Levantar - Desligar o alarme - Sair da cama ## Dormir - Deitar na cama - Contar carneirinhos # Divisão de slides feita por --- --- title: &quot;Hábitos&quot; author: &quot;John Doe&quot; format: revealjs --- --- - Desligar o alarme - Sair da cama --- - Deitar na cama - Contar carneirinhos Também é possível dividir as apresentações em seções com slides de título usando um título de nível 1 ( #). Por exemplo: --- title: &quot;Hábitos&quot; author: &quot;John Doe&quot; format: revealjs --- # De manhã ## Levantar - Desligar o alarme - Sair da cama ## Café da manhã - Comer ovos - Tomar café # À noite ## Jantar - Comer espaguete - Beber vinho ## Dormir - Deitar na cama - Contar carneirinhos Listas incrementais Por padrão, as listas de números e marcadores dentro dos slides são exibidas todas de uma vez. Você pode substituir isso globalmente usando: title: &quot;Minha Apresentação&quot; format: revealjs: incremental: true Para tornar as listas incrementais individualmente: ::: {.incremental} - Comer espaguete - Beber vinho ::: Para tornar as listas não incrementais individualmente: ::: {.nonincremental} - Comer espaguete - Beber vinho ::: Colunas múltiplas Para colocar material em colunas lado a lado, podemos usar o contêiner .columns, contendo dois ou mais contêineres .column e com atributo width: :::: {.columns} ::: {.column width=&quot;40%&quot;} conteudo... ::: ::: {.column width=&quot;60%&quot;} conteudo... ::: :::: Poderia usar também: ::: columns ::: column conteudo ::: ::: column conteudo ::: ::: Notas pessoais ## Slide com notas do palestrante Conteúdo do slide ::: {.notes} As notas do palestrante vão aqui. ::: Temas Há 11 temas integrados disponíveis para apresentações. O tema default é usado automaticamente. Para mudar o tema, deve-se usar a opção theme: --- title: &quot;Apresentação&quot; format: revealjs: theme: dark --- Outros temas disponíveis: Aqui está a lista completa de temas disponíveis: beige blood dark default league moon night serif simple sky solarized Outras informações em: https://quarto.org/docs/presentations/revealjs/ Exercícios Reproduza a seguinte apresentação usando Quarto Presentation do R Markdown: Apresentação de Slides com RMarkdown 7.4 Exercícios do Capítulo 7 (Entregar na lista 2) 1. Criar um relatório no RMarkdown que inclua: Chunks de código Gráficos com ggplot2 Gráficos interativos com plotly Personalizações de texto (negrito, itálico, títulos) Códigos inline Imagens Tabelas (Markdown e kable) Símbolos e equações matemáticas 2. Criar uma apresentação de slides no RMarkdown que inclua todos os itens do exercício anterior e adicionalmente contemple: Listas incrementais Colunas múltiplas Tema personalizado Rodapé e logotipo "],["shiny.html", "Capítulo 8 Shiny 8.1 Introdução ao Shiny 8.2 UI básica 8.3 Reatividade básica 8.4 Layout, temas, HTML 8.5 UI dinâmica 8.6 Publicando aplicativo em shinyapps.io 8.7 Exercícios do Capítulo 8 (Entregar na lista 2)", " Capítulo 8 Shiny 8.1 Introdução ao Shiny Definição: Shiny é um framework para R que permite criar aplicações web interativas diretamente a partir do código R, sem necessidade de conhecimentos em HTML, CSS ou JavaScript. Para começar a trabalhar com Shiny, primeiro instale o pacote: # Instalação do pacote Shiny # install.packages(&quot;shiny&quot;) # Carregando o pacote library(shiny) Para criar um novo app, salvar um script com a extensão .R, exemplo app.R. A partir disso, pode adicionar rapidamente o modelo do aplicativo digitando “shinyapp” e pressionando Shift+Tab. A estrutura de um App Shiny, é composta de: 1. Interface do Usuário (UI): A UI define a aparência do aplicativo - o que o usuário vê e com o que interage. 2. Servidor (Server): O servidor contém a lógica do aplicativo - como ele responde às interações do usuário. 3. Função que combina ambos UI e Server: Para criar o aplicativo, combinamos a UI e o servidor com a função shinyApp(ui = ui, server = server) RunApp: executa o aplicativo Stop (no RStudio) ou fechar a janela do app: encerra o aplicativo 8.1.1 Adicionando controles de UI library(shiny) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Conjunto de Dados&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { } shinyApp(ui, server) fluidPage(): função de layout que define a estrutura visual básica da página. selectInput(): controle de entrada que permite ao usuário interagir com o aplicativo fornecendo um valor. Neste caso, é uma caixa de seleção com o rótulo “Conjunto de Dados” e permite escolher um dos conjuntos de dados que vêm com o R. verbatimTextOutput() e tableOutput(): controles de saída que informam ao Shiny onde colocar a saída renderizada. verbatimTextOutput() exibe código e tableOutput() tabelas. Vemos apenas a entrada, não as duas saídas, porque ainda não informamos ao Shiny como a entrada e as saídas estão relacionadas. 8.1.2 Adicionando comportamento ao Server library(shiny) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Conjunto de Dados&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { output$resumo &lt;- renderPrint({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) summary(dataset) }) output$tabela &lt;- renderTable({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) dataset }) } shinyApp(ui, server) Cada input e output na UI tem identificarodes (IDs). Chamando input$ID e output$ID no servidor é a forma de identificar no shiny uma entrada e uma saída específica, com base no seu ID. output$ID: indica que você está fornecendo a receita para a saída do Shiny com esse ID. Funções de renderização (render{Type}): encapsulam o código fornecido e conectam inputs e outputs. Cada função render{Type} é projetada para produzir um tipo específico de saída (texto, tabelas e gráficos) e geralmente é pareada com uma função {type}Output. Exemplo, renderPrint() é pareado com verbatimTextOutput() e renderTable() é pareado com tableOutput(). Observações: O resumo e a tabela são atualizados sempre que você altera o conjunto de dados de entrada. Essa dependência é criada implicitamente, pois utilizamos input$dataset nas funções de saída. input$dataset é preenchido com o valor atual do componente de interface do usuário com id dataset e fará com que as saídas sejam atualizadas automaticamente sempre que esse valor for alterado. Essa é a essência da reatividade: as saídas reagem (recalculam) automaticamente quando suas entradas são alteradas. 8.1.3 Expressões Reativas São usadas para evitar códigos duplicados. No exemplo anterior, o código a seguir é repetido 2 vezes. dataset &lt;- get(input$dataset, &quot;package:datasets&quot;) Para criar uma expressão reativa: expressao_reativa &lt;- reactive({...}) Para chamar o seu valor, usamos: expressao_reativa(). A expressão reativa só é executada na primeira vez que é chamada e, em seguida, armazena o resultado em cache até que ele precise ser atualizado, deixando o código mais eficiente. Atualizando o app com a expressão reativa: library(shiny) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Conjunto de Dados&quot;, choices = ls(&quot;package:datasets&quot;)), verbatimTextOutput(&quot;resumo&quot;), tableOutput(&quot;tabela&quot;) ) server &lt;- function(input, output, session) { # Criando uma expressão reativa dataset &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;) }) output$resumo &lt;- renderPrint({ # Chamando-a como uma função summary(dataset()) }) output$tabela &lt;- renderTable({ dataset() }) } shinyApp(ui, server) O aplicativo se comporta de forma idêntica, mas funciona um pouco mais eficientemente, pois só precisa recuperar o conjunto de dados uma vez, e não duas. Exercícios - Seção 8.1 1. Crie um aplicativo que cumprimente o usuário pelo nome. Considerando as funções abaixo, organize e identifique quais delas serão necessárias para esta finalidade. tableOutput(&quot;mortgage&quot;) output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name) }) numericInput(&quot;age&quot;, &quot;How old are you?&quot;, value = NA) textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;) textOutput(&quot;greeting&quot;) output$histogram &lt;- renderPlot({ hist(rnorm(1000)) }, res = 96) 2. Suponha que seu amigo queira criar um aplicativo que permita ao usuário definir um número (x) entre 1 e 50 e exiba o resultado da multiplicação desse número por 5. Esta é a primeira tentativa dele: library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;If x is&quot;, min = 1, max = 50, value = 30), &quot;then x times 5 is&quot;, textOutput(&quot;product&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ x * 5 }) } shinyApp(ui, server) Mas infelizmente tem um erro. Você pode ajudá-lo a encontrar e corrigir o erro? 3. Expanda o aplicativo do exercício anterior para permitir que o usuário defina o valor do multiplicador, y, para que o aplicativo produza o valor de x * y. O resultado final deve ser semelhante a este: 4. Considere o aplicativo a seguir, que adiciona algumas funcionalidades adicionais ao aplicativo descrito no exercício anterior. O que há de novo? Como você poderia reduzir a quantidade de código duplicado no aplicativo usando uma expressão reativa? library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, &quot;If x is&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, &quot;and y is&quot;, min = 1, max = 50, value = 5), &quot;then, (x * y) is&quot;, textOutput(&quot;product&quot;), &quot;and, (x * y) + 5 is&quot;, textOutput(&quot;product_plus5&quot;), &quot;and (x * y) + 10 is&quot;, textOutput(&quot;product_plus10&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ product &lt;- input$x * input$y product }) output$product_plus5 &lt;- renderText({ product &lt;- input$x * input$y product + 5 }) output$product_plus10 &lt;- renderText({ product &lt;- input$x * input$y product + 10 }) } shinyApp(ui, server) 5. No aplicativo a seguir, você seleciona um conjunto de dados de um pacote (usando o pacote ggplot2) e o aplicativo imprime um resumo e um gráfico dos dados. Ele também segue boas práticas e utiliza expressões reativas para evitar redundância de código. No entanto, há três bugs no código fornecido abaixo. Você consegue encontrá-los e corrigi-los? library(shiny) library(ggplot2) datasets &lt;- c(&quot;economics&quot;, &quot;faithfuld&quot;, &quot;seals&quot;) ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, &quot;Dataset&quot;, choices = datasets), verbatimTextOutput(&quot;summary&quot;), tableOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { dataset &lt;- reactive({ get(input$dataset, &quot;package:ggplot2&quot;) }) output$summmry &lt;- renderPrint({ summary(dataset()) }) output$plot &lt;- renderPlot({ plot(dataset) }, res = 96) } shinyApp(ui, server) Respostas ## 1. library(shiny) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name) }) } shinyApp(ui, server) ## 2. O erro aqui surge porque, no lado do servidor, precisamos escrever input$x em vez de x. ## 3. Vamos adicionar outro sliderInput com ID y e usar ambos input$x e input$y para calcular output$product. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, label = &quot;If x is&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, label = &quot;and y is&quot;, min = 1, max = 50, value = 30), &quot;then x multiplied by y is&quot;, textOutput(&quot;product&quot;) ) server &lt;- function(input, output, session) { output$product &lt;- renderText({ input$x * input$y }) } shinyApp(ui, server) ## 4. # A novidade é o cálculo adicional em que 5 e 10 foram adicionados # ao produto e as saídas renderizadas como texto. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;x&quot;, &quot;If x is&quot;, min = 1, max = 50, value = 30), sliderInput(&quot;y&quot;, &quot;and y is&quot;, min = 1, max = 50, value = 5), &quot;then, (x * y) is&quot;, textOutput(&quot;product&quot;), &quot;and, (x * y) + 5 is&quot;, textOutput(&quot;product_plus5&quot;), &quot;and (x * y) + 10 is&quot;, textOutput(&quot;product_plus10&quot;) ) server &lt;- function(input, output, session) { # Add this reactive expression to reduce # amount of duplicated code product &lt;- reactive({ input$x * input$y }) output$product &lt;- renderText({ product() }) output$product_plus5 &lt;- renderText({ product() + 5 }) output$product_plus10 &lt;- renderText({ product() + 10 }) } shinyApp(ui, server) ## 5. # Erros: # 1º erro: # trocar tableOutput(&quot;plot&quot;) por plotOutput(&quot;plot&quot;) -&gt; renderPlot # 2º erro: # summary esta escrito errado em output$summmry # 3º erro: # trocar plot(dataset) por plot(dataset()) para usar a expressão reativa Acesso Professor 8.2 UI básica A estrutura do UI (front-end) do shiny possibilita diferentes tipos de funções de entrada e saída que permitem capturar diversos tipos de dados e exibir diversos tipos de saída em R. 8.2.1 Entradas Argumentos das funções de entrada: inputId (primeiro argumento presente em todas as funções): Este é o identificador usado para conectar o front-end com o back-end. Se sua interface de usuário tiver uma entrada com ID “name”, a função do servidor a acessará com input$name. O inputId tem duas restrições: Deve ser uma string simples contendo apenas letras, números e sublinhados. Deve ser nomeada como uma variável em R. Deve ser único. label (segundo argumento presente na maioria das funções): usado para criar um rótulo legível para o controle. value (terceiro argumento): quando pesente, permite definir o valor padrão. Principais funções de entrada do Shiny 1. Texto livre Permite coletar pequenas quantidades de texto com textInput(), senhas com passwordInput() e parágrafos de texto com textAreaInput(). ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;Qual é o seu nome?&quot;), passwordInput(&quot;password&quot;, &quot;Qual é a sua senha?&quot;), textAreaInput(&quot;story&quot;, &quot;Fale sobre você&quot;, rows = 3) ) 2. Entradas numéricas Para valores numéricos: caixa de texto restrita com numericInput() ou um controle deslizante com sliderInput(). ui &lt;- fluidPage( numericInput(&quot;num&quot;, &quot;Número um&quot;, value = 0, min = 0, max = 100), sliderInput(&quot;num2&quot;, &quot;Número dois&quot;, value = 50, min = 0, max = 100), sliderInput(&quot;rng&quot;, &quot;Intervalo&quot;, value = c(10, 20), min = 0, max = 100) ) 3. Datas Para coletar um único dia: dateInput(); ou um intervalo de dias: dateRangeInput(). ui &lt;- fluidPage( dateInput(&quot;dob&quot;, &quot;Quando você nasceu?&quot;), dateRangeInput(&quot;holiday&quot;, &quot;Quando você quer tirar as próximas férias?&quot;) ) 4. Escolhas limitadas Existem duas abordagens diferentes para permitir que o usuário escolha entre um conjunto pré-especificado de opções: selectInput() e radioButtons(). animais &lt;- c(&quot;cachorro&quot;, &quot;gato&quot;, &quot;rato&quot;, &quot;pássaro&quot;, &quot;outro&quot;, &quot;nenhum&quot;) estados &lt;- c(&quot;PR&quot;, &quot;SC&quot;, &quot;SP&quot;, &quot;RJ&quot;) ui &lt;- fluidPage( selectInput(&quot;estado&quot;, &quot;Qual é o seu estado favorito?&quot;, estados), radioButtons(&quot;animal&quot;, &quot;Qual é o seu animal favorito?&quot;, animais) ) Os botões de opção (radioButtons()) têm dois recursos interessantes: eles mostram todas as opções possíveis, tornando-os adequados para listas curtas. Os menus suspensos (selectInput()) ocupam a mesma quantidade de espaço, independentemente do número de opções, tornando-os mais adequados para opções mais longas. Você também pode configurar multiple = TRUEpara permitir que o usuário selecione vários elementos. ui &lt;- fluidPage( selectInput(&quot;estado&quot;, &quot;Qual é o seu estado favorito?&quot;, estados, multiple = TRUE) ) 5. Botões de ação Para executar ações: actionButton() ou actionLink(). ui &lt;- fluidPage( actionButton(&quot;click&quot;, &quot;Clique aqui!&quot;), actionButton(&quot;drink&quot;, &quot;Beba-me!&quot;, icon = icon(&quot;cocktail&quot;)) ) Links e botões de ação são mais naturalmente pareados com observeEvent() ou eventReactive() na sua função de servidor. Você pode personalizar a aparência usando o argumento class “btn-primary”, “btn-success”, “btn-info”, “btn-warning”, ou “btn-danger”. Você também pode alterar o tamanho com “btn-lg”, “btn-sm”, “btn-xs”. Por fim, você pode fazer com que os botões ocupem toda a largura do elemento em que estão incorporados usando “btn-block”. ui &lt;- fluidPage( fluidRow( actionButton(&quot;click&quot;, &quot;Clique aqui!&quot;, class = &quot;btn-danger&quot;), actionButton(&quot;drink&quot;, &quot;Beba-me!&quot;, class = &quot;btn-lg btn-success&quot;) ), fluidRow( actionButton(&quot;resp&quot;, &quot;Respostas!&quot;, class = &quot;btn-block&quot;) ) ) Exercícios - Seção 8.2.1 1. Quando o espaço é limitado, é útil rotular as caixas de texto com um espaço reservado que aparece dentro da área de entrada de texto. Como você chamaria textInput() para gerar a IU abaixo? 2. Leia atentamente a documentação de sliderInput() e tente descobrir como criar um controle deslizante de data, conforme mostrado abaixo. 3. No seu aplicativo Shiny, crie um controle deslizante que permita ao usuário escolher um número entre 0 e 100, variando de 5 em 5. Em seguida, adicione uma funcionalidade de animação, de forma que, ao clicar em um botão de “play”, o controle avance automaticamente pelos valores disponíveis, como se estivesse passando por eles em sequência. Dica: existe um argumento do controle deslizante que permite ativar esse tipo de animação automaticamente. 4. Quando uma lista de opções em um menu suspenso (selectInput()) é muito longa, pode ser útil organizá-la em grupos com rótulos — como se fossem seções ou categorias dentro da lista. Explore como criar esse tipo de organização usando selectInput() no Shiny. Crie um exemplo com pelo menos dois grupos e algumas opções dentro de cada grupo (como o exemplo a seguir). Respostas ##1 textInput(inputId = &quot;text&quot;, label = &quot;&quot;, placeholder = &quot;Your name&quot;) ##2 # ?sliderInput -&gt; ?Date -&gt; as.Date sliderInput( &quot;dates&quot;, &quot;Quando devemos entregar?&quot;, min = as.Date(&quot;2025-03-10&quot;), max = as.Date(&quot;2025-03-20&quot;), value = as.Date(&quot;2025-03-12&quot;) ) ##3 sliderInput(&quot;number&quot;, &quot;Selecione um número:&quot;, min = 0, max = 100, value = 0, step = 5, animate = TRUE) ##4 selectInput( &quot;raca&quot;, &quot;Selecione sua raça animal favorita:&quot;, choices = list(&quot;Cães&quot; = list(&#39;Pastor Alemão&#39;, &#39;Bulldog&#39;, &#39;Labrador Retriever&#39;), &quot;Gatos&quot; = list(&#39;Gato Persa&#39;, &#39;Gato de Bengala&#39;, &#39;Gato Siamês&#39;)) ) Acesso Professor 8.2.2 Saídas As saídas na UI criam espaços reservados que são posteriormente preenchidos pela função do servidor. Assim como as entradas, as saídas recebem um ID exclusivo como primeiro argumento. Se a sua especificação de UI criar uma saída com ID “plot”, você a acessará na função do servidor com output$plot. Cada função de output no front-end (UI) é acoplada a uma função de renderização no back-end (server). 1. Texto Produza texto com textOutput() e código fixo com verbatimTextOutput(). library(shiny) ui &lt;- fluidPage( textOutput(&quot;texto&quot;), verbatimTextOutput(&quot;code&quot;) ) server &lt;- function(input, output, session) { output$texto &lt;- renderText({ &quot;Olá, bem vindo! A seguir um resumo de dados:&quot; }) output$code &lt;- renderPrint({ summary(1:10) }) } shinyApp(ui, server) Observe que há duas funções de renderização que se comportam de maneira ligeiramente diferente: renderText() combina o resultado em uma única string e geralmente é emparelhado com textOutput(). renderPrint() imprime o resultado, como se você estivesse em um console R, e geralmente é pareado com verbatimTextOutput(). ui &lt;- fluidPage( textOutput(&quot;texto&quot;), verbatimTextOutput(&quot;print&quot;) ) server &lt;- function(input, output, session) { output$texto &lt;- renderText(&quot;Texto com renderText.&quot;) output$print &lt;- renderPrint(cat(&quot;Texto com renderPrint.&quot;)) } 2. Tabelas Há duas opções para exibir quadros de dados em tabelas: tableOutput() e renderTable() renderizam uma tabela estática de dados, mostrando todos os dados de uma só vez. Útil para resumos pequenos e fixos. dataTableOutput() e renderDataTable() renderizam uma tabela dinâmica. É mais apropriado se você deseja expor um quadro de dados completo ao usuário. ui &lt;- fluidPage( tableOutput(&quot;statica&quot;), dataTableOutput(&quot;dinamica&quot;) ) server &lt;- function(input, output, session) { output$statica &lt;- renderTable(head(mtcars)) output$dinamica &lt;- renderDataTable(mtcars, options = list(pageLength = 5)) } Versões mais recentes sugerem usar DTOutput e renderDT do pacote DT para tabelas dinâmicas. library(shiny) library(DT) ui &lt;- fluidPage( tableOutput(&quot;statica&quot;), DTOutput(&quot;dinamica&quot;) ) server &lt;- function(input, output, session) { output$statica &lt;- renderTable(head(mtcars)) output$dinamica &lt;- renderDT(mtcars, options = list(pageLength = 5)) } shinyApp(ui, server) 3. Gráficos Você pode exibir qualquer tipo de gráfico R (basico, ggplot2, etc) com plotOutput() e renderPlot(). ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } Por padrão, plotOutput() ocupará toda a largura do contêiner e terá 400 pixels de altura. Você pode substituir esses padrões com os argumentos height e width. Recomenda-se sempre definir res = 96, pois isso fará com que seus gráficos correspondam o máximo possível ao que você vê no RStudio. Os gráficos são especiais porque são saídas que também podem atuar como entradas. plotOutput() possui vários argumentos como click, dblclick e hover. Se passar uma string para eles, como click = \"plot_click\", eles criarão uma entrada reativa (input$plot_click) que você pode usar para manipular a interação do usuário no gráfico, por exemplo, clicando no gráfico. Exercícios - Seção 8.2.2 1. As funções textOutput() e verbatimTextOutput() devem ser pareadas com qual(is) função(ões) de renderização abaixo: renderPrint(summary(mtcars)) renderText(\"Good morning!\") renderPrint(t.test(1:5, 2:6)) renderText(str(lm(mpg ~ wt, data = mtcars))) 2. Recrie o aplicativo a seguir, definindo a altura como 300px e a largura como 700px. library(shiny) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } shinyApp(ui, server) 3. Atualize o código abaixo para que a tabela exiba apenas os dados e o controle de paginação, removendo os controles de busca e ordenação por colunas. Para isso, use os argumentos adequados para options da função renderDataTable(). Consulte a ajuda da função renderDataTable (?renderDataTable) e a documentação oficial do DataTables para entender como desativar esses controles: https://datatables.net/reference/option/ ui &lt;- fluidPage( dataTableOutput(&quot;table&quot;) ) server &lt;- function(input, output, session) { output$table &lt;- renderDataTable(mtcars, options = list(pageLength = 5)) } Respostas ## 1. # a. renderPrint(summary(mtcars)) -&gt; verbatimTextOutput (console) # b. renderText(&quot;Good morning!&quot;) -&gt; textOutput # c. renderPrint(t.test(1:5, 2:6)) -&gt; verbatimTextOutput (console) # d. renderText(str(lm(mpg ~ wt, data = mtcars))) -&gt; verbatimTextOutput (console) ## 2. library(shiny) ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;700px&quot;, height = &quot;300px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5), res = 96) } shinyApp(ui, server) ## 3. library(shiny) ui &lt;- fluidPage( dataTableOutput(&quot;table&quot;) ) server &lt;- function(input, output, session) { output$table &lt;- renderDataTable(mtcars, options = list(ordering = FALSE, searching = FALSE)) } shinyApp(ui, server) Acesso Professor 8.3 Reatividade básica 8.3.1 A função do servidor As funções de servidor recebem três parâmetros: input, output e session. Como você nunca chama a função de servidor, nunca criará esses objetos. Em vez disso, eles são criados pelo Shiny quando a sessão inicia, conectando-se a uma sessão específica. Vamos ver algumas formas de evitar erros envolvendo inputs e outputs. Entradas (input) O input é um objeto em forma de lista que contém todos os dados de entrada enviados pelo navegador, nomeados de acordo com o ID de entrada. Por exemplo, se sua interface contiver um controle de entrada numérico com um ID count, então você pode acessar o valor dessa entrada com input$count. ui &lt;- fluidPage( numericInput(&quot;count&quot;, label = &quot;Number of values&quot;, value = 100) ) Inicialmente, ele conterá o valor 100 e será atualizado automaticamente conforme o usuário altera o valor no navegador. Ao contrário de uma lista típica, objetos de input são somente leitura. Se você tentar modificar uma entrada dentro da função do servidor, receberá um erro: server &lt;- function(input, output, session) { input$count &lt;- 10 } shinyApp(ui, server) #&gt; Error: Can&#39;t modify read-only reactive value &#39;count&#39; Este erro ocorre porque input reflete o que está acontecendo no navegador, e o navegador é a “única fonte de verdade” do Shiny. Além disso, para ler um input no servidor é necessário estar em um contexto reativo criado por uma função como renderText() ou reactive(). Isso permite que as saídas sejam atualizadas automaticamente quando uma entrada muda. Este código ilustra o erro que você verá se cometer este erro: server &lt;- function(input, output, session) { message(&quot;The value of input$count is &quot;, input$count) } shinyApp(ui, server) #&gt; Error: Can&#39;t access reactive value &#39;count&#39; outside of reactive consumer. #&gt; ℹ Do you need to wrap inside reactive() or observer()? Saídas (output) A saída (output) também é um objeto do tipo lista, nomeado de acordo com o ID de saída. A principal diferença é que você o usa para enviar saída em vez de receber entrada. Você sempre usa o objeto output em conjunto com uma função render. ui &lt;- fluidPage( textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText(&quot;Hello human!&quot;) } Assim como o input, o output é exigente quanto à forma como você o utiliza. Você receberá um erro se: Esquecer a função render. server &lt;- function(input, output, session) { output$greeting &lt;- &quot;Hello human&quot; } shinyApp(ui, server) #&gt; Error: Unexpected character object for output$greeting #&gt; ℹ Did you forget to use a render function? Tentar ler uma saída. server &lt;- function(input, output, session) { message(&quot;The greeting is &quot;, output$greeting) } shinyApp(ui, server) #&gt; Error: Reading from shinyoutput object is not allowed. 8.3.2 Programação reativa Um aplicativo será bem chato se tiver apenas entradas ou apenas saídas. A verdadeira magia do Shiny acontece quando você tem um aplicativo com ambos. library(shiny) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name, &quot;!&quot;) }) } shinyApp(ui, server) Se você executar o aplicativo verá que a saudação é atualizada automaticamente conforme você digita. Esta é a grande ideia do Shiny: você não precisa informar a saída quando atualizar, porque o Shiny descobre isso automaticamente para você. Um dos pontos fortes da programação em Shiny é que ela permite que os aplicativos sejam extremamente preguiçosos. Um aplicativo Shiny só fará o mínimo de trabalho necessário para atualizar os controles de saída. Essa preguiça, no entanto, tem uma desvantagem importante. O que há de errado com o código abaixo? library(shiny) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name, &quot;!&quot;) }) } shinyApp(ui, server) Se você observar atentamente, poderá notar que está escrito greting em vez de greeting. Isso não gerará um erro no Shiny, mas não fará o que você deseja. A saída greting não existe, então o código em renderText() nunca será executado. Importante: Verificar se sua interface de usuário e funções de servidor estão usando os mesmos nomes de identificadores. O Gráfico Reativo O gráfico reativo é uma representação gráfica que descreve como as entradas e saídas estão conectadas. Ele define a ordem de execução do aplicativo. Para o exemplo: library(shiny) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { output$greeting &lt;- renderText({ paste0(&quot;Hello &quot;, input$name, &quot;!&quot;) }) } shinyApp(ui, server) O gráfico reativo fica: O gráfico reativo contém um símbolo para cada entrada e saída, e conectamos uma entrada a uma saída sempre que a saída acessa a entrada. Este gráfico informa que greeting precisará ser recomputado sempre que name for alterado. Frequentemente descreveremos essa relação como greeting tendo uma dependência reativa em name. O gráfico reativo é uma ferramenta poderosa para entender como seu aplicativo funciona. À medida que seu aplicativo se torna mais complexo, muitas vezes é útil fazer um esboço rápido e detalhado do gráfico reativo para lembrar como todas as peças se encaixam. No caso do código envolver expressões reativas, esta informação também deve ser adicionada ao gráfico reativo. Exemplo: library(shiny) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) server &lt;- function(input, output, session) { string &lt;- reactive(paste0(&quot;Hello &quot;, input$name, &quot;!&quot;)) output$greeting &lt;- renderText(string()) } shinyApp(ui, server) Neste caso, o gráfico reativo fica: Uma expressão reativa é desenhada com ângulos em ambos os lados porque conecta entradas a saídas. Exercícios - Seção 8.3.2 1. Dada esta UI: ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), textOutput(&quot;greeting&quot;) ) Corrija os erros encontrados em cada uma das três funções de servidor abaixo. Primeiro, tente identificar o problema apenas lendo o código; depois, execute o código para garantir que o corrigiu. server1 &lt;- function(input, output, server) { input$greeting &lt;- renderText(paste0(&quot;Hello &quot;, name)) } server2 &lt;- function(input, output, server) { greeting &lt;- paste0(&quot;Hello &quot;, input$name) output$greeting &lt;- renderText(greeting) } server3 &lt;- function(input, output, server) { output$greting &lt;- paste0(&quot;Hello&quot;, input$name) } 2. Desenhe o gráfico reativo para cada função de servidor a seguir: server1 &lt;- function(input, output, session) { c &lt;- reactive(input$a + input$b) e &lt;- reactive(c() + input$d) output$f &lt;- renderText(e()) } server2 &lt;- function(input, output, session) { x &lt;- reactive(input$x1 + input$x2 + input$x3) y &lt;- reactive(input$y1 + input$y2) output$z &lt;- renderText(x() / y()) } server3 &lt;- function(input, output, session) { d &lt;- reactive(c() ^ input$d) a &lt;- reactive(input$a * 10) c &lt;- reactive(b() / input$c) b &lt;- reactive(a() + input$b) } 3. Por que esse código falhará? library(shiny) df &lt;- mtcars ui &lt;- fluidPage( selectInput(&quot;var&quot;, NULL, choices = colnames(df)), verbatimTextOutput(&quot;debug&quot;) ) server &lt;- function(input, output, session) { var &lt;- reactive(df[[input$var]]) range &lt;- reactive(range(var(), na.rm = TRUE)) output$debug &lt;- renderPrint({ range() }) } shinyApp(ui = ui, server = server) Por que range() e var() são nomes ruins para reativos? Apresente o código corrigido. Respostas 1. # Servidor 1: - input$greeting –&gt; output$greeting - Dentro renderText, name –&gt; input$name Código corrigido: server1 &lt;- function(input, output, server) { output$greeting &lt;- renderText(paste0(&quot;Hello &quot;, input$name)) } # Servidor 2: - Faça greeting um reativo: greeting &lt;- reactive(paste0(&quot;Hello &quot;, input$name)) - Como greeting agora é reativo, adicione parênteses ao redor dele: output$greeting &lt;- renderText(greeting()) Código corrigido: server2 &lt;- function(input, output, server) { greeting &lt;- reactive(paste0(&quot;Hello &quot;, input$name)) output$greeting &lt;- renderText(greeting()) } # Servidor 3: - Erro de ortografia: output$greting –&gt; output$greeting - renderText() ausente. Código corrigido: server3 &lt;- function(input, output, server) { output$greeting &lt;- renderText(paste0(&quot;Hello &quot;, input$name)) } 2. Para criar o grafico reativo, precisamos considerar as entradas, expressões reativas e saídas. Server1: entradas: input$a, input$b e input$d reativos: c() e e() saídas: output$f Server2: entradas: input$x1, input$x2, input$x3, input$y1, input$y2 reativos: y() e x() saídas: output$z Server3 entradas: input$a, input$b, input$c, input$d reativos: a(), b(), c(), d() 3. Este código não funciona porque chamamos nosso reativo de range, então, quando chamamos a função range, estamos, na verdade, chamando nosso novo reativo. Se mudarmos o nome do reativo de range para col_range, o código funcionará. Da mesma forma, var() não é um bom nome para um reativo porque já é uma função para calcular a variância de x! Código corrigido: library(shiny) df &lt;- mtcars ui &lt;- fluidPage( selectInput(&quot;var&quot;, NULL, choices = colnames(df)), verbatimTextOutput(&quot;debug&quot;) ) server &lt;- function(input, output, session) { col_var &lt;- reactive(df[[input$var]]) col_range &lt;- reactive({ range(col_var(), na.rm = TRUE ) }) output$debug &lt;- renderPrint({ col_range() }) } shinyApp(ui = ui, server = server) Acesso Professor 8.3.3 observeEvent() e eventReactive() No Shiny, observeEvent() e eventReactive() são funções essenciais para controlar a reatividade com base em eventos específicos (como cliques em botões, mudanças em inputs, etc.). Elas têm finalidades diferentes, embora ambas respondam a eventos. observeEvent(): Executa código sem retorno de valor reativo e é útil para efeitos colaterais (ex: atualizar valores, mostrar mensagens, salvar arquivos). Sintaxe: observeEvent(evento, { # código que será executado quando &#39;evento&#39; mudar }) Exemplo: library(shiny) ui &lt;- fluidPage( actionButton(&quot;meu_botao&quot;, &quot;Clique aqui&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$meu_botao, { print(&quot;O botão foi clicado!&quot;) }) } shinyApp(ui, server) eventReactive(): Cria um objeto reativo que só é atualizado quando um evento ocorre. Ideal para realizar cálculos pesados ou demorados apenas quando necessário (como ao clicar num botão). Sintaxe: reactivo &lt;- eventReactive(evento, { # código que gera e retorna o valor }) Exemplo: library(shiny) ui &lt;- fluidPage( numericInput(&quot;n&quot;, &quot;Número:&quot;, value = 5), actionButton(&quot;calc&quot;, &quot;Calcular quadrado&quot;), verbatimTextOutput(&quot;resultado&quot;) ) server &lt;- function(input, output, session) { quadrado &lt;- eventReactive(input$calc, { input$n^2 }) output$resultado &lt;- renderText({ paste(&quot;Resultado:&quot;, quadrado()) }) } shinyApp(ui, server) Exercícios - Seções 8.1 a 8.3 1. Encontre e corrija o(s) erro(s) dos códigos a seguir: a. library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Seu nome:&quot;), textOutput(&quot;mensagem&quot;) ) server &lt;- function(input, output, session) { output$frase &lt;- renderText({ paste(&quot;Olá&quot;, input$nome) }) } shinyApp(ui, server) b. library(shiny) ui &lt;- fluidPage( numericInput(&quot;x&quot;, &quot;Número:&quot;, value = 1), textOutput(&quot;mensagem&quot;) ) server &lt;- function(input, output, session) { output$mensagem &lt;- renderPlot({ paste(&quot;O valor é&quot;, input$x) }) } shinyApp(ui, server) c. library(shiny) ui &lt;- fluidPage( numericInput(&quot;x&quot;, &quot;Número:&quot;, value = 5) ) server &lt;- function(input, output, session) { output$resultado &lt;- renderText({ paste(&quot;Dobro:&quot;, 2 * input$x) }) } shinyApp(ui, server) d. library(shiny) ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Número A&quot;, value = 0), numericInput(&quot;b&quot;, &quot;Número B&quot;, value = 0), textOutput(&quot;soma&quot;) ) server &lt;- function(input, output, session) { soma &lt;- reactive({ input$a + input$b }) output$soma &lt;- renderText({ paste(&quot;A soma é:&quot;, soma) }) } shinyApp(ui, server) e. library(shiny) ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Número A&quot;, value = 0), numericInput(&quot;b&quot;, &quot;Número B&quot;, value = 0), textOutput(&quot;soma&quot;) ) server &lt;- function(input, output, session) { soma &lt;- reactive({ input$a + input$b }) renderText({ paste(&quot;A soma é:&quot;, soma()) }) } shinyApp(ui, server) 2. Crie um app com: textInput() para um nome, selectInput() para escolher uma comida favorita, Um textOutput() que exibe algo como: “Olá [nome], sua comida favorita é [comida].” 3. Crie um app com: Dois numericInput() (números a e b), Um botão (actionButton(“calcular”)), Um textOutput() com a soma de a + b, somente após clicar. Dica: Use eventReactive(). 4. Crie um app com: Um sliderInput() para escolher o número de bins (ex: de 5 a 50), Um plotOutput() com um histograma da distribuição rnorm(100), O gráfico deve atualizar automaticamente conforme o slider muda. Dica: Use renderPlot(). 5. Crie um app com: Um botão (actionButton()) para gerar, quando clicado, 100 números aleatórios (rnorm(100)), Um plotOutput() com o histograma desses números, O gráfico só deve mudar quando o botão for clicado. Dica: Use eventReactive(). Respostas ## 1. # a. output$frase &lt;- renderText({ # ID do output diferente na UI paste(&quot;Olá&quot;, input$nome) }) # b. # renderPlot() está sendo usado para gerar texto (erro de função) # c. # faltando textOutput() no UI! # d. # paste(&quot;A soma é:&quot;, soma) # BUG AQUI: está faltando () # e. # BUG: renderText() está sendo chamado sem ser atrtribuído a output$soma ## 2. library(shiny) ui &lt;- fluidPage( textInput(&quot;nome&quot;, &quot;Seu nome:&quot;), selectInput(&quot;comida&quot;, &quot;Escolha sua comida favorita:&quot;, choices = c(&quot;Pizza&quot;, &quot;Sushi&quot;, &quot;Lasanha&quot;, &quot;Hambúrguer&quot;)), textOutput(&quot;mensagem&quot;) ) server &lt;- function(input, output, session) { output$mensagem &lt;- renderText({ paste(&quot;Olá&quot;, input$nome, &quot;- sua comida favorita é&quot;, input$comida) }) } shinyApp(ui, server) ## 3. library(shiny) ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Número A:&quot;, value = 0), numericInput(&quot;b&quot;, &quot;Número B:&quot;, value = 0), actionButton(&quot;calcular&quot;, &quot;Calcular soma&quot;), textOutput(&quot;resultado&quot;) ) server &lt;- function(input, output, session) { soma &lt;- eventReactive(input$calcular, { input$a + input$b }) output$resultado &lt;- renderText({ paste(&quot;Resultado da soma:&quot;, soma()) }) } shinyApp(ui, server) ## 4. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;bins&quot;, &quot;Número de bins:&quot;, min = 5, max = 50, value = 10), plotOutput(&quot;histograma&quot;) ) server &lt;- function(input, output, session) { output$histograma &lt;- renderPlot({ x &lt;- rnorm(100) hist(x, breaks = input$bins, col = &quot;steelblue&quot;, border = &quot;white&quot;) }) } shinyApp(ui, server) ## 5. library(shiny) ui &lt;- fluidPage( actionButton(&quot;gerar&quot;, &quot;Gerar histograma&quot;), plotOutput(&quot;histograma&quot;) ) server &lt;- function(input, output, session) { dados &lt;- eventReactive(input$gerar, { rnorm(100) }) output$histograma &lt;- renderPlot({ hist(dados(), col = &quot;darkgreen&quot;) }) } shinyApp(ui, server) Acesso Professor 8.4 Layout, temas, HTML O Shiny fornece diversas funções para organizar a aparência dos aplicativos. 8.4.1 Layouts Funções de página O fluidPage() configura todo o HTML, CSS e JavaScript que o Shiny precisa. Além de fluidPage(), o Shiny oferece outras funções de página que podem ser úteis em situações mais especializadas: fixedPage() e fillPage(). fixedPage() funciona como fluidPage(), mas tem uma largura máxima fixa, o que impede que seus aplicativos fiquem excessivamente largos em telas maiores. fillPage() Preenche toda a altura do navegador e é útil se você quiser criar um gráfico que ocupe a tela inteira. 1. Layouts de página única Página com barra lateral Para criar layouts mais complexos, você precisará chamar funções de layout dentro de fluidPage() Para criar um layout de duas colunas com entradas à esquerda e saídas à direita, você pode usar sidebarLayout() junto com titlePanel(), sidebarPanel() e mainPanel(). ui &lt;- fluidPage( titlePanel( # Titulo do app ), sidebarLayout( sidebarPanel( # inputs ), mainPanel( # outputs ) ) ) Exemplo: Teorema do Limite Central ui &lt;- fluidPage( titlePanel(&quot;Teorema do Limite Central&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;m&quot;, &quot;Número de amostras:&quot;, 2, min = 1, max = 100) ), mainPanel( plotOutput(&quot;hist&quot;) ) ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }, res = 96) } Multi-linhas Podemos adicionar linhas ou colunas ao aplicativo com fluidRow() e column(). ui &lt;- fluidPage( fluidRow( column(4, ... ), column(8, ... ) ), fluidRow( column(6, ... ), column(6, ... ) ) ) Cada linha é composta por 12 colunas e o primeiro argumento de column() indica quantas dessas colunas ocupar. Exercícios 1. Leia a documentação de sidebarLayout() e identifique os valores padrão da largura (em colunas) da barra lateral (sidebarPanel) e do painel principal (mainPanel). Recrie a aparência do aplicativo Teorema do Limite Central usando fluidRow() e column()? 2. Modifique o aplicativo Teorema do Limite Central (usando sidebarLayout()) para colocar a barra lateral à direita em vez de à esquerda. 3. Para conjunto de dados mtcars e usando as funções fluidRow() e column(), construa um app Shiny que mostre: Titulo do Aplicativo Na primeira linha: Dois botões de seleção (selectInput) para escolher duas variáveis numéricas (em colunas lado a lado). Na segunda linha: Dois gráficos correspondentes - um histograma da primeira variável e um boxplot da segunda variável, exibidos lado a lado. Respostas 1. Por padrão, a barra lateral ocupa 1/3 da largura (width = 4), e o painel principal, 2/3 (width = 8). # É possivel recriar, embora o layout fique um pouco diferente # Recriando sidebarLayout() fluidRow( # sidebar (4 columns) column(4, ... ), # # main panel (8 columns) column(8, ... ) ) # Para o exemplo anterior: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Teorema do Limite Central&quot;), # sidebar (4 columns) fluidRow( column(4, numericInput(&quot;m&quot;, &quot;Número de amostras:&quot;, 2, min = 1, max = 100) ), # main panel (8 columns) column(8, plotOutput(&quot;hist&quot;) ) ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }, res = 96) } shinyApp(ui = ui, server = server) 2. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Teorema do Limite Central&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;m&quot;, &quot;Número de amostras:&quot;, 2, min = 1, max = 100) ), mainPanel( plotOutput(&quot;hist&quot;) ), # Modificado para colocar a posição da barra lateral à direita position = &quot;right&quot; ) ) server &lt;- function(input, output, session) { output$hist &lt;- renderPlot({ means &lt;- replicate(1e4, mean(runif(input$m))) hist(means, breaks = 20) }, res = 96) } shinyApp(ui, server) 3. library(shiny) &lt;!-- # Selecionando numericas (se necessário) --&gt; &lt;!-- library(dplyr) --&gt; &lt;!-- numeric_vars &lt;- mtcars %&gt;% --&gt; &lt;!-- select(where(is.numeric)) %&gt;% --&gt; &lt;!-- names() --&gt; ui &lt;- fluidPage( titlePanel(&quot;Histograma e Boxplot&quot;), # Linha de seleção das variáveis fluidRow( column(6, selectInput(&quot;var1&quot;, &quot;Variável para histograma:&quot;, choices = names(mtcars), selected = &quot;mpg&quot;) ), column(6, selectInput(&quot;var2&quot;, &quot;Variável para boxplot:&quot;, choices = names(mtcars), selected = &quot;hp&quot;) ) ), # Linha com os dois gráficos lado a lado fluidRow( column(6, plotOutput(&quot;histPlot&quot;) ), column(6, plotOutput(&quot;boxPlot&quot;) ) ) ) server &lt;- function(input, output, session) { output$histPlot &lt;- renderPlot({ var &lt;- mtcars[[input$var1]] hist(var, main = paste(&quot;Histograma de&quot;, input$var1), xlab = input$var1, col = &quot;skyblue&quot;) }) output$boxPlot &lt;- renderPlot({ var &lt;- mtcars[[input$var2]] boxplot(var, main = paste(&quot;Boxplot de&quot;, input$var2), ylab = input$var2, col = &quot;orange&quot;) }) } shinyApp(ui, server) Acesso Professor 2. Layouts de várias páginas Conjuntos de guias A maneira mais simples de dividir uma página em partes é usar tabsetPanel() junto com tabPanel(). tabsetPanel() cria um contêiner para qualquer número de tabPanels(), que por sua vez pode conter quaisquer outros componentes. Exemplo: ui &lt;- fluidPage( tabsetPanel( tabPanel(title = &quot;Importar dados&quot;, fileInput(&quot;file&quot;, &quot;Dados&quot;, buttonLabel = &quot;Upload...&quot;), textInput(&quot;delim&quot;, &quot;Delimitador&quot;, &quot;&quot;), numericInput(&quot;skip&quot;, &quot;Linhas para pular&quot;, 0, min = 0), numericInput(&quot;rows&quot;, &quot;Linhas para visualizar&quot;, 10, min = 1) ), tabPanel(&quot;Conjunto de parâmetros&quot;), tabPanel(&quot;Resultados&quot;) ) ) Se quiser saber qual aba um usuário selecionou, você pode fornecer o argumento id para tabsetPanel() e ele se tornará uma entrada. Argumento ID: se fornecido, você pode usar input$id na lógica do seu servidor para determinar qual das abas atuais está ativa. O valor de input$id corresponderá ao argumento value passado para tabPanel(). library(shiny) ui &lt;- fluidPage( sidebarLayout( sidebarPanel( textOutput(&quot;painel&quot;) ), mainPanel( tabsetPanel( id = &quot;painel_ativo&quot;, tabPanel(title = &quot;Aba 1&quot;, value = &quot;aba1&quot;, &quot;Conteúdo da Aba 1&quot;), tabPanel(title = &quot;Aba 2&quot;, value = &quot;aba2&quot;, &quot;Conteúdo da Aba 2&quot;) ) ) ) ) server &lt;- function(input, output, session) { output$painel &lt;- renderText({ paste(&quot;A aba atual é:&quot;, input$painel_ativo) }) } shinyApp(ui, server) Se value for omitido e tabsetPanel tiver um ID, o título será usado. Listas e barras de navegação A estrutura de abas com tabsetPanel (que tem exibição horizontal), dificulta representar titulos longos. Deste modo, navlistPanel(), navbarPage() e navbarMenu() possibilitam layouts alternativos que permitem que você use abas com títulos mais longos. navlistPanel() é semelhante a tabsetPanel(), mas em vez de exibir os títulos das guias horizontalmente, ele os exibe verticalmente em uma barra lateral. ui &lt;- fluidPage( navlistPanel( id = &quot;tabset&quot;, &quot;Título 1&quot;, tabPanel(&quot;Painel 1&quot;, &quot;Conteúdos do painel 1...&quot;), &quot;Título 2&quot;, tabPanel(&quot;Painel 2&quot;, &quot;Conteúdos do painel 2...&quot;), tabPanel(&quot;Painel 3&quot;, &quot;Conteúdos do painel 3...&quot;) ) ) navbarPage(): exibe os títulos das abas horizontalmente, mas você pode usar navbarMenu() para adicionar menus suspensos com um nível adicional de hierarquia. ui &lt;- navbarPage( &quot;Titulo&quot;, tabPanel(&quot;Painel 1&quot;, &quot;Conteúdos do painel 1...&quot;), tabPanel(&quot;Painel 2&quot;, &quot;Conteúdos do painel 2...&quot;), navbarMenu(&quot;Sub-Painéis&quot;, tabPanel(&quot;Painel 4a&quot;, &quot;Conteúdos do painel 4-a...&quot;), tabPanel(&quot;Painel 4b&quot;, &quot;Conteúdos do painel 4-b...&quot;) ) ) Exercícios 1. Crie um app usando tabsetPanel() com 2 abas para os dados mtcars: Aba 1: Gráfico boxplot para a variável mpg Aba 2: Gráfico de barras para a variável cyl. 2. Crie um app com uma barra de navegação lateral (navlistPanel()) com 2 abas, para os dados mtcars: Aba 1: contendo um controle (por exemplo, selectInput()) para escolher uma variável e um gráfico para esta variável. Aba 2: contendo a tabela de dados mtcars. 3. Considerando o conjunto de dados iris, crie um app com menu de navegação usando navbarPage() e navbarMenu(), contendo 2 abas: Aba 1: um resumo (summary) dos dados (use verbatimTextOutput()). Aba 2: contendo 2 sub-abas com: (1) um gráfico de dispersão entre Sepal.Length e Petal.Length e (2) um histograma para Sepal.Width. Respostas ## 1. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Visualização dos dados mtcars&quot;), tabsetPanel( tabPanel(&quot;Boxplot de mpg&quot;, plotOutput(&quot;boxplot_mpg&quot;) ), tabPanel(&quot;Barras de cyl&quot;, plotOutput(&quot;barras_cyl&quot;) ) ) ) server &lt;- function(input, output, session) { output$boxplot_mpg &lt;- renderPlot({ boxplot(mtcars$mpg, main = &quot;Boxplot de mpg&quot;, ylab = &quot;Milhas por galão (mpg)&quot;, col = &quot;skyblue&quot;) }) output$barras_cyl &lt;- renderPlot({ barplot(table(mtcars$cyl), main = &quot;Frequência de cilindros (cyl)&quot;, xlab = &quot;Número de cilindros&quot;, ylab = &quot;Frequência&quot;, col = &quot;orange&quot;) }) } shinyApp(ui, server) ## 2. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Análise dos dados mtcars&quot;), navlistPanel( &quot;Menu&quot;, tabPanel(&quot;Gráfico de variável&quot;, selectInput(inputId = &quot;variavel&quot;, label = &quot;Escolha uma variável numérica:&quot;, choices = names(mtcars), selected = &quot;mpg&quot; ), plotOutput(&quot;grafico&quot;) ), tabPanel(&quot;Tabela de dados&quot;, tableOutput(&quot;tabela&quot;) ) ) ) server &lt;- function(input, output, session) { output$grafico &lt;- renderPlot({ hist(mtcars[[input$variavel]], main = paste(&quot;Histograma de&quot;, input$variavel), xlab = input$variavel, col = &quot;steelblue&quot;) }) output$tabela &lt;- renderTable({ mtcars }) } shinyApp(ui, server) ## 3. library(shiny) ui &lt;- navbarPage(&quot;Análise do dataset iris&quot;, tabPanel(&quot;Resumo dos dados&quot;, verbatimTextOutput(&quot;resumo&quot;) ), navbarMenu(&quot;Gráficos&quot;, tabPanel(&quot;Dispersão: Sepal vs Petal&quot;, plotOutput(&quot;dispersao&quot;) ), tabPanel(&quot;Histograma: Sepal.Width&quot;, plotOutput(&quot;histograma&quot;) ) ) ) server &lt;- function(input, output, session) { output$resumo &lt;- renderPrint({ summary(iris) }) output$dispersao &lt;- renderPlot({ plot(iris$Sepal.Length, iris$Petal.Length, main = &quot;Dispersão: Sepal.Length vs Petal.Length&quot;, xlab = &quot;Sepal.Length&quot;, ylab = &quot;Petal.Length&quot;, pch = 19, col = iris$Species) }) output$histograma &lt;- renderPlot({ hist(iris$Sepal.Width, main = &quot;Histograma de Sepal.Width&quot;, xlab = &quot;Sepal.Width&quot;, col = &quot;lightgreen&quot;, border = &quot;white&quot;) }) } shinyApp(ui, server) Acesso Professor 8.4.2 Temas Principais abordagens para aplicar temas em Shiny. Temas básicos com shinythemes library(shiny) library(shinythemes) ui &lt;- fluidPage( theme = shinytheme(&quot;cerulean&quot;), # Exemplo de tema titlePanel(&quot;App com tema &#39;cerulean&#39;&quot;), sidebarLayout( sidebarPanel( sliderInput(&quot;num&quot;, &quot;Escolha um número&quot;, 1, 100, 50) ), mainPanel( textOutput(&quot;res&quot;) ) ) ) server &lt;- function(input, output) { output$res &lt;- renderText({ paste(&quot;Você escolheu&quot;, input$num) }) } shinyApp(ui = ui, server = server) Outros temas disponíveis: - cosmo - cyborg - darkly - flatly - journal - lumen - paper - readable Customização avançada com bslib (Bootstrap themes) library(shiny) library(bslib) ui &lt;- fluidPage( theme = bslib::bs_theme( bg = &quot;#0b3d91&quot;, fg = &quot;white&quot;, base_font = &quot;Source Sans Pro&quot; ), titlePanel(&quot;App com bslib e tema &#39;minty&#39;&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;n&quot;, &quot;Número&quot;, 1) ), mainPanel( verbatimTextOutput(&quot;result&quot;) ) ) ) server &lt;- function(input, output) { output$result &lt;- renderPrint({ input$n^2 }) } shinyApp(ui, server) bg: Cores para o fundo. fg: Cores para o primeiro plano. base_font: A fonte padrão. Para visualizar o exemplo de um tema específico: theme &lt;- bslib::bs_theme( bg = &quot;#0b3d91&quot;, fg = &quot;white&quot;, base_font = &quot;Source Sans Pro&quot; ) bslib::bs_theme_preview(theme) Para personalizar os gráficos de acordo com o tema do app, usar thematic_shiny() do pacote thematic. library(shiny) library(thematic) thematic_shiny() # aplica automaticamente o tema ui &lt;- fluidPage( theme = bslib::bs_theme( bg = &quot;#0b3d91&quot;, fg = &quot;white&quot;, base_font = &quot;Source Sans Pro&quot; ), titlePanel(&quot;App com thematic&quot;), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output) { output$plot &lt;- renderPlot({ plot(rnorm(100)) }) } shinyApp(ui, server) Observações: Para criar as cores você pode consultar colors(), ou consultar os códigos em https://r-charts.com/colors/. Para fontes, você pode usar o suporte do Google Fonts via a função font_google() do próprio bslib, com diferentes opções em https://fonts.google.com/. 8.4.3 HTML O Shiny foi projetado para que, como usuário de R, você não precise aprender os detalhes de HTML. No entanto, se você tiver algum conhecimento de HTML e CSS, é possível personalizá-lo ainda mais. Todas as funções de entrada, saída e layout do shiny: apenas geram HTML. Você pode ver esse HTML executando funções de interface do usuário diretamente no console: # Código no console fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;) ) # Saída &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;form-group shiny-input-container&quot;&gt; &lt;label class=&quot;control-label&quot; id=&quot;name-label&quot; for=&quot;name&quot;&gt;What&#39;s your name? &lt;/label&gt; &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;shiny-input-text form-control&quot; value=&quot;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; É possível adicionar seu próprio HTML ao ui. Uma maneira de fazer isso é incluir HTML literal com a função HTML(), juntamente com a “constante de caractere bruto”, r\"()\", para facilitar a inclusão de aspas na string: ui &lt;- fluidPage( HTML(r&quot;( &lt;h1&gt;This is a heading&lt;/h1&gt; &lt;p class=&quot;my-class&quot;&gt;This is some text!&lt;/p&gt; &lt;ul&gt; &lt;li&gt;First bullet&lt;/li&gt; &lt;li&gt;Second bullet&lt;/li&gt; &lt;/ul&gt; )&quot;) ) Outra opção é usar o auxiliar HTML fornecido pelo Shiny. Existem funções regulares para os elementos mais importantes, como h1() e p(), e outros podem ser acessados por meio de tags auxiliares. Recriando o HTML acima: ui &lt;- fluidPage( h1(&quot;This is a heading&quot;), p(&quot;This is some text!&quot;, class = &quot;my-class&quot;), tags$ul( tags$li(&quot;First bullet&quot;), tags$li(&quot;Second bullet&quot;) ) ) O livro Outstanding User Interfaces with Shiny, de David Granjon, pode ser consultado para mais detalhes sobre como usar HTML, CSS e JavaScript para criar interfaces de usuário mais atraentes. Exercícios 1. Crie um aplicativo Shiny simples com um tema usando bslib com as seguintes características: Cor de fundo (bg) para um tom de azul claro: #e6f2ff. Cor do texto (fg) para um cinza escuro: #2c3e50. Fonte base como “Lato” (Google Fonts). Dica: Você pode usar a função font_google(\"Lato\") para aplicar a fonte. 2. Use bslib::bs_theme_preview() para criar o tema mais feio possível. Respostas ## 1. library(shiny) library(thematic) thematic_shiny() # aplica automaticamente o tema ui &lt;- fluidPage( theme = bslib::bs_theme( bg = &quot;#e6f2ff&quot;, fg = &quot;#2c3e50&quot;, base_font = font_google(&quot;Lato&quot;) ), titlePanel(&quot;App com thematic&quot;), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output) { output$plot &lt;- renderPlot({ plot(rnorm(100)) }) } shinyApp(ui, server) ## 2. tema &lt;- bslib::bs_theme( bg = &quot;#ff00ff&quot;, # Rosa neon de fundo fg = &quot;#00ff00&quot;, # Verde neon para texto base_font = font_google(&quot;Comic Neue&quot;), # Fonte bizarra heading_font = font_google(&quot;Creepster&quot;), # Título ainda mais estranho code_font = &quot;Courier New&quot; ) bslib::bs_theme_preview(tema) Acesso Professor 8.5 UI dinâmica O shiny disponibiliza alguns recursos para criar interfaces de usuário dinâmicas, alterando a UI usando código executado na função do servidor. Existem três técnicas principais para criar interfaces de usuário dinâmicas: Usando a familia de funções update para modificar parâmetros de controles de entrada. Usando tabsetPanel() com updateTabsetPanel() para mostrar e ocultar condicionalmente partes da interface do usuário. Usando uiOutput() e renderUI() gerando partes selecionadas da interface do usuário com código. 8.5.1 Usando a familia de funções update Cada controle de entrada, por exemplo textInput(), é pareado com uma função de atualização, por exemplo updateTextInput(), que permite modificar o controle após sua criação. Exemplos 1. Atualizando parâmetros de slider No exemplo a seguir, o aplicativo possui duas entradas que controlam o min e max de outra entrada, um controle deslizante. A ideia principal é usar observeEvent() para disparar updateSliderInput() sempre que as entradas min ou max mudarem. ui &lt;- fluidPage( numericInput(&quot;min&quot;, &quot;Mínimo&quot;, 0), numericInput(&quot;max&quot;, &quot;Máximo&quot;, 3), sliderInput(&quot;n&quot;, &quot;n&quot;, min = 0, max = 3, value = 1) ) server &lt;- function(input, output, session) { observeEvent(input$min, { updateSliderInput(inputId = &quot;n&quot;, min = input$min) }) observeEvent(input$max, { updateSliderInput(inputId = &quot;n&quot;, max = input$max) }) } As funções de atualização recebem o nome do input como o argumento inputId. Os argumentos restantes correspondem aos argumentos para construir o input que podem ser modificados após a criação. 2. Resetar controles O app a seguir ilustra como redefinir os parâmetros dos controles para seus valores iniciais. ui &lt;- fluidPage( sliderInput(&quot;x1&quot;, &quot;x1&quot;, 0, min = -10, max = 10), sliderInput(&quot;x2&quot;, &quot;x2&quot;, 0, min = -10, max = 10), sliderInput(&quot;x3&quot;, &quot;x3&quot;, 0, min = -10, max = 10), actionButton(&quot;reset&quot;, &quot;Reset&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$reset, { updateSliderInput(inputId = &quot;x1&quot;, value = 0) updateSliderInput(inputId = &quot;x2&quot;, value = 0) updateSliderInput(inputId = &quot;x3&quot;, value = 0) }) } 3. Atualizar texto de um botão de ação ui &lt;- fluidPage( numericInput(&quot;n&quot;, &quot;Simulations&quot;, 10), actionButton(&quot;simulate&quot;, &quot;Simulate&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$n, { label &lt;- paste0(&quot;Simulate &quot;, input$n, &quot; times&quot;) updateActionButton(inputId = &quot;simulate&quot;, label = label) }) } 4. Caixas de seleção hierárquicas Uma aplicação particularmente importante é facilitar a seleção em uma longa lista de opções possíveis, por meio da filtragem passo a passo. Considere o conjunto de dados para um painel de vendas, obtidos de https://www.kaggle.com/kyanyoga/sample-sales-data. library(dplyr) ## Lendo os dados: sales &lt;- readr::read_csv(&quot;figs/sales_data_sample.csv&quot;, col_types = cols(), na = &quot;&quot;) sales %&gt;% select(TERRITORY, CUSTOMERNAME, ORDERNUMBER, everything()) %&gt;% arrange(ORDERNUMBER) Neste caso, os dados tem uma hierarquia natural: Cada território (TERRITORY) contém clientes (CUSTOMERNAME). Cada cliente (CUSTOMERNAME) tem vários pedidos (ORDERNUMBER). Cada pedido (ORDERNUMBER) contém linhas. Vamos criar uma interface de usuário onde você possa: Selecionar um território para ver todos os clientes. Selecionar um cliente para ver todos os pedidos. Selecionar um pedido para ver as linhas subjacentes. A essência da UI é simples: três caixas de seleção e uma tabela de saída. As opções para as caixas de seleção customername e ordernumber serão geradas dinamicamente, então usamos choices = NULL. Na função de servidor: É criado um reativo, territory(), que contém as linhas das vendas que correspondem ao território selecionado. Sempre que territory() muda, a lista choices na caixa de seleção input$customername é atualizada. É criado outro reativo, customer(), que contém as linhas de territory() que correspondem ao cliente selecionado. Sempre que customer() muda, a lista choices na caixa de seleção input$ordernumber é atualizada. Os pedidos selecionados são exibidos em output$data. Neste caso, o territory e customer foram considerados reativos, por terem sido utilizados em mais de um lugar. Em casos mais simples, isso não seria necessário. # Interface do usuário ui &lt;- fluidPage( # Menu suspenso para selecionar o território # (usa os valores únicos da coluna TERRITORY) selectInput(&quot;territory&quot;, &quot;Território&quot;, choices = unique(sales$TERRITORY)), # Menu suspenso para selecionar o cliente # (inicialmente vazio, será preenchido dinamicamente) selectInput(&quot;customername&quot;, &quot;Cliente&quot;, choices = NULL), # Menu suspenso para selecionar o número do pedido # (também vazio no início) selectInput(&quot;ordernumber&quot;, &quot;Pedido&quot;, choices = NULL), # Local onde será exibida a tabela com os dados filtrados tableOutput(&quot;data&quot;) ) # Lógica do servidor server &lt;- function(input, output, session) { # Expressão reativa que filtra os dados com base no território selecionado territory &lt;- reactive({ filter(sales, TERRITORY == input$territory) }) # Quando o território mudar, atualiza a lista de clientes disponíveis observeEvent(territory(), { # clientes únicos do território filtrado choices &lt;- unique(territory()$CUSTOMERNAME) # atualiza o selectInput de cliente updateSelectInput(inputId = &quot;customername&quot;, choices = choices) }) # Expressão reativa que filtra os dados com base no cliente selecionado customer &lt;- reactive({ req(input$customername) # garante que o cliente foi selecionado filter(territory(), CUSTOMERNAME == input$customername) }) # Quando o cliente mudar, atualiza a lista de pedidos disponíveis observeEvent(customer(), { # pedidos únicos do cliente filtrado choices &lt;- unique(customer()$ORDERNUMBER) # atualiza o selectInput de pedido updateSelectInput(inputId = &quot;ordernumber&quot;, choices = choices) }) # Renderiza a tabela com os dados filtrados pelo pedido selecionado output$data &lt;- renderTable({ req(input$ordernumber) # garante que um pedido foi selecionado customer() %&gt;% # filtra pelo pedido selecionado filter(ORDERNUMBER == input$ordernumber) %&gt;% # seleciona as colunas a serem exibidas select(QUANTITYORDERED, PRICEEACH, PRODUCTCODE) }) } Este aplicativo está disponível em: https://hadley.shinyapps.io/ms-update-nested/ Exercícios 1. Crie um aplicativo com um sliderInput que possibilite ao usuário selecionar um número e um botão de ação que, ao clicado, atualize o label desse slider para o número atual selecionado. 2. Crie um aplicativo com um botão de ação nomeado “trocar” e um selectInput com 3 letras do alfabeto. O objetivo é que ao clicar no botão “trocar” as opções de letras do alfabeto sejam atualizadas para outras letras aleatórias. 3. Crie um aplicativo com 2 inputs numéricos e um slider cujo valor seja atualizado com a média destes inputs, conforme eles forem modificados. 4. Complete a interface de usuário abaixo com uma função de servidor que atualiza as opções de input$county com base em input$state. library(openintro, warn.conflicts = FALSE) states &lt;- unique(county$state) ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;State&quot;, choices = states), selectInput(&quot;county&quot;, &quot;County&quot;, choices = NULL) ) 5. Complete a interface de usuário abaixo com uma função de servidor que atualiza as opções de input$country com base em input$continent. Use output$data para exibir todas as linhas correspondentes. library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = continents), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) Respostas ## 1. ui &lt;- fluidPage( sliderInput(&quot;nota&quot;, &quot;Nota&quot;, min = 0, max = 10, value = 5), actionButton(&quot;atualizar&quot;, &quot;Atualizar rótulo&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$atualizar, { updateSliderInput(inputId = &quot;nota&quot;, label = paste(&quot;Nota:&quot;, input$nota)) }) } ## 2. ui &lt;- fluidPage( actionButton(&quot;trocar&quot;, &quot;Trocar opções&quot;), selectInput(&quot;escolha&quot;, &quot;Escolha uma opção:&quot;, choices = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ) server &lt;- function(input, output, session) { observeEvent(input$trocar, { novas_opcoes &lt;- sample(LETTERS[1:6], size = 3) updateSelectInput(inputId = &quot;escolha&quot;, choices = novas_opcoes) }) } ## 3. ui &lt;- fluidPage( numericInput(&quot;a&quot;, &quot;Valor A&quot;, value = 10), numericInput(&quot;b&quot;, &quot;Valor B&quot;, value = 30), sliderInput(&quot;media&quot;, &quot;Média&quot;, min = 0, max = 100, value = 20) ) server &lt;- function(input, output, session) { observeEvent(c(input$a, input$b), { media_valor &lt;- mean(c(input$a, input$b)) updateSliderInput(inputId = &quot;media&quot;, value = media_valor) }) } ## 4. library(shiny) library(openintro, warn.conflicts = FALSE) # Lista única de estados disponíveis no dataset &#39;county&#39; states &lt;- unique(county$state) # Interface do usuário ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;State&quot;, choices = states),# Seletor de estado selectInput(&quot;county&quot;, &quot;County&quot;, choices = NULL) # Seletor de condado (atualizado dinamicamente) ) # Função do servidor server &lt;- function(input, output, session) { # Observa mudanças no estado selecionado observeEvent(input$state, { # Filtra os condados correspondentes ao estado selecionado counties &lt;- unique(county$name[county$state == input$state]) # Atualiza o seletor de condados updateSelectInput(inputId = &quot;county&quot;, choices = counties) }) } ## ou (solução livro) server &lt;- function(input, output, session) { observeEvent(input$state, { req(input$state) # pull out county names choices &lt;- county %&gt;% filter(state == input$state) %&gt;% pull(name) %&gt;% unique() updateSelectInput(inputId = &quot;county&quot;, choices = choices) }) } # Executa o aplicativo shinyApp(ui, server) ## 5. library(shiny) library(gapminder) continents &lt;- unique(gapminder$continent) ui &lt;- fluidPage( # add &quot;(All)&quot; to the list of choices selectInput(&quot;continent&quot;, &quot;Continent&quot;, choices = continents), selectInput(&quot;country&quot;, &quot;Country&quot;, choices = NULL), tableOutput(&quot;data&quot;) ) # Função do servidor (usando base R) server &lt;- function(input, output, session) { # Observa mudanças no estado selecionado observeEvent(input$continent, { choices &lt;- unique(gapminder$country[gapminder$continent == input$continent]) # Atualiza o seletor de condados updateSelectInput(inputId = &quot;country&quot;, choices = choices) }) output$data &lt;- renderTable({ req(input$country) gapminder[gapminder$continent == input$continent &amp; gapminder$country == input$country, ] }) } # Função do servidor (usando dplyr) server &lt;- function(input, output, session) { observeEvent(input$continent, { req(input$continent) # pull out country names choices &lt;- gapminder %&gt;% filter(continent == input$continent) %&gt;% pull(country) %&gt;% unique() updateSelectInput(inputId = &quot;country&quot;, choices = choices) }) output$data &lt;- renderTable({ gapminder %&gt;% filter(continent == input$continent, country == input$country) }) } shinyApp(ui, server) Acesso Professor 8.5.2 Usando tabsetPanel() com updateTabsetPanel() Exemplos 1. Guias condicionais Imagine que você queira um aplicativo que permita ao usuário simular distribuições normal, uniforme e exponencial. Cada distribuição tem parâmetros diferentes, então precisaremos de uma maneira de mostrar controles diferentes para cada distribuição. Cada distribuição terá sua interface de usuário exclusiva com tabPanel() e, em seguida, serão oranizadas em guias de um arquivo tabsetPanel(). Em seguida, isso será incorporado na interface de usuário que permite ao usuário escolher o número de amostras e mostra um histograma dos resultados. # Define um conjunto de abas ocultas, onde cada aba contém os # parâmetros para uma distribuição específica parameter_tabs &lt;- tabsetPanel( id = &quot;params&quot;, # ID do tabset usado para controle via server type = &quot;hidden&quot;, # Oculta as abas # (elas são trocadas programaticamente, não clicáveis) # Aba para distribuição normal: precisa de média e desvio padrão tabPanel(&quot;normal&quot;, numericInput(&quot;mean&quot;, &quot;mean&quot;, value = 1), # Input para média numericInput(&quot;sd&quot;, &quot;standard deviation&quot;, min = 0, value = 1) # Input para desvio padrão ), # Aba para distribuição uniforme: precisa de mínimo e máximo tabPanel(&quot;uniform&quot;, numericInput(&quot;min&quot;, &quot;min&quot;, value = 0), # Limite inferior numericInput(&quot;max&quot;, &quot;max&quot;, value = 1) # Limite superior ), # Aba para distribuição exponencial: precisa da taxa tabPanel(&quot;exponential&quot;, numericInput(&quot;rate&quot;, &quot;rate&quot;, value = 1, min = 0) # Parâmetro de taxa (lambda) ) ) # Interface do usuário ui &lt;- fluidPage( sidebarLayout( sidebarPanel( selectInput(&quot;dist&quot;, &quot;Distribution&quot;, # Menu suspenso para escolher a distribuição choices = c(&quot;normal&quot;, &quot;uniform&quot;, &quot;exponential&quot;) ), numericInput(&quot;n&quot;, &quot;Number of samples&quot;, value = 100), # Quantidade de amostras parameter_tabs # Os inputs de parâmetros definidos acima ), mainPanel( plotOutput(&quot;hist&quot;) # Área para exibir o histograma ) ) ) # Função do servidor server &lt;- function(input, output, session) { # Observa a escolha da distribuição e atualiza o tabsetPanel correspondente observeEvent(input$dist, { updateTabsetPanel(inputId = &quot;params&quot;, selected = input$dist) # Ativa a aba correspondente à distribuição }) # Gera a amostra com base na distribuição e nos parâmetros escolhidos sample &lt;- reactive({ switch(input$dist, normal = rnorm(input$n, input$mean, input$sd), # Gera amostra normal uniform = runif(input$n, input$min, input$max), # Gera amostra uniforme exponential = rexp(input$n, input$rate) # Gera amostra exponencial ) }) # Desenha o histograma da amostra gerada output$hist &lt;- renderPlot(hist(sample()), res = 96) # res = 96 define resolução para melhor visualização } O resultado pode ser visualizado em: https://hadley.shinyapps.io/ms-dynamic-conditional/ 2. Guias sequenciais A mesma ideia pode ser usada para criar um “assistente”, um tipo de interface que facilita a coleta de um conjunto de informações, distribuindo-as por várias páginas. Neste exemplo, cada “página” têm botões de ação, facilitando o avanço e o retrocesso. # Interface do usuário ui &lt;- fluidPage( tabsetPanel( # ID do tabset, usado para controlar qual aba está ativa id = &quot;wizard&quot;, # Esconde as abas (mostra apenas o conteúdo) type = &quot;hidden&quot;, # Primeira &quot;página&quot; tabPanel(&quot;page_1&quot;, &quot;Bem-vindo!&quot;, actionButton(&quot;page_12&quot;, &quot;next&quot;) # Botão para ir para a próxima página ), # Segunda página tabPanel(&quot;page_2&quot;, &quot;Falta só uma página&quot;, actionButton(&quot;page_21&quot;, &quot;prev&quot;), # Botão para voltar para a página 1 actionButton(&quot;page_23&quot;, &quot;next&quot;) # Botão para ir para a página 3 ), # Terceira (última) página tabPanel(&quot;page_3&quot;, &quot;Pronto!&quot;, actionButton(&quot;page_32&quot;, &quot;prev&quot;) # Botão para voltar para a página 2 ) ) ) # Função do servidor server &lt;- function(input, output, session) { # Função auxiliar que recebe um número e ativa a aba correspondente switch_page &lt;- function(i) { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = paste0(&quot;page_&quot;, i)) } # Observadores: quando um botão é clicado, chama a função switch_page() observeEvent(input$page_12, switch_page(2)) # Página 1 → 2 observeEvent(input$page_21, switch_page(1)) # Página 2 → 1 observeEvent(input$page_23, switch_page(3)) # Página 2 → 3 observeEvent(input$page_32, switch_page(2)) # Página 3 → 2 } Esse app simula um “wizard” (um fluxo de páginas passo-a-passo), muito comum em formulários ou tutoriais. O tabsetPanel(type = \"hidden\") permite criar várias telas (abas), mas sem mostrar as guias. Cada página é representada por um tabPanel(), e os botões de navegação chamam updateTabsetPanel() para mudar de página. A função switch_page(i) constrói o nome da aba a ativar com paste0(\"page_\", i), por exemplo “page_2”. O resultado pode ser visualizado em: https://hadley.shinyapps.io/ms-wizard Exercícios 1. Crie uma UI em que o usuário escolha uma categoria (por ex., “Carro”, “Moto”, “Bicicleta”), e o app mostre campos específicos para essa categoria, usando abas escondidas. Um selectInput(\"veiculo\", \"Tipo de veículo\", choices = ...) Um tabsetPanel(type = \"hidden\") com uma aba para cada tipo de veículo. No servidor, troque para a aba correspondente com updateTabsetPanel(). 2. Crie um formulário multi-etapas para coletar o nome e a idade do usuário em duas páginas separadas. Página 1: textInput(\"name\", \"Seu nome:\") + botão “Próximo” Página 2: numericInput(\"age\", \"Sua idade:\", value = NA) + botões “Voltar” e “Próximo” Página 3: Exiba um texto com paste(\"Olá\", input$name, \"de\", input$age, \"anos!\") + botão “Reiniciar” que volta para página 1. 3. Crie um mini-quiz com duas perguntas de múltipla escolha. Página 1: Pergunta 1 (radioButtons) + botão “Próximo” Página 2: Pergunta 2 (radioButtons) + botão “Ver Resultado” Página 3: Mostrar pontuação com renderText() com base nas respostas corretas e um botão “Tentar novamente” que reinicia o quiz na página 1. Respostas ## 1. ui &lt;- fluidPage( selectInput(&quot;veiculo&quot;, &quot;Tipo de veículo:&quot;, choices = c(&quot;carro&quot;, &quot;moto&quot;, &quot;bicicleta&quot;)), tabsetPanel( id = &quot;veiculo_tabs&quot;, type = &quot;hidden&quot;, tabPanel(&quot;carro&quot;, numericInput(&quot;portas&quot;, &quot;Número de portas:&quot;, value = 4) ), tabPanel(&quot;moto&quot;, numericInput(&quot;ano&quot;, &quot;Ano de fabricação:&quot;, value = 1990) ), tabPanel(&quot;bicicleta&quot;, selectInput(&quot;tipo_bike&quot;, &quot;Tipo:&quot;, choices = c(&quot;urbana&quot;, &quot;mountain bike&quot;, &quot;estrada&quot;)) ) ) ) server &lt;- function(input, output, session) { observeEvent(input$veiculo, { updateTabsetPanel(inputId = &quot;veiculo_tabs&quot;, selected = input$veiculo) }) } ## 2. ui &lt;- fluidPage( tabsetPanel( id = &quot;wizard&quot;, type = &quot;hidden&quot;, tabPanel(&quot;page_1&quot;, textInput(&quot;name&quot;, &quot;Seu nome:&quot;), actionButton(&quot;to2&quot;, &quot;Próximo&quot;) ), tabPanel(&quot;page_2&quot;, numericInput(&quot;age&quot;, &quot;Sua idade:&quot;, value = NA), actionButton(&quot;back1&quot;, &quot;Voltar&quot;), actionButton(&quot;to3&quot;, &quot;Próximo&quot;) ), tabPanel(&quot;page_3&quot;, textOutput(&quot;summary&quot;), actionButton(&quot;restart&quot;, &quot;Reiniciar&quot;) ) ) ) server &lt;- function(input, output, session) { switch_page &lt;- function(i) { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = paste0(&quot;page_&quot;, i)) } observeEvent(input$to2, { req(input$name) switch_page(2)}) observeEvent(input$back1, switch_page(1)) observeEvent(input$to3, { req(input$age) switch_page(3)}) observeEvent(input$restart, switch_page(1)) output$summary &lt;- renderText({ paste(&quot;Olá&quot;, input$name, &quot;de&quot;, input$age, &quot;anos!&quot;) }) } ## 3. ui &lt;- fluidPage( tabsetPanel( id = &quot;wizard&quot;, type = &quot;hidden&quot;, tabPanel(&quot;page_1&quot;, radioButtons(&quot;q1&quot;, &quot;Quanto é 2 + 2?&quot;, choices = c(&quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), actionButton(&quot;nextq1&quot;, &quot;Próxima&quot;) ), tabPanel(&quot;page_2&quot;, radioButtons(&quot;q2&quot;, &quot;Quanto é 3 * 3?&quot;, choices = c(&quot;6&quot;, &quot;9&quot;, &quot;12&quot;)), actionButton(&quot;result&quot;, &quot;Ver resultado&quot;), actionButton(&quot;backq1&quot;, &quot;Voltar&quot;) ), tabPanel(&quot;page_3&quot;, textOutput(&quot;score&quot;), actionButton(&quot;retry&quot;, &quot;Tentar novamente&quot;) ) ) ) server &lt;- function(input, output, session) { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_1&quot;) observeEvent(input$nextq1, { req(input$q1) updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_2&quot;) }) observeEvent(input$backq1, { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_1&quot;) }) observeEvent(input$result, { req(input$q2) updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_3&quot;) }) observeEvent(input$retry, { updateTabsetPanel(inputId = &quot;wizard&quot;, selected = &quot;page_1&quot;) }) output$score &lt;- renderText({ score &lt;- 0 if (input$q1 == &quot;4&quot;) score &lt;- score + 1 if (input$q2 == &quot;9&quot;) score &lt;- score + 1 paste(&quot;Você acertou&quot;, score, &quot;de 2 perguntas.&quot;) }) } Acesso Professor 8.5.3 Usando uiOutput() e renderUI() Essa técnica permite criar e modificar a interface de usuário enquanto o aplicativo está em execução. Essa solução tem duas partes: uiOutput(): insere um espaço reservado no seu ui. Isso deixa um “buraco” que o código do seu servidor pode preencher posteriormente. renderUI() é chamado server() para preencher o espaço reservado com a interface do usuário gerada dinamicamente. Exemplo: Criando dinamicamente um controle de entrada ui &lt;- fluidPage( textInput(&quot;label&quot;, &quot;Rótulo&quot;), selectInput(&quot;type&quot;, &quot;Tipo&quot;, c(&quot;slider&quot;, &quot;numerico&quot;)), uiOutput(&quot;controle&quot;) ) server &lt;- function(input, output, session) { output$controle &lt;- renderUI({ if (input$type == &quot;slider&quot;) { sliderInput(&quot;dynamic&quot;, input$label, value = 0, min = 0, max = 10) } else { numericInput(&quot;dynamic&quot;, input$label, value = 0, min = 0, max = 10) } }) } Embora mais personalizável, uma das desvantagens de renderUI() é que ele pode deixar o aplicativo mais lento. Assim, recomenda-se manter a maior parte possível da interface do usuário fixa, usando as técnicas descritas anteriormente. Exercícios 1. Usando uiOutput() e renderUI() Crie um app que mostre um tipo diferente de controle de entrada (textInput, numericInput ou sliderInput) dependendo da opção escolhida pelo usuário. Crie um app que pergunte ao usuário quantos nomes deseja informar (de 1 a 5) e mostre dinamicamente esse número de caixas de texto para preencher os nomes. Respostas ## a. ui &lt;- fluidPage( selectInput(&quot;tipo&quot;, &quot;Tipo de entrada:&quot;, choices = c(&quot;texto&quot;, &quot;número&quot;, &quot;slider&quot;)), uiOutput(&quot;entrada&quot;), verbatimTextOutput(&quot;resposta&quot;) ) server &lt;- function(input, output, session) { output$entrada &lt;- renderUI({ if (input$tipo == &quot;texto&quot;) { textInput(&quot;valor&quot;, &quot;Digite algo:&quot;) } else if (input$tipo == &quot;número&quot;) { numericInput(&quot;valor&quot;, &quot;Informe um número:&quot;, value = 0) } else if (input$tipo == &quot;slider&quot;) { sliderInput(&quot;valor&quot;, &quot;Escolha um valor:&quot;, min = 0, max = 100, value = 50) } }) output$resposta &lt;- renderPrint({ input$valor }) } ## ou server &lt;- function(input, output, session) { output$entrada &lt;- renderUI({ switch(input$tipo, &quot;texto&quot; = textInput(&quot;valor&quot;, &quot;Digite algo:&quot;), &quot;número&quot; = numericInput(&quot;valor&quot;, &quot;Informe um número:&quot;, value = 0), &quot;slider&quot; = sliderInput(&quot;valor&quot;, &quot;Escolha um valor:&quot;, min = 0, max = 100, value = 50) ) }) output$resposta &lt;- renderPrint({ input$valor }) } ## b. ui &lt;- fluidPage( numericInput(&quot;n&quot;, &quot;Quantos nomes?&quot;, value = 1, min = 1, max = 5), uiOutput(&quot;nomes&quot;) ) server &lt;- function(input, output, session) { output$nomes &lt;- renderUI({ req(input$n) lapply(1:input$n, function(i) { textInput(inputId = paste0(&quot;nome&quot;, i), label = paste(&quot;Nome&quot;, i)) }) }) # função lapply: aplica uma função a cada elemento de uma lista, # ou de vetor, retornando lista. lapply(list(1,2,3), function(i) i^2) # ou lapply(1:3, function(i) i^2) Acesso Professor 8.6 Publicando aplicativo em shinyapps.io 1. Instalar o pacote rsconnect no R Abra o R ou RStudio e execute: install.packages(&quot;rsconnect&quot;) 2. Criar uma conta no shinyapps.io Acesse: https://www.shinyapps.io Crie uma conta gratuira e faça login Após o login, vá até a aba Account &gt; Tokens &gt; Show &gt; Show secret &gt; Copy Copiar o código 3. Configurar sua conta e Publicar o App Abra o seu aplicativo no R Clique no ícone azul: “Publish the application” Clique em Conectar conta com shinyapps.io Cole o código copiado no campo especificado Selecione os arquivos da pasta que serão enviados para o app. Dê um nome para o app em “Title” Clique em “Publish” Se tudo estiver ok, o RStudio vai abrir o link do app na web, uma URL como: https://seu-usuario.shinyapps.io/nome-do-app/ Esse é o link público do seu app! 4. Compartilhando o app Copie o link gerado e envie para quem quiser acessar — não é necessário instalar nada! 5. Atualizações do app Sempre que fizer alterações no código, basta clucar no simbolo azul de publicação e fazer o envio novamente na conta conectada. O app será sobrescrito com a nova versão. Observações: Certifique-se de que seu app está salvo em uma pasta, contendo: Um único arquivo chamado app.R ou dois arquivos: ui.R e server.R Todos os arquivos adicionais (por exemplo, imagens, CSVs) também devem estar nessa mesma pasta. Para deletar o app ne sua conta acessar o app em shinyapps.io, arquivar e depois deletar. Exercício: Crie uma conta no shinyapps.io e publique o aplicativo a seguir: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;Meu Primeiro App&quot;), sidebarLayout( sidebarPanel( selectInput(&quot;var&quot;, &quot;Variável:&quot;, choices = names(mtcars)) ), mainPanel( plotOutput(&quot;grafico&quot;) ) ) ) server &lt;- function(input, output, session) { output$grafico &lt;- renderPlot({ hist(mtcars[[input$var]], main = input$var) }) } shinyApp(ui, server) 8.7 Exercícios do Capítulo 8 (Entregar na lista 2) 1. Pesquise a definição das funções req() e isolate() e dê exemplos simples da utilização de cada uma delas. 2. Crie uma UI em que o usuário escolha uma categoria (por ex., “Carro”, “Moto”, “Bicicleta”), e o app mostre campos específicos para essa categoria, usando abas escondidas. Além disso, que o app exiba no painel principal um resumo com o tipo e a informação específica do veículo (nº de portas, ano, tipo de bicicleta). Um selectInput(“veiculo”, “Tipo de veículo”, choices = …) Um tabsetPanel(type = “hidden”) com uma aba para cada tipo de veículo. No servidor, troque para a aba correspondente com updateTabsetPanel(). 3. Crie um aplicativo que plote, ggplot(diamonds, aes(carat)) mas permita que o usuário escolha qual geom usar: geom_histogram(), geom_freqpoly(), ou geom_density(). Use um conjunto de guias oculto para permitir que o usuário selecione argumentos diferentes dependendo do geom: geom_histogram() e geom_freqpoly() tenha um argumento binwidth; geom_density() tenha um argumento bw. 4. Construa um app Shiny que: Permita ao usuário escolher um conjunto de dados entre mtcars, iris e ToothGrowth. Mostre uma tabela com os dados e um resumo estatístico. Permita ao usuário selecionar uma variável quantitativa para plotar um histograma. O número de classes (bins) do histograma deve ser ajustável por um sliderInput(). Ao escolher um dataset, os inputs de escolha de variável devem ser atualizados dinamicamente por meio da família update*() de funções. O layout deve ser organizado com fluidRow() e column(). 5 Publique pelo menos um dos aplicativos criados nesta seção no shinyapps.io usando sua conta (plano gratuito) e encaminhe o link da URL do app publicado. "],["websites-com-rmarkdown.html", "Capítulo 9 Websites com RMarkdown 9.1 Criando um novo projeto 9.2 Estrutura do arquivo _site.yml 9.3 Editar os arquivos .Rmd 9.4 Renderizar o site 9.5 Publicando no GitHub 9.6 Ativar o GitHub Pages 9.7 Deletando um repositório", " Capítulo 9 Websites com RMarkdown Requisitos: Conta no GitHub R e RStudio instalados Pacotes: rmarkdown, knitr, usethis 9.1 Criando um novo projeto Abra o RStudio. Vá em File &gt; New Project &gt; New Directory &gt; Simple R Markdown Website. Escolha o nome da pasta e o diretório onde será salvo. O RStudio criará um projeto com os arquivos básicos: index.Rmd: página inicial about.Rmd: página “sobre” _site.yml: configurações do site 9.2 Estrutura do arquivo _site.yml Este arquivo controla o menu de navegação, os arquivos e o tema do site. name: &quot;meu_site&quot; output_dir: &quot;docs&quot; navbar: title: &quot;Meu Site&quot; left: - text: &quot;Início&quot; href: index.html - text: &quot;Sobre&quot; href: about.html output: html_document: theme: flatly highlight: textmate A linha output_dir: \"docs\" é importante para publicar no GitHub Pages. 9.3 Editar os arquivos .Rmd Personalize o index.Rmd e o about.Rmd com seu conteúdo: --- title: &quot;Bem-vindo ao Meu Site&quot; output: html_document --- # Olá! Este é o meu site feito com **RMarkdown**. 9.4 Renderizar o site Clique em Build &gt; Build All, ou execute no console: rmarkdown::render_site() Isso gera arquivos .html em uma pasta chamada docs/, que será usada para publicação. Obs.: Para adicionar mais abas ao site, criar outros arquivos .Rmd na mesma pasta, atualizar e salvar a informação em _site.yml. Após isso, compilar novamente o website em Build. 9.5 Publicando no GitHub 1. Criando um repositório no GitHub Acesse https://github.com. Crie um novo repositório. Nomeie o repositório em Repository name (ex: meusite). Defina o repositório como público para poder usar o Github Pages. 2. Subindo os arquivos via terminal Abra o terminal na pasta com os arquivos do site: git init git add . git commit -m &quot;Primeiro commit&quot; git branch -M main git remote add origin https://github.com/SEU_USUARIO/meusite.git git push -u origin main Digitar o nome de usuário e senha. Caso não lembre a senha, é possível gerar uma nova em: Settings &gt; Developer Settings &gt; Personal Acess Tokens &gt; Tokens e clicar em Generate new token. Deixe o campo repo selecionado dentre as opções de Select scopes Copie e salve o token gerado, pois ele só fica disponível uma vez. 3. Subindo os arquivos manualmente no github No repositório GitHub, clique em “uploading an existing file”; Arraste os arquivos ou clique em “choose your files” Depois clique em “Commit changes” Ideal para enviar poucos arquivos ou atualizações simples. 9.6 Ativar o GitHub Pages Acesse o repositório no GitHub. Vá em Settings &gt; Pages. Em Source, selecione: Deploy from a branch Em Branch, selecione: Select Branch: main Select folder: /docs Clique para salvar O GitHub publicará o site em uma URL como: https://seu-usuario.github.io/meusite/ Espere alguns segundos até o site estar no ar. Obs.: Você também pode criar sites personalizados usando o pacote blogdown do R (https://bookdown.org/yihui/blogdown/). 9.7 Deletando um repositório No repositório clicar em settings Rolar até o final da página em Danger Zone Clicar em Delete this repository e nas mensagens de confirmação subsequentes. Referências Gerador de sites do RMarkdown GitHub Pages Temas Bootstrap para RMarkdown blogdown: Criando sites com R Markdown Exercício Crie um novo projeto de Website simples em RMarkdown. Edite o conteúdo do site: No arquivo index.Rmd, mude o título e adicione um texto com seu nome e formação acadêmica. No arquivo about.Rmd escreva um parágrafo falando sobre você e seus interesses profissionais. Crie um novo arquivo, por exemplo portfolio.Rmd, com algumas imagens que representem seus interesses e vida acadêmica. Atualize o arquivo _site.yml para as páginas existentes e compile o site. Crie um novo repositório no github e faça o envio dos seus arquivos. Identifique se o site foi corretamente gerado no link: https://seu_usuario.github.io/seu_site/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
